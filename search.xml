<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Tensorflow、Pytorch、Ncnn中NCHW通道的总结]]></title>
    <url>%2F2021%2F09%2F05%2F%E5%85%B3%E4%BA%8ETensorflow%E3%80%81Pytorch%E3%80%81Ncnn%E4%B8%ADNCHW%E9%80%9A%E9%81%93%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目前深度学习训练和推理涉及到的输入数据通常为4-D，对应的通道格式主要有两种： NCHW NHWC 其中各个字母代表的含义为： N - Batch C - Channel 特征图通道 H - Height 特征图高度 W - Width 特征图宽度 各个框架和图像处理方式对图像数据要求如下： TensorFlow模型默认的输入格式为：RGB NHWC Pytorch模型默认的输入格式为：RGB NCHW ONNX模型默认的输入格式为：RGB NCHW fp32 Caffe 的Blob通道顺序是：NCHW TensorRT中通道顺序：NCHW OpenCV默认数据格式为：BGR HWC uint8 NCHW 则是 Nvidia cuDNN 默认格式，使用 GPU 加速时用 NCHW 格式速度会更快 一、基本原理如图所示，假定N = 2，C = 16，H = 5，W = 4，无论逻辑表达上是几维的数据，在计算机中存储时都是按照1D来存储的。下面很可以很清楚的看到NCHW和NHWC格式的高位数据，存储为1D时候的样子： 总的来说，无论是NCHW还是NHWC或者CHWN，在读取为1D时都是从后往前读，举例来说： 对于NCHW格式的4D数据，首先取W方向数据；然后H方向；再C方向；最后N方向。所以，序列化出1D数据为：000 (W方向) 001 002 003，(H方向) 004 005 … 019，(C方向) 020 … 318 319，(N方向) 320 321 … 对于NHWC格式的4D数据，首先取C方向数据；然后W方向；再H方向；最后N方向。所以，序列化出1D数据：000 (C方向) 020 … 300，(W方向) 001 021 … 303，(H方向) 004 … 319，(N方向) 320 340 … 我们通常在输入一张256 * 256分辨率的rgb图像时，对应的4D数据为[N = 1, H=256.h, W=256, C=3],然后对应的1D数据的组织方式如下图所示： NCHW: RRRRRRRRRRGGGGGGGGGGBBBBBBBBBB NHWC: RBGRGBRGBRGBRGBRGBRGBRGBRGBRGB 二、java调用tensorflow pb模型推理的简单运用第一种，若 Tensor.create(input) 输入的input是4维数组，那么按照tensorflow要求的NHWC的格式进行数据的组织即可：12345678910111213Imgproc.resize(src, dst, new Size(h, w)); // 1, h, w,3float input[][][][] = new float[1][h][w][3];System.out.println(dst.rows());System.out.println(dst.cols());for (int i = 0; i &lt; dst.cols(); i++) &#123; for (int j = 0; j &lt; dst.rows(); j++) &#123; double[] pixel = dst.get(j, i); input[0][i][j][0] = (float) (255 - pixel[0]); input[0][i][j][1] = (float) (255 - pixel[1]); input[0][i][j][2] = (float) (255 - pixel[2]); &#125;&#125;Tensor input_X = Tensor.create(input); 第二种，若 Tensor.create(input) 输入的input是1维数组，那么按照前面转1D数据的基本原理，将NHWC的格式进行转换后再组织即可：1234567891011121314Imgproc.resize(src, dst, new Size(h, w)); // 1, h, w,3float input[] = new float[1 * h * w * 3];System.out.println(dst.rows());System.out.println(dst.cols());int index = 0；for (int i = 0; i &lt; dst.cols(); i++) &#123; for (int j = 0; j &lt; dst.rows(); j++) &#123; double[] pixel = dst.get(j, i); input[index++] = (float) (255 - pixel[0]); input[index++] = (float) (255 - pixel[1]); input[index++] = (float) (255 - pixel[2]); &#125;&#125;Tensor input_X = Tensor.create(shape = (1,h,w,3),input);]]></content>
      <categories>
        <category>科研笔记</category>
        <category>论文部分</category>
      </categories>
      <tags>
        <tag>Tenforflow通道</tag>
        <tag>Pytorh通道</tag>
        <tag>NCHW</tag>
        <tag>NHWC</tag>
        <tag>模型通道转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（16）--最接近的三数之和（中等题）]]></title>
    <url>%2F2019%2F07%2F23%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8816%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:最接近的三数之和12345给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路：12345678910111213141516171819202122232425262728293031323334353637383940414243444546类似第15题，秒解```c++class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()==3)return nums[0]+nums[1]+nums[2]; sort(nums.begin(),nums.end()); int jilu_i=0,jilu_l=1,jilu_r=nums.size()-1; int min=abs(nums[jilu_i]+nums[jilu_l]+nums[jilu_r]-target); int l,r; for(int i=0;i&lt;nums.size();i++) &#123; l=i+1;r=nums.size()-1; while(l&lt;r) &#123; if(nums[i]+nums[l]+nums[r]==target) &#123; return target; &#125; else &#123; if(min&gt;abs(nums[i]+nums[l]+nums[r]-target)) &#123; min=abs(nums[i]+nums[l]+nums[r]-target); jilu_i=i; jilu_l=l; jilu_r=r; &#125; if(nums[i]+nums[l]+nums[r]&gt;target) &#123; r--; &#125; else &#123; l++; &#125; &#125; &#125; &#125; return nums[jilu_i]+nums[jilu_l]+nums[jilu_r]; &#125;&#125;;执行用时：12 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>最接近的三数之和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（11）--盛最多水的容器（中等题）]]></title>
    <url>%2F2019%2F07%2F23%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8811%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:盛最多水的容器123给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。 123456图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。示例:输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路：12345678910111213141516双指针游标，每游一次，对比当前值和最大值，保留最大值，然后判断左右谁小，谁小就移动谁。```c++class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int r=0,i=0,j=height.size()-1; while(i&lt;j) &#123; r=max(r,min(height[i],height[j])*(j-i)); (height[i]&lt;height[j])?i++:j--; &#125; return r; &#125;&#125;;执行用时：24 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>盛最多水的容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（15）--正则表达式匹配（困难题）]]></title>
    <url>%2F2019%2F06%2F14%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8815%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:正则表达式匹配123456789101112131415161718192021222324252627282930313233343536373839404142434445给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例 1:输入:s = "aa"p = "a"输出: false解释: "a" 无法匹配 "aa" 整个字符串。示例 2:输入:s = "aa"p = "a*"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。示例 3:输入:s = "ab"p = ".*"输出: true解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。示例 4:输入:s = "aab"p = "c*a*b"输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。示例 5:输入:s = "mississippi"p = "mis*is*p*."输出: false 解题思路：方法一：123456789101112131415161718192021222324递归解决方案：在想到递归之前，我一直想用最简单的if else解决，在理清了思路以后，发现每次遇到p[j]=='*'时就进行不下去了，这时我意识到自己的思路还没有理清，所以推倒重来。然后发现，其实可以把思路精简为如下3种情况进行思考： 1、当p[j]和s[i]都是字母的时候 此时非常好分析，直接比较即可，如果匹配则j++，i++就可以了 2、当p[j]='.'时 直接跳过p[j]进行到下一个即可，类似情况1 3、当p[j]='*' 这是最麻烦的一种情况，但是*可以这么理解，它相当于对前一个字符的补充说明，说明前一个字符到底是0个还是多个,那么就可以视为*是和字母或者'.'是绑定在一起的，每当匹配字母或者''就检查后面是否跟着一个'*'。举个栗子，s:abbc和p:ab*c 当检查到第一个b的时候，发现p中的b后有一个*，此时只有两种可能，一是跳过p中的b*，b*的含义相当于有0个b，那么这时就会让s中的第一个b和p中的c匹配，如果不成功，那么就进行第二种情况，b*的含义就为多个b,那么s往后移动一位，p不变，再然后就是s中的b与p当前的b比较，然后重复上述过程跳过b*，s中的c就会与p中的c进行匹配,匹配成功结束. 伪码如下：bool isMatch(string s, string p) &#123; 取p的第二个字符p[1],s的第一个字符s[0] if(p[1]=='*') &#123; 上述分析中的两种情况，1是p中的b*视为0个b，所以跳过；2是b*视为多个b，所以s往后移动一位 return isMatch(s,p.substr(2))||(isMatch(s.substr(1),p)); &#125; else &#123; 当p[0]为普通字母或者'.'时，s和p直接后移一位即可 return isMatch(s.substr(1),p.substr(1)); &#125; &#125;具体代码如下，基本就是将伪码就行完善 1234567891011121314151617class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.size()&lt;=0)return s.size()&lt;=0; bool match=(s.size()&gt;0&amp;&amp;(s[0]==p[0]||p[0]=='.')); if((p.size()&gt;1)&amp;&amp;(p[1]=='*')) &#123; return isMatch(s,p.substr(2))||(match&amp;&amp;isMatch(s.substr(1),p)); &#125; else &#123; return match&amp;&amp;isMatch(s.substr(1),p.substr(1)); &#125; &#125;&#125;;执行用时：548 ms 递归耗时严重，后续会增加其他方法，目前还在思考中。]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>正则表达式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【科研笔记】CTeX的套件中MiKTeX版本太低，无法更新包的解决办法]]></title>
    <url>%2F2018%2F12%2F11%2F%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91-CTeX%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当前CTeX套装中的MiKTeX过于陈旧，很多宏包已经无法自动更新了。因此，需要重新安装新版MiKTeX来解决问题。 工具准备：(1)CTeX套装： CTeX_2.9.2.164_Full.exe ，网址：www.ctex.org/CTeXDownload务必选择Full版本 (2)下载最新版 MiKTeX：basic-miktex-2.9.6753-x64.exe ，网址MiKTeX 开始安装：(1)安装CTeX，在如图一步时，不要勾选MiKTeX，因为默认的版本过低，已经没法连接上了，所以自己手动安装最新版。剩下就一路Next即可。 (2)安装下载好的最新版本的MikTeX：注意！！！在选择目录的时候，选择CTeX的安装目录，同时将MikTeX安装的文件夹的名字改为MiKTeX，如下图所示： (3)安装完毕以后，进入如下Miktex的控制台，并更新包。 最后注意PS：在编译时，可能出现报错或者无法生成pdf的情况，往往是因为包没有更新，所以进入Miktex的控制台更新包，然后再shift+ctrl+p再编译运行生成pdf一次就可以解决。]]></content>
      <categories>
        <category>科研笔记</category>
        <category>论文部分</category>
      </categories>
      <tags>
        <tag>CTeX</tag>
        <tag>MiKTeX</tag>
        <tag>windows api error 2</tag>
        <tag>windows api error 3</tag>
        <tag>MiKTeX包无法更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法作业1-右移数组]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1-%E5%8F%B3%E7%A7%BB%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:右移数组1已知一个长度为 n 的数组和一个正整数 k，并且最多只能使用一个用于交换数 组元素的附加空间单元，试设计算法得到原数组循环右移 k 次的结果并分析算法的时间复杂度。 解题思路：方法：在自己尝试的过程中，发现了一个很有趣的规律，例如 arr=1 2 3 4 5 n=5,k=2 显然右移两位以后的数组为 4 5 1 2 3 而该数组的逆序为 3 2 1 5 4 恰好是123 45子数组的逆序由此，该算法就很容易了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include "stdafx.h"#include &lt;string&gt;#include &lt;assert.h&gt;#include &lt;iostream&gt;using namespace std;void nixu(char* arr, int start, int end) &#123;//arr为数组，n为数组长度，k为右移位数 char tmp; while (start &lt; end) &#123; tmp = arr[start]; arr[start] = arr[end]; arr[end] = tmp; start++; end--; &#125;&#125;int main() &#123; int n = 0, k = 0, flag = 0; cout &lt;&lt; "请输入数组长度:"; cin &gt;&gt; n; char *arr = new char[n]; cout &lt;&lt; endl; cout &lt;&lt; "请输入数组:"; while (flag == 0) &#123; cin &gt;&gt; arr; if (strlen(arr) == n) &#123; flag = 1; &#125; else &#123; cout &lt;&lt; "请重新输入数组，因为数组长度不为n"&lt;&lt;endl; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "请输入右移次数:"; cin &gt;&gt; k; cout &lt;&lt; endl; nixu(arr, 0, n - k - 1); nixu(arr, n - k, n - 1); nixu(arr, 0, n - 1); cout &lt;&lt; arr; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>作业练习</category>
      </categories>
      <tags>
        <tag>逆序数组</tag>
        <tag>右移数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法作业3-多米诺骨牌]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:多米诺骨牌12现有 n 块 “多米诺骨牌” s1; s2; 。 。 。 ; sn 水平放成一排，每块骨牌 si 包含左右两 个部分，每个部分赋予一个非负整数值，如下图所示为包含 6 块骨牌的序列。骨牌可做 180 度旋转，使得原来在左边的值变到右边，而原来在右边的值移到左边，假设不论 si 如何旋转，L[i] 总是存储 si 左边的值，R[i] 总是存储 si 右边的值，W [i] 用于存储 si 的状态： 当 L[i] &lt;=R[i] 时记为 0，否则记为1，试采用分治法设计算法 解题思路：方法：在实验过程中，很容易观察到，在骨牌首尾补充两张牌00，00，就可以讲问题分成左右两个部分，就可以分别求出MAX0,MAX1,然后比较两者的值较大者就是题目要求的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int max_duominuo(int* L, int* R, int start,int end,int* w) &#123;//这里的start end是骨牌的序号 /*思路 很容易观察到，在骨牌收尾补充两张牌00，00，就可以讲问题分成左右两个部分，就可以分别求出MAX0,MAX1,然后比较两者的值 较大者就是题目要求的结果。 */ int mid = 0,maxL1,maxR1,MAX1, maxL0, maxR0, MAX0, tmp; if (end - start == 1)//此时证明只有两张牌，直接计算即可 &#123; return R[start] * L[end]; &#125; else &#123; mid = (start + end) / 2; if (L[mid] &gt; R[mid]) &#123; w[mid] = 1; maxL1=max_duominuo(L, R, start, mid, w); maxR1=max_duominuo(L, R, mid, end, w); MAX1 = maxL1 + maxR1; tmp = L[mid]; L[mid] = R[mid]; R[mid] = tmp; w[mid] = 0; maxL0 = max_duominuo(L, R, start, mid, w); maxR0 = max_duominuo(L, R, mid, end, w); MAX0 = maxL0 + maxR0; if (MAX1 &gt; MAX0) &#123; w[mid] = 1; return MAX1; &#125; else &#123; w[mid] = 0; return MAX0; &#125; &#125; else &#123; w[mid] = 0; maxL0 = max_duominuo(L, R, start, mid, w); maxR0 = max_duominuo(L, R, mid, end, w); MAX0 = maxL0 + maxR0; tmp = L[mid]; L[mid] = R[mid]; R[mid] = tmp; w[mid] = 1; maxL1 = max_duominuo(L, R, start, mid, w); maxR1 = max_duominuo(L, R, mid, end, w); MAX1 = maxL1 + maxR1; if (MAX1 &gt; MAX0) &#123; w[mid] = 1; return MAX1; &#125; else &#123; w[mid] = 0; return MAX0; &#125; &#125; &#125;&#125;int main() &#123; int n = 0,MAX=0; cout &lt;&lt; "请输入骨牌个数n="; cin &gt;&gt; n; if (n &lt;= 1) &#123; cout &lt;&lt; "骨牌过少，无法计算" &lt;&lt; endl; return 0; &#125; cout &lt;&lt; endl; int *L = new int[n+2]; int *R = new int[n+2]; int *w = new int[n+2]; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; "请输入骨牌S" &lt;&lt; i &lt;&lt; "的左骨牌数值: "; cin &gt;&gt; L[i]; cout &lt;&lt; "请输入骨牌S" &lt;&lt; i &lt;&lt; "的右骨牌数值: "; cin &gt;&gt; R[i]; cout &lt;&lt; endl; if (L[i] &lt;= R[i]) &#123; w[i] = 0; &#125; else &#123; w[i] = 1; &#125; &#125; R[0] = 0; L[0] = 0; L[n + 1] = 0; R[n + 1] = 0; MAX = max_duominuo(L,R,0,n+1,w); cout &lt;&lt; "最大值为：" &lt;&lt; MAX&lt;&lt;endl; cout &lt;&lt; "各个骨牌的状态为："; for (int i = 1; i &lt;=n; i++) &#123; cout &lt;&lt; w[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>作业练习</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>多米诺骨牌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（14）--最长公共前缀（简单题）]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8814%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:最长公共前缀12345678910111213141516编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。示例 1:输入: ["flower","flow","flight"]输出: "fl"示例 2:输入: ["dog","racecar","car"]输出: ""解释: 输入不存在公共前缀。说明:所有输入只包含小写字母 a-z 。 解题思路：方法：很简单，不赘述。 1234567891011121314151617181920212223242526272829303132333435static const auto io_speed_up= []()&#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); return 0;&#125;();class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string result=""; int i=0,j=1; if(strs.size()==1)return strs[0]; if(strs.size()==0)return ""; while(i&lt;strs[0].length()) &#123; while(j&lt;strs.size()) &#123; if(strs[j][i]==strs[0][i]) &#123; j++; &#125; else &#123; return result; &#125; &#125; j=1; result=result+strs[0][i]; i++; &#125; return result; &#125;&#125;;执行用时：4 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>最长公共前缀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（13）--罗马数字转整数（简单题）]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8813%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:罗马数字转整数123456789101112131415161718192021222324252627282930313233343536373839404142罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: "III"输出: 3示例 2:输入: "IV"输出: 4示例 3:输入: "IX"输出: 9示例 4:输入: "LVIII"输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: "MCMXCIV"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路：方法：很简单，不赘述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static const auto io_speed_up= []()&#123; std::ios::sync_with_stdio(false); cin.tie(nullptr); return 0;&#125;();class Solution &#123;public: int romanToInt(string s) &#123; int i=0,result=0; while(i&lt;s.size()) &#123; if(s[i]=='I'&amp;&amp;s[i+1]=='V') &#123; result=result+4; i=i+2; &#125; if(s[i]=='I'&amp;&amp;s[i+1]=='X') &#123; result=result+9; i=i+2; &#125; if(s[i]=='I'&amp;&amp;s[i+1]!='X'&amp;&amp;s[i+1]!='V') &#123; result=result+1; i++; &#125; if(s[i]=='V') &#123; result=result+5; i++; &#125; if(s[i]=='X'&amp;&amp;s[i+1]=='L') &#123; result=result+40; i=i+2; &#125; if(s[i]=='X'&amp;&amp;s[i+1]=='C') &#123; result=result+90; i=i+2; &#125; if(s[i]=='X'&amp;&amp;s[i+1]!='L'&amp;&amp;s[i+1]!='C') &#123; result=result+10; i++; &#125; if(s[i]=='L') &#123; result=result+50; i++; &#125; if(s[i]=='C'&amp;&amp;s[i+1]=='D') &#123; result=result+400; i=i+2; &#125; if(s[i]=='C'&amp;&amp;s[i+1]=='M') &#123; result=result+900; i=i+2; &#125; if(s[i]=='C'&amp;&amp;s[i+1]!='D'&amp;&amp;s[i+1]!='M') &#123; result=result+100; i++; &#125; if(s[i]=='D') &#123; result=result+500; i++; &#125; if(s[i]=='M') &#123; result=result+1000; i++; &#125; &#125; return result; &#125;&#125;;执行用时：40 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>罗马数字转整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（12）--整数转罗马数字（中等题）]]></title>
    <url>%2F2018%2F11%2F19%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8812%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:整数转罗马数字12345678910111213141516171819202122232425262728293031323334353637383940414243罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。示例 1:输入: 3输出: "III"示例 2:输入: 4输出: "IV"示例 3:输入: 9输出: "IX"示例 4:输入: 58输出: "LVIII"解释: L = 50, V = 5, III = 3.示例 5:输入: 1994输出: "MCMXCIV"解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路：方法：很简单，不赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143static const auto _ = []()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: string intToRoman(int num) &#123; int tmp = num; int q = tmp / 1000; tmp = tmp % 1000; int b = tmp / 100; tmp = tmp % 100; int s = tmp / 10; tmp = tmp % 10; int g = tmp; string result = ""; if (q != 0) &#123; if (q &lt;= 3) &#123; while (q) &#123; result = result + 'M'; q--; &#125; &#125; &#125; if (b != 0) &#123; if (b == 9) &#123; result = result + "CM"; &#125; else &#123; if (b == 4) &#123; result = result + "CD"; &#125; else &#123; if (b &lt;= 3) &#123; while (b) &#123; result = result + 'C'; b--; &#125; &#125; else//500~800 &#123; result = result + 'D'; b = b - 5; while (b) &#123; result = result + 'C'; b--; &#125; &#125; &#125; &#125; &#125; if (s != 0) &#123; if (s == 9) &#123; result = result + "XC"; &#125; else &#123; if (s == 4) &#123; result = result + "XL"; &#125; else &#123; if (s &lt;= 3) &#123; while (s) &#123; result = result + 'X'; s--; &#125; &#125; else//500~800 &#123; result = result + 'L'; s = s - 5; while (s) &#123; result = result + 'X'; s--; &#125; &#125; &#125; &#125; &#125; if (g != 0) &#123; if (g == 9) &#123; result = result + "IX"; &#125; else &#123; if (g == 4) &#123; result = result + "IV"; &#125; else &#123; if (g &lt;= 3) &#123; while (g) &#123; result = result + 'I'; g--; &#125; &#125; else//500~800 &#123; result = result + 'V'; g = g - 5; while (g) &#123; result = result + 'I'; g--; &#125; &#125; &#125; &#125; &#125; return result; &#125;&#125;;执行用时：32 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>整数转罗马数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（10）--三数之和（中等题）]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8810%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:三数之和1234567891011给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566思路有两种，一种是先排序，然后找到三元素，最后去重，难点是如何记录和去除重复的，此方法比较麻烦，所以放弃。第二种就是,先排序，然后固定一个值，接着用双指针的思想去找到相加为0的三元素，期间，遇到有重复的跳过即可。```c++class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(nums.size()&lt;3)return res; sort(nums.begin(),nums.end()); for(int mid=0;mid&lt;=nums.size()-1;mid++) &#123; if(nums[mid]&gt;0)break; if(mid&gt;0&amp;&amp;nums[mid]==nums[mid-1])continue; int l=mid+1,r=nums.size()-1; while(l&lt;r) &#123; if(nums[l]+nums[mid]+nums[r]==0) &#123; if(l==mid+1||r==nums.size()-1) &#123; res.push_back(vector&lt;int&gt;&#123;nums[l], nums[mid], nums[r]&#125;); l++; r--; &#125; else&#123; if(nums[l]==nums[l-1]) &#123; l++; &#125; else&#123; if(nums[r]==nums[r+1]) &#123; r--; &#125; else &#123; res.push_back(vector&lt;int&gt;&#123;nums[l], nums[mid], nums[r]&#125;); l++; r--; &#125; &#125; &#125; &#125; else &#123; if(nums[l]+nums[mid]+nums[r]&lt;0) &#123; l++; &#125; else &#123; r--; &#125; &#125; &#125; &#125; return res; &#125; &#125;;执行用时：140 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>三数之和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（9）--回文数（简单题）]]></title>
    <url>%2F2018%2F10%2F26%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:回文数1判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 1234567891011121314151617示例1:输入: 121输出: true示例2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？ 解题思路：方法：很简单，不赘述。 12345678910111213141516171819202122static const auto _ = []()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0)return false; if(x&lt;10)return true; int y=0,flag=x; while(x) &#123; y=y*10+x%10; x=x/10; &#125; return y==flag; &#125;&#125;;执行用时：56 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（8）--字符串转整数 (atoi)（中等题）]]></title>
    <url>%2F2018%2F10%2F23%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:字符串转整数 (atoi)12345678910111213实现 atoi，将字符串转为整数。该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。若函数不能执行有效的转换，返回 0。说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [$−2^{31}$, $2^{31} − 1$]1如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 12345678910111213141516171819202122232425示例1:输入: "42"输出: 42示例2:输入: " -42"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例3:输入: "4193 with words"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。示例4:输入: "words and 987"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例5:输入: "-91283472332"输出: -2147483648解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路：方法：只要注意细节就可以了很简单 1234567891011121314151617181920212223242526272829303132333435363738394041static const auto x=[]&#123; ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: int myAtoi(string str) &#123; int i,flag=0; long long int result=0; for(i=0;i&lt;str.size();i++) &#123; if(flag==0) &#123; if(str[i]==' ')continue; else if(str[i]=='+')flag = 1; else if(str[i]=='-')flag = -1; else if(str[i]-'0'&lt;10&amp;&amp;str[i]-'0'&gt;=0)&#123; result=result*10+(str[i]-'0'); flag = 1; &#125; else return 0; &#125; else &#123; if(str[i]-'0'&lt;10&amp;&amp;str[i]-'0'&gt;=0) &#123; result=result*10+(str[i]-'0'); if(flag*result&gt;INT_MAX)&#123;return INT_MAX;&#125; if(flag*result&lt;INT_MIN)&#123;return INT_MIN;&#125; &#125; else if(result!=0)break; else return 0; &#125; &#125; return flag*result; &#125;&#125;;执行用时：20 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串转整数</tag>
        <tag>atoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（7）--反转整数（简单题）]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:反转整数1给定一个 32 位有符号整数，将整数中的数字进行反转。 123456789101112131415示例1:输入: 123输出: 321示例2:输入: -123输出: -321示例3:输入: 120输出: 21注意:假设我们的环境只能存储 32 位有符号整数，其数值范围是 [$−2^{31}$, $2^{31} − 1$]。 1根据这个假设，如果反转后的整数溢出，则返回 0。 解题思路：方法：注意使用res*=10就可以了，过于简单 1234567891011121314151617181920212223static const auto x=[]&#123; ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: int reverse(int x) &#123; long long int res=0; while(x) &#123; res=res*10+x%10; if(res&gt;pow(2,31)-1||res&lt;-pow(2,31))return 0; x/=10; &#125; return res; &#125;&#125;;执行用时：4 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>反转整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（6）--Z字形变换（中等题）]]></title>
    <url>%2F2018%2F10%2F22%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt; 题目:Z字形变换1234567将字符串 "PAYPALISHIRING"以Z字形排列成给定的行数：P A H NA P L S I I GY I R之后从左往右，逐行读取字符："PAHNAPLSIIGYIR"实现一个将字符串进行指定行数变换的函数:string convert(string s, int numRows); 12345678910111213示例1:输入: s = "PAYPALISHIRING", numRows = 3输出: "PAHNAPLSIIGYIR"示例2:输入: s = "PAYPALISHIRING", numRows = 4输出: "PINALSIGYAHRPI"解释:P I NA L S I GY A H RP I 解题思路：方法：思路很简单，就是从左到右按照行数依次存入，就是按照题意的规律存。通过观察，可以发现，先存第一行，然后第二行只是第一行的每个数的左右两个字符依次存取，第三行是第一行每个数的左右间隔一个数的依次存取…..而第一行的规矩就是2（numRows-2）+2为两个字符之间的距离。第一行第一个字符，可以看做是第零行第一个字符的右下第一个字符，所以要先s[j+1],然后再存第零行第二个字符左下的字符所以是s[j+row0-i]i为行数从0开始计数。 12345678910111213141516171819202122class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&lt;=1)return s; int n=s.size(); int i=0,j=0; int row0=2*numRows-2; string res; for(i=0;i&lt;numRows;i++) &#123; for(j=0;j+i&lt;n;j=j+row0) &#123; res+=s[j+i]; if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;j+row0-i&lt;n) res+=s[j+row0-i]; &#125; &#125; return res; &#125;&#125;;执行用时：28 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Z字形变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（5）--最长回文子串（中等题）]]></title>
    <url>%2F2018%2F10%2F15%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[方法一耗时很长但是思路容易理解，还要接着想其他更好的方法呀，加油。 题目:最长回文子串1给定一个字符串s，找到s中最长的回文子串。你可以假设 s 的最大长度为1000。 12345678示例1:输入: "babad"输出: "bab"注意: "aba"也是一个有效答案。示例2:输入: "cbbd"输出: "bb" 解题思路：方法一：从头到尾遍历字符串s，当前后有字母相同时，证明有可能这两个字母间的串为最长回文串，所以，判断该串是否是回文串即可，若是则输出成新串new_s即可。而判断是否是回文串也很简单，一样的思路，如果遍历字符串，如果一直头尾相等，那么该串就是回文串了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: string longestPalindrome(string s) &#123; int m,n,max_length=0,m1,n1; string new_s=""; for(m=0,n=s.size()-1;m&lt;s.size();n--) &#123; if(s[m]==s[n]) &#123; if(is_huiwenstring(s,m+1,n-1)) &#123; if(n-m+1&gt;max_length) &#123; max_length=n-m+1; new_s=""; for(m1=m,n1=n;m1&lt;=n1;m1++) &#123; new_s=new_s+s[m1]; &#125; &#125; &#125; &#125; if(m==n) &#123; m++; n=s.size(); &#125; &#125; return new_s; &#125; bool is_huiwenstring(string s,int A,int B) &#123; int i=0,j=0; if((B-A+1)%2==0) &#123; for(i=A,j=B;i&lt;(B+A+1)/2;i++,j--) &#123; if(s[i]!=s[j]) &#123; return false; &#125; &#125; &#125; else &#123; for(i=A,j=B;i&lt;(B+A)/2;i++,j--) &#123; if(s[i]!=s[j]) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;执行用时：1328 ms 方法二：这个方法就是找到最长子串的中心，然后想外部扩展，使用了i、j的双游标。123456789101112131415161718192021222324252627282930313233343536static const auto __ = []() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;&#125;();class Solution &#123;public: string longestPalindrome(string s) &#123; int center=0,left=0,right=0,max_length=0,place=0; while(center&lt;s.size()) &#123; left=center; right=center; while(right&lt;s.size()&amp;&amp;s[right]==s[right+1])//右边的游标先从中心出发，这样就可以保证，无论回文子串是偶数长度还是奇数长度，left和right都可以分开。简单来说，因为在偶数的情况下，中心的两个字符必然相等，该操作等同于产生了左右两个中心，一个是原地不动的left_center，一个是r++了以后的right_center &#123; right++; &#125; center=right+1;//更新中心的位置 while(left&gt;=0&amp;&amp;right&lt;s.size()&amp;&amp;s[left]==s[right]) &#123; left--; right++; &#125; if(max_length&lt;right-left+1-2) &#123; max_length=right-left+1-2; place=left+1; &#125; &#125; return s.substr(place,max_length); &#125;&#125;;执行用时：4 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>最长回文子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（4）--两个排序数组的中位数（困难题）]]></title>
    <url>%2F2018%2F10%2F12%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[10分钟，一次AC并且超过了95%，还不错^.^ 题目:两个排序数组的中位数12给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。你可以假设 nums1 和 nums2 不同时为空。 123456789示例1:nums1 = [1, 3]nums2 = [2]中位数是 2.0示例2:nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 解题思路：方法：这题的思路很简单，当两个数组，有一个已经填充到arr完毕的时候，另外一组直接“贴”在最后即可，然后在取arr的中位数，这题过于简单了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int sizeall=0,i=0,j=0,k=0; sizeall=nums1.size()+nums2.size(); int arr[sizeall]=&#123;0&#125;; while(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size()) &#123; if(nums1[i]&lt;nums2[j]) &#123; arr[k]=nums1[i]; i++; &#125; else &#123; arr[k]=nums2[j]; j++; &#125; k++; &#125; if(i&lt;nums1.size()) &#123; while(i&lt;nums1.size()) &#123; arr[k]=nums1[i]; i++; k++; &#125; &#125; if(j&lt;nums2.size()) &#123; while(j&lt;nums2.size()) &#123; arr[k]=nums2[j]; j++; k++; &#125; &#125; if((sizeall)%2==0) &#123; return (arr[sizeall/2]+arr[(sizeall-1)/2])/2.0; &#125; else &#123; return (double)arr[sizeall/2]; &#125; &#125;&#125;;static const auto io_sync_off = []()&#123; // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;&#125;();执行用时：28 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双游标</tag>
        <tag>两个排序数组的中位数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（3）--无重复字符的最长子串（中等题）]]></title>
    <url>%2F2018%2F10%2F12%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[没有简单的题目，或者说，再简单的题目，只要追求极致，都会要花心思。好好加油吧&lt;-&gt; 题目:无重复字符的最长子串1给定一个字符串，找出不含有重复字符的最长子串的长度。 123456789101112131415示例1:输入: "abcabcbb"输出: 3 解释: 无重复字符的最长子串是 "abc"，其长度为 3。示例2:输入: "bbbbb"输出: 1解释: 无重复字符的最长子串是 "b"，其长度为 1。示例3:输入: "pwwkew"输出: 3解释: 无重复字符的最长子串是 "wke"，其长度为 3。 请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。 解题思路：方法1：首先，因为键盘可输入字符为128个，所以先int一个128的数组并且初始化为0，用此数组来记录是否重复，然后在循环中判断，如果为0，那么就累加长度，并且记录最大长度。然后在不为0的时候，再初始化数组为0。很明显，这个初始化很耗时，所以又想了下面的方法。 方法2：双游标，i,j两者之差j-i+1就是子串的长度，然后数组记录的不再是字符是否重复了，而是记录最后一个字母在s串中的位置。细节在于，i在字母重复的时候，会变成字母所在的位置，判断的时候的细节在于，重复的字母的位置如果在i的左边，则表示不会在i到j的子串中重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int arr[128]=&#123;0&#125;; int max_length=0,i,j; for(i=0,j=0;j&lt;s.size();++j) &#123; if(arr[(int)s[j]]==0||arr[(int)s[j]]-1&lt;i) &#123; arr[(int)s[j]]=j+1;//保持字符 s[j] 在s中的位置+1 比如0位 ，最后保存的是1 //length++; if(j-i+1&gt;max_length) &#123; max_length=j-i+1; &#125; &#125; else &#123; if(arr[(int)s[j]]-1&lt;i) &#123; &#125; else &#123; i=arr[(int)s[j]]; arr[(int)s[j]]=j+1; /*if(j-i&gt;max_length) &#123; max_length=j-i+1; &#125;*/ &#125; &#125; &#125; return max_length; &#125;&#125;;static const auto _____ = []() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;&#125;();执行用时：12 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>无重复字符的最长子串</tag>
        <tag>双游标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（2）--两数相加（中等题）]]></title>
    <url>%2F2018%2F10%2F11%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[没有简单的题目，或者说，再简单的题目，只要追求极致，都会要花心思。好好加油吧&lt;-&gt; 题目:两数之和12给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字0之外，这两个数字都不会以零开头。 1234示例:输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路：方法：1、判断了l1和l2是否存在，如果存在，就可以累加，然后将累加后产生的进位存起来 2、要考虑到两个表长度不一样，所以，在其中一个表已经空了以后，就要将进位的值消耗掉，如果两个表都为空了以后，进位还不为0，则最后一位必为1 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* result=new ListNode(0);//初始化第一个至为0 ListNode* tmp=result;//使用tmp记录每次计算了以后的余数，比如6+5=11 tmp=1 int sum_jinwei=0;//这个变量起到两个作用，一是用作l1与l2的相加的值sum，二是作为jinwei的值例如8+7=17，jinwei=1 while(l1||l2) &#123; if(l1) &#123; sum_jinwei=sum_jinwei+l1-&gt;val; l1=l1-&gt;next; &#125; if(l2) &#123; sum_jinwei=sum_jinwei+l2-&gt;val; l2=l2-&gt;next; &#125; tmp-&gt;next=new ListNode(sum_jinwei%10);//tmp-&gt;next就记录余数，也就是最后显示的值 sum_jinwei=sum_jinwei/10;//此时sum_jinwei就起到了携带进位的任务 tmp=tmp-&gt;next; &#125; if(sum_jinwei==1) &#123; tmp-&gt;next=new ListNode(1);//当sum_jinwei==1的时候就证明最高位必然为1 &#125; return result-&gt;next; &#125;&#125;;执行用时：24 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>两数相加</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题之旅（1）--两数之和（简单题）]]></title>
    <url>%2F2018%2F10%2F10%2FLeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法，永远是检验一个程序员的能力大小的重要指标，也是提升自身能力所必备的专业技能。所以现在就要动手练习，同时，可以对C++有更加深刻的认识和理解。而LeetCode上可以和各位算法爱好者一起学习，是一个很好的平台。好好加油吧&lt;-&gt; 题目:两数之和12给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 12345示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路：方法一：使用两个for循环，从头到尾遍历nums，同时对比即可，这个方法很简单，但是时间复杂度为O(n^2),实际的执行时间也到了180ms左右，显然不太好（代码在下面的注释里）。 方法二：使用以空间换时间的方法，那也就是哈希表了，这里的思路就是使用关联容器中的无序集合类型——unordered_map。在C++11中关联容器支持高效的关键字查找和访问。在此题中，使用map的思路就是，首先看是否能够find到target-nums[i]的值，如果能找到，就说明在nums中存在两个数字满足题意，那么直接返回两者的对应下标即可，也就是i，和r[key]；如果找不到target-nums[i]，那么就初始化map的键值对，这里可能乍一看怎么没有初始化map，其实不然，每一次没有找到就会初始化一个值，这样效率最高。例如：实例中的例子，一开始的key=9-2=7,map此时为空，所以找不到，那么初始化r[2]=0,然后再循环key=9-7=2，刚好有2，然后就可以返回下标i=1,r[2]=0，完毕。1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt;r; int i=0; for(i=0;i&lt;nums.size();i++) &#123; int key=target-nums[i]; if(r.find(key)!=r.end()) &#123; return vector&lt;int&gt;(&#123;i,r[key]&#125;); &#125; r[nums[i]] = i; &#125; &#125; /* vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; result.push_back(i); result.push_back(j); return result; &#125; &#125; &#125;*/&#125;;执行用时：8 ms]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode刷题之旅</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>两数之和</tag>
        <tag>unordered_map</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》尾声（9）]]></title>
    <url>%2F2018%2F03%2F15%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%B0%BE%E5%A3%B0%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[让mkfs()只执行一次目前我们的操作系统每次启动都是“全新的”，因为每一次init_fs()都会调用mkfs()刷新硬盘，每次启动时可以保证文件系统是一样，但它也存在明细的坏处，那就是上次建立的文件到下一次启动时就不见了。下面就来改变现状：1234567891011121314151617181920212223242526272829303132PRIVATE void init_fs()&#123; int i; /* f_desc_table[] */ for (i = 0; i &lt; NR_FILE_DESC; i++) memset(&amp;f_desc_table[i], 0, sizeof(struct file_desc)); /* inode_table[] */ for (i = 0; i &lt; NR_INODE; i++) memset(&amp;inode_table[i], 0, sizeof(struct inode)); /* super_block[] */ struct super_block * sb = super_block; for (; sb &lt; &amp;super_block[NR_SUPER_BLOCK]; sb++) sb-&gt;sb_dev = NO_DEV; /* open the device: hard disk */ MESSAGE driver_msg; driver_msg.type = DEV_OPEN; driver_msg.DEVICE = MINOR(ROOT_DEV); assert(dd_map[MAJOR(ROOT_DEV)].driver_nr != INVALID_DRIVER); send_recv(BOTH, dd_map[MAJOR(ROOT_DEV)].driver_nr, &amp;driver_msg); /* read the super block of ROOT DEVICE */ RD_SECT(ROOT_DEV, 1); sb = (struct super_block *)fsbuf; if (sb-&gt;magic != MAGIC_V1) &#123; printl("&#123;FS&#125; mkfs\n"); mkfs(); /* make FS */ &#125; 只需要每次先读取超级块，如果发现魔数，则认为分区已经操作系统，否则调用mkfs()。然后在untar()上留下记号，让它不再一股脑的解压了。运行结果如下： 从硬盘引导前面都是从软盘引导的，现在我们从硬盘引导，先看看软盘引导的过程： BIOS将引导扇区读入内存0000：7c00处 跳转到0000:7c00处开始执行引导代码 引导代码从软盘中找到loader.bin，并将其读入内存 跳转到loader.bin开始执行 loader.bin从软盘中找到kernel.bin，并将其读入内存 跳转到kernel.bin开始执行，到此可认为启动过程结束 系统运行硬盘启动和软盘的启动的区别在于第一步，BIOS到底是读谁，由CMOS设置决定，通常可以找到一个叫做Boot Sequence的选项，从中选择首选启动设备。在第3步和第5步中，对于软盘启动，代码将在软盘中寻找loader.bin和kernel.bin，对应硬盘启动，我们需要让引导扇区代码从硬盘中寻找loader.bin和kernel.bin。grub将引导扇区安装到我们的操作系统分区的引导扇区，而不是整块硬盘的引导扇区，这样操作系统就可以和硬盘上其他操作系统和平共处了。只需要安装一个grub就可以了将OS安装到真实的计算机]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>硬盘启动</tag>
        <tag>grub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》内存管理（8）]]></title>
    <url>%2F2018%2F03%2F14%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[fork认识fork生成一个子进程的系统调用被成为fork()，操作系统接到一个fork请求后，会将调用者复制一份，这时就会有两个一模一样的进程同时进行。其中子进程是从父进程得到数据、堆栈以及代码而来的。我们最先要解决的问题是，谁作为最开始的父进程？参考Linux以及Minix可以知道是init进程，所以我们先写出Init进程：12345678910111213141516171819void Init()&#123; int fd_stdin = open("/dev_tty0", O_RDWR); assert(fd_stdin == 0); int fd_stdout = open("/dev_tty0", O_RDWR); assert(fd_stdout == 1); printf("Init() is running ...\n"); int pid = fork(); if (pid != 0) &#123; /* parent process */ printf("parent is running, child pid:%d\n", pid); spin("parent"); &#125; else &#123; /* child process */ printf("child is running, pid:%d\n", getpid()); spin("child"); &#125;&#125; 可以看到其中调用了即将实现的fork()，而且判定了返回值。如果返回0则表明自己是子进程，否则返回的是子进程的pid并表明自己是父进程。然后我们要增加MM进程，它将负责从用户进程接受消息。下图是一个进程涉及的所有数据结构以及相互联系： fork前要做好的工作 在proc_table[]中预留出一些空白项，供新进程使用 在proc_table[]中的每一个进程表项中的idt_sel项都设定好 将进程所需的GDT表项都初始化好fork()库函数1234567891011PUBLIC int fork()&#123; MESSAGE msg; msg.type = FORK; send_recv(BOTH, TASK_MM, &amp;msg); assert(msg.type == SYSCALL_RET); assert(msg.RETVAL == 0); return msg.PID;&#125; MM和文件管理进程一样，MM要有一个主消息循环，如下：1234567891011121314151617181920212223242526272829303132333435363738PUBLIC void task_mm()&#123; init_mm(); while (1) &#123; send_recv(RECEIVE, ANY, &amp;mm_msg); int src = mm_msg.source; int reply = 1; int msgtype = mm_msg.type; switch (msgtype) &#123; case FORK: mm_msg.RETVAL = do_fork(); break; case EXIT: do_exit(mm_msg.STATUS); reply = 0; break; /* case EXEC: */ /* mm_msg.RETVAL = do_exec(); */ /* break; */ case WAIT: do_wait(); reply = 0; break; default: dump_msg("MM::unknown msg", &amp;mm_msg); assert(0); break; &#125; if (reply) &#123; mm_msg.type = SYSCALL_RET; send_recv(SEND, src, &amp;mm_msg); &#125; &#125;&#125; 当MM接到FORK消息后，调用do_fork()来处理。在内存的分配上，我们采用固定内存的方式，每个内存块大小为1MB。fork()系统调用的结果余下： exit和wait生成子进程最重要的是fork()，而进程的消亡则是用到系统调用exit()。而系统调用wait()是父进程得到返回值的方法，用该系统调用挂起，等子进程退出时，wait()调用方结束，并且父进程因此得带返回值。1234567891011int pid = fork(); if (pid != 0) &#123; /* parent process */ printf("parent is running, child pid:%d\n", pid); int s; int child = wait(&amp;s); printf("child (%d) exited with status: %d.\n", child, s); &#125; else &#123; /* child process */ printf("child is running, pid:%d\n", getpid()); exit(123); &#125; 和fork()类似，上述两个系统调用同样是发送消息给MM，它们发送的消息分别是EXIT和WAIT。并由MMM中对应的消息函数进行处理。do_exit/do_wait和msg_send/msg_receive这两对函数是类似的例如，假设进程P有子进程。而A调用exit()，那么MM会： 告诉FS：A退出，请做出相应处理 释放A占用的内存 判断P是否正在WAITING 遍历proc_table[]如果P调用wait()，那么MM将会： 遍历proc_table[]。 如果P的子进程没有一个在HANGING，则设P的WITING位 如果P没有子进程，则向P发送消息，消息携带一个表示出错的返回值。完成了这以后，子进程的产生和消亡都有了，运行一下，结果如图：exec认识execexec的语义很简单，它将当前的进程映像替换成另一个。也就是说我们可以从硬盘上读取另一个可执行的文件，用它替换掉刚刚被fork出来的子进程，于是被替换的子进程就成为了新进程。下面的exec()的代码：12345678910int pid = fork(); if (pid != 0) &#123; /* parent process */ printf("parent is running, child pid:%d\n", pid); int s; int child = wait(&amp;s); printf("child (%d) exited with status: %d.\n", child, s); &#125; else &#123; /* child process */ execl("/echo", "echo", "hello", "world", 0); &#125; 为自己的操作系统编写应用程序例如Linux中的echo，它和操作系统的接口是系统调用。本质上，一个应用程序只能调用两种东西：属于自己的函数，以及中断。写一个echo最笨的方法就是将send_recv()、printf()、write()等所有用到的系统调用的代码都复制到源文件中，然后编译下。而更好的做法是制作一个类似C运行时库的东西，我们把之前已经写好的应用程序可以使用的库函数单独链接成一个文件，每次写应用程序时的时候直接链接起来就好了。到目前位置，可以被用来链接成库的文件及其包含的主要函数有这些： 真正的系统调用：sendrec和printx:lib/syscall.asm 字符串操作：memcpy、memset、strcpy、strlen：lib/string.asm FS的接口：lib/open.c lib/read.c lib/write.c lib/close.c lib/unlink.c MM的接口：lib/fork.c lib/exit.c lib/wait.c SYS的接口：lib/getpid.c 其他：lib/misc.c lib/vsprintf.c lib/printf.c把这些函数单独链接成一个库，起名为orangescrt.a表明这是我们的C运行时库.现在先写一个最简单的echo：1234567891011#include "stdio.h"int main(int argc, char * argv[])&#123; int i; for (i = 1; i &lt; argc; i++) printf("%s%s", i == 1 ? "" : " ", argv[i]); printf("\n"); return 0;&#125; 编译链接：123gcc -I ../include/ -c -fno-builtin -Wall -o echo.o echo.cnasm -I ../include/ -f elf -o start.o start.asmld -Ttext 0x1000 -o echo echo.o start.o ../lib/orangescrt.a 安装应用程序安装程序到我们的文件系统中，需要做以下工作： 编程应用程序，并编译链接 将链接好的应用程序打成一个tar包：inst.tar 将inst.tar用工具dd写入磁盘的某段特定扇区 启动系统，这时mkfs()会在文件系统中建立一个新文件cmd.tar，它的inode中的i_start_sect成员会被设为X 在某个进程中将cmd.tar解包，将其中包含的文件存入文件系统。运行结果如下：简单的shellshell可以很复杂，我们这里是实现读取命令并执行：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106void shabby_shell(const char * tty_name)&#123; int fd_stdin = open(tty_name, O_RDWR); assert(fd_stdin == 0); int fd_stdout = open(tty_name, O_RDWR); assert(fd_stdout == 1); char rdbuf[128]; while (1) &#123; write(1, "$ ", 2); int r = read(0, rdbuf, 70); rdbuf[r] = 0; int argc = 0; char * argv[PROC_ORIGIN_STACK]; char * p = rdbuf; char * s; int word = 0; char ch; do &#123; ch = *p; if (*p != ' ' &amp;&amp; *p != 0 &amp;&amp; !word) &#123; s = p; word = 1; &#125; if ((*p == ' ' || *p == 0) &amp;&amp; word) &#123; word = 0; argv[argc++] = s; *p = 0; &#125; p++; &#125; while(ch); argv[argc] = 0; int fd = open(argv[0], O_RDWR); if (fd == -1) &#123; if (rdbuf[0]) &#123; write(1, "&#123;", 1); write(1, rdbuf, r); write(1, "&#125;\n", 2); &#125; &#125; else &#123; close(fd); int pid = fork(); if (pid != 0) &#123; /* parent */ int s; wait(&amp;s); &#125; else &#123; /* child */ execv(argv[0], argv); &#125; &#125; &#125; close(1); close(0);&#125;/***************************************************************************** * Init *****************************************************************************//** * The hen. * *****************************************************************************/void Init()&#123; int fd_stdin = open("/dev_tty0", O_RDWR); assert(fd_stdin == 0); int fd_stdout = open("/dev_tty0", O_RDWR); assert(fd_stdout == 1); printf("Init() is running ...\n"); /* extract `cmd.tar' */ untar("/cmd.tar"); char * tty_list[] = &#123;"/dev_tty1", "/dev_tty2"&#125;; int i; for (i = 0; i &lt; sizeof(tty_list) / sizeof(tty_list[0]); i++) &#123; int pid = fork(); if (pid != 0) &#123; /* parent process */ printf("[parent is running, child pid:%d]\n", pid); &#125; else &#123; /* child process */ printf("[child is running, pid:%d]\n", getpid()); close(fd_stdin); close(fd_stdout); shabby_shell(tty_list[i]); assert(0); &#125; &#125; while (1) &#123; int s; int child = wait(&amp;s); printf("child (%d) exited with status: %d.\n", child, s); &#125; assert(0);&#125; 运行结果如下： PS:不知道为何在虚拟机下Ubuntu+Bochs就无法在Bochs里使用CTRL+Fn键！！！！]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》文件管理（7-2）]]></title>
    <url>%2F2018%2F03%2F10%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%887-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在硬盘上制作一个文件系统 文件系统通常有两个含义： 用于存储和组织计算机文件数据的一套方法 存在于某介质上的具备某种格式的数据我们所做的工作是第一种，所以我们需要考虑如何利用空间，如何对文件进行添加、删除以及修改，还要考虑不同类型的文件如何并存于一个文件系统。当我们说某个硬盘分区是“某某文件系统”时，是说的第二种，其格式表名这个分区是由某种策略和机制来管理。文件系统设计的数据结构主要有超级块、i-node和目录项。超级块主要关注以下内容： 文件系统的标识。 文件系统最多允许有多少个i-node。 inode_array占用多少扇区。 文件系统总共扇区数是多少 inode-map占用多少扇区 sector-map占用多少扇区 第一个数据扇区的扇区号是多少 根目录区的i-node号是多少 编码建立文件系统建立文件系统的函数mkfs()分为如下几部分： 向硬盘驱动程序索取ROOT_DEV的起始扇区和大小 建立超级块 建立inode-map 建立sector-map 写入inode-array 建立根目录文件在函数mkfs()中，所有写入磁盘的内容都是先放进fsbuf这个缓冲区的，与通常的做法不同，没有定义一个数组，而是定义了一个指针，让它指向0x600000.也就是说，指定内存地址6MB~7MB为系统文件的缓冲区。在建立FS的过程中，写扇区的函数都是WR_SECT这个宏来完成的。下面来执行一下，结构如图： 创建文件对文件进行创建以及读写等操作，需要用到open()、write()、read()、close()等系统调用，而这些熊调用都用到了一个变量——fd，文件描述符（file descriptor）。如下是它的结构图：其中fd_mode用来记录这个fd是用来做什么操作的。fd_pos用来记录读写到了文件的什么位置。fd_inode便是指向inode的指针。每当一个进程打开一个文件——无论是打开一个已经存在的还是创建一个新的，该进程的进程变filp数组就会分配一个文职——假设是k，用于存放打开文件的fd指针，而这个k就是返回给用户进程open()函数的返回值了。 open()现在用户进程中创建一个文件：1234567void TestA()&#123; int fd = open("/blah",O_CREAT); printf("fd:%d\n",fd); close(fd); spin("TESTA");&#125; 下面是open()的系统调用：123456789101112131415PUBLIC int open(const char *pathname, int flags)&#123; MESSAGE msg; msg.type = OPEN; msg.PATHNAME = (void*)pathname; msg.FLAGS = flags; msg.NAME_LEN = strlen(pathname); send_recv(BOTH, TASK_FS, &amp;msg); assert(msg.type == SYSCALL_RET); return msg.FD;&#125; 发了一个OPEN消息给文件系统，所以文件系统需要处理它：12345678910111213141516171819202122232425262728293031PUBLIC void task_fs()&#123; printl("Task FS begins.\n"); init_fs(); while (1) &#123; send_recv(RECEIVE, ANY, &amp;fs_msg); int src = fs_msg.source; pcaller = &amp;proc_table[src]; switch (fs_msg.type) &#123; case OPEN: fs_msg.FD = do_open(); break; case CLOSE: fs_msg.RETVAL = do_close(); break; ..... default: dump_msg("FS::unknown message:", &amp;fs_msg); assert(0); break; &#125; /* reply */ fs_msg.type = SYSCALL_RET; send_recv(SEND, src, &amp;fs_msg); &#125;&#125; 其中用do_open来专门处理OPEn消息，首先是从消息内对出各项参数，其中需要格外注意的是文件名的读取。 创建文件所设计的其他函数strip_path()该函数用于把路径分为文件名和文件夹两个部分，定位直接包含文件的文件夹，并得到给定文件在此文件夹中的名称。 search_file()用来得到文件所在目录的i-node，通过这个i-node来得到目录所在的扇区，然后读取这些扇区，查看里面是否有我们要找的文件，如果找到就返回文件的i-node，如果没有就返回0. do_clode()关闭文件显得十分简单，CLOSE消息是由do_close()来处理。完成了open()和close()两个系统调用，我们接着运行一下：可以看到进程TestA打印出了新创建的文件的fd:0。 打开文件打开文件其实就是根据文件名找到i-node，并且建立进程表、f_desc_table[]和inode_table[]之间的关联。对于普通文件而言，打开操作有以下情况： 文件存在。这时我们获得文件的i-node号，读出i-node，建立前面所述三表的关联，并返回fd。 文件不存在。直接返回-1。 文件不存在。创建文件，建立前面所述的关联，并返回fd。读写文件因为采取一次分配的原则，所以读写变得比较简单，但是这个方式并不好。在读写的过程中，我们任然是把它扔给相应的驱动程序——虽然驱动程序并未准备还处理，但发送一个消息只是举手之劳。下面是read()函数123456789101112PUBLIC int read(int fd, void *buf, int count)&#123; MESSAGE msg; msg.type = READ; msg.FD = fd; msg.BUF = buf; msg.CNT = count; send_recv(BOTH, TASK_FS, &amp;msg); return msg.CNT;&#125; 下面是write():123456789101112PUBLIC int write(int fd, const void *buf, int count)&#123; MESSAGE msg; msg.type = WRITE; msg.FD = fd; msg.BUF = (void*)buf; msg.CNT = count; send_recv(BOTH, TASK_FS, &amp;msg); return msg.CNT;&#125; 测试文件读写修改TestA代码如下：123456789101112131415161718192021222324252627282930313233343536373839void TestA()&#123; int fd; int n; const char filename[] = "blah"; const char bufw[] = "abcde"; const int rd_bytes = 3; char bufr[rd_bytes]; assert(rd_bytes &lt;= strlen(bufw)); /* create */ fd = open(filename, O_CREAT | O_RDWR); assert(fd != -1); printf("File created. fd: %d\n", fd); /* write */ n = write(fd, bufw, strlen(bufw)); assert(n == strlen(bufw)); /* close */ close(fd); /* open */ fd = open(filename, O_RDWR); assert(fd != -1); printf("File opened. fd: %d\n", fd); /* read */ n = read(fd, bufr, rd_bytes); assert(n == rd_bytes); bufr[n] = 0; printf("%d bytes read: %s\n", n, bufr); /* close */ close(fd); spin("TestA");&#125; 运行结果如图; 文件系统调试随着代码越来越多，我们需要其他调试手段，比如我们有了硬盘驱动和文件系统，我们可以直接开始写log。由于文件系统比较初级，所以Ilog可以直接通过硬盘驱动写入某个扇区。下图是log。我们可以将log写出某种特定的格式，比如这个存成DOT源文件，然后用dd命令将磁盘映像中我们写入的log扇区抽取出来，存成本地文件，用bash脚本或线程的工具将log中的dot部分抽取出来，存成一个或多个文件，然后用graphviz包里面的工具将其装换成可视文件格式。 删除文件删除是添加的反过程，以下是我们要做的工作： 释放inode-map中的相应位 释放sector-map中的相应位。 将inode_array中的i-node清零 删除根目录中的目录项运行结果如下：我们创建了”foo”、”bar”、”baz”三个文件，然后删除，另外删除”/dev_tty0”，这时也被制止了。为文件系统添加系统调用的步骤 定义一种消息，比如MMM。 写一个函数来处理MMM消息。 修改task_fs()，增加对消息MMM的处理。 写一个用户接口函数XXX()将TTY纳入文件系统假设进程P要求读取TTY，它会发送消息给文件系统，文件系统将消息传递给TTY，TTY记下发出请求的进程号等信息之后立即返回，而文件系统这时并不对P接触阻塞，因为结果还没有准备好，在接下来的过程中，文件系统像往常一样等待来自任何进程的请求。而TTY则会将键盘输入复制进P传入的内存地址，一直遇到回车，TTY就告诉文件系统，P的请求已被满足，文件系统会接触对P的阻塞，于是整个读取工作结束。在写TTY时，P发消息给文件系统，文件 系统传递给TTY，TTY收到消息后立即将字符写入显存，完成后发消息给文件系统，文件系统再发消息给P，整个过程结束。作为驱动程序，TTY接受并处理DEV_OPEN、DEV_READ、DEV_WRITE消息。DEV_READ、DEV_WRITE分别有对应的函数tty_do_read()、tty_do_write()来处理。tty_caller用来保存想TTY发送消息的进程的进程号。tty_procnr用来保存请求数据的进程的进程号。tty_req_buf保存进程P用来存放读入字符的缓冲区的线性地址。tty_left_cnt保存P想读入的字符数。tty_trans_cnt保存TTY已经向P传送了多少字符。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>文件读写</tag>
        <tag>文件描述符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》文件管理（7-1）]]></title>
    <url>%2F2018%2F03%2F10%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%887-1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在本部分，将通过硬盘驱动程序直接操作硬盘。在编写这个文件系统的过程中，通过几个消息、用户进程、文件系统和驱动程序之间就可以方便的协同工作。 硬盘操作的I/O端口和键盘控制器、VGA控制器等类似，对硬盘控制器的操作仍然是通过I/O端口来进行，这些端口分为两组，它们对应命令块寄存器和控制块寄存器，如下表：对硬盘的操作并不复杂，只需要往命令块寄存器写入正确的值，再通过控制块寄存器发送命令就可以了。 硬盘驱动程序驱动程序的作用在于隐藏硬件细节，向上层提供统一的接口。由于进程通过收发消息来相互通信，那么驱动程序的接口自然也是消息了。所以只要定义了驱动程序可以接受的消息，也就定义了驱动程序的接口。首先想硬盘驱动器发送一个IDENTIFY命令，这个命令可用来获取硬盘参数。下面是Device寄存器的格式：可以看到寄存器主要有LBA模式位、DRV位和低四位。DRV用于指定主盘或从盘，0表示主盘，1表示从盘。LBA模式位用于指定操作模式，当此位为0时，对磁盘的操作使用CHS模式；当为1时，对磁盘使用LBA模式。我们使用函数hd_cmd_out()来进行实际的向硬件驱动器发送命令的工作，因为今后我们还会用到它。当发送命令之后，我们用interrupt_wait()来等待中断的发生。驱动程序获知中断发生的情形如下：建立如下文件系统进程：1234567891011PUBLIC void task_fs()&#123; printl("Task FS begins.\n"); /* open the device: hard disk */ MESSAGE driver_msg; driver_msg.type = DEV_OPEN; send_recv(BOTH, TASK_HD, &amp;driver_msg); spin("FS");&#125; make运行，结果如下： 文件系统我们结合前面学习的FAT12来了解文件系统，从下图可知，文件系统有4个部分： 引导扇区：存放Metadata—占用整整一个扇区的superblock FAT表：记录扇区使用情况—sector map 根目录区：文件的索引—inode map 数据区：记录任一文件的信息—root数据区 superblock通常也叫超级块，关于文件系统的Metadata都记录在这里。sector map是哟个位图，用来映射扇区的使用情况，用1表示扇区已经被使用。i-node是UNIX各种文件系统的核心数据结构之一。 硬盘分区表硬盘分区表是一个结构体数组，数组的每个成员是一个16字节的结构体，如下：我们将80MB的硬盘映像分成了一个主分区和一个扩展分区，扩展分区中又分成了5个逻辑分区。我们以后把写的操作系统放在第一个逻辑分区。先把它的分区类型（Systen ID）改成99h，又维他设定了“可启动”标志。 设备号下图是所有分区：其中数字1~4为主引导扇区中的分区表项所示，从5开始依次表示逻辑分区。这些数字其实就是设备号，其作用是给每个设备起一个名字，这样驱动程序就能方便地管理他们。对硬盘而言，采用如下的编号规则：下面是遍历所有分区的情况： 完善硬盘驱动程序目前的驱动程序只能处理DEV_OPEN消息，这显然是不够的，起码也要有DEV_READ和DEV_WRITE。下面先添加读写硬盘的功能：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199/***************************************************************************** * task_hd *****************************************************************************//** * Main loop of HD driver. * *****************************************************************************/PUBLIC void task_hd()&#123; MESSAGE msg; init_hd(); while (1) &#123; send_recv(RECEIVE, ANY, &amp;msg); int src = msg.source; switch (msg.type) &#123; case DEV_OPEN: hd_open(msg.DEVICE); break; case DEV_CLOSE: hd_close(msg.DEVICE); break; case DEV_READ: case DEV_WRITE: hd_rdwt(&amp;msg); break; case DEV_IOCTL: hd_ioctl(&amp;msg); break; default: dump_msg("HD driver::unknown msg", &amp;msg); spin("FS::main_loop (invalid msg.type)"); break; &#125; send_recv(SEND, src, &amp;msg); &#125;&#125;/***************************************************************************** * init_hd *****************************************************************************//** * &lt;Ring 1&gt; Check hard drive, set IRQ handler, enable IRQ and initialize data * structures. *****************************************************************************/PRIVATE void init_hd()&#123; int i; /* Get the number of drives from the BIOS data area */ u8 * pNrDrives = (u8*)(0x475); printl("NrDrives:%d.\n", *pNrDrives); assert(*pNrDrives); put_irq_handler(AT_WINI_IRQ, hd_handler); enable_irq(CASCADE_IRQ); enable_irq(AT_WINI_IRQ); for (i = 0; i &lt; (sizeof(hd_info) / sizeof(hd_info[0])); i++) memset(&amp;hd_info[i], 0, sizeof(hd_info[0])); hd_info[0].open_cnt = 0;&#125;/***************************************************************************** * hd_open *****************************************************************************//** * &lt;Ring 1&gt; This routine handles DEV_OPEN message. It identify the drive * of the given device and read the partition table of the drive if it * has not been read. * * @param device The device to be opened. *****************************************************************************/PRIVATE void hd_open(int device)&#123; int drive = DRV_OF_DEV(device); assert(drive == 0); /* only one drive */ hd_identify(drive); if (hd_info[drive].open_cnt++ == 0) &#123; partition(drive * (NR_PART_PER_DRIVE + 1), P_PRIMARY); print_hdinfo(&amp;hd_info[drive]); &#125;&#125;/***************************************************************************** * hd_close *****************************************************************************//** * &lt;Ring 1&gt; This routine handles DEV_CLOSE message. * * @param device The device to be opened. *****************************************************************************/PRIVATE void hd_close(int device)&#123; int drive = DRV_OF_DEV(device); assert(drive == 0); /* only one drive */ hd_info[drive].open_cnt--;&#125;/***************************************************************************** * hd_rdwt *****************************************************************************//** * &lt;Ring 1&gt; This routine handles DEV_READ and DEV_WRITE message. * * @param p Message ptr. *****************************************************************************/PRIVATE void hd_rdwt(MESSAGE * p)&#123; int drive = DRV_OF_DEV(p-&gt;DEVICE); u64 pos = p-&gt;POSITION; assert((pos &gt;&gt; SECTOR_SIZE_SHIFT) &lt; (1 &lt;&lt; 31)); /** * We only allow to R/W from a SECTOR boundary: */ assert((pos &amp; 0x1FF) == 0); u32 sect_nr = (u32)(pos &gt;&gt; SECTOR_SIZE_SHIFT); /* pos / SECTOR_SIZE */ int logidx = (p-&gt;DEVICE - MINOR_hd1a) % NR_SUB_PER_DRIVE; sect_nr += p-&gt;DEVICE &lt; MAX_PRIM ? hd_info[drive].primary[p-&gt;DEVICE].base : hd_info[drive].logical[logidx].base; struct hd_cmd cmd; cmd.features = 0; cmd.count = (p-&gt;CNT + SECTOR_SIZE - 1) / SECTOR_SIZE; cmd.lba_low = sect_nr &amp; 0xFF; cmd.lba_mid = (sect_nr &gt;&gt; 8) &amp; 0xFF; cmd.lba_high = (sect_nr &gt;&gt; 16) &amp; 0xFF; cmd.device = MAKE_DEVICE_REG(1, drive, (sect_nr &gt;&gt; 24) &amp; 0xF); cmd.command = (p-&gt;type == DEV_READ) ? ATA_READ : ATA_WRITE; hd_cmd_out(&amp;cmd); int bytes_left = p-&gt;CNT; void * la = (void*)va2la(p-&gt;PROC_NR, p-&gt;BUF); while (bytes_left) &#123; int bytes = min(SECTOR_SIZE, bytes_left); if (p-&gt;type == DEV_READ) &#123; interrupt_wait(); port_read(REG_DATA, hdbuf, SECTOR_SIZE); phys_copy(la, (void*)va2la(TASK_HD, hdbuf), bytes); &#125; else &#123; if (!waitfor(STATUS_DRQ, STATUS_DRQ, HD_TIMEOUT)) panic("hd writing error."); port_write(REG_DATA, la, bytes); interrupt_wait(); &#125; bytes_left -= SECTOR_SIZE; la += SECTOR_SIZE; &#125;&#125; /***************************************************************************** * hd_ioctl *****************************************************************************//** * &lt;Ring 1&gt; This routine handles the DEV_IOCTL message. * * @param p Ptr to the MESSAGE. *****************************************************************************/PRIVATE void hd_ioctl(MESSAGE * p)&#123; int device = p-&gt;DEVICE; int drive = DRV_OF_DEV(device); struct hd_info * hdi = &amp;hd_info[drive]; if (p-&gt;REQUEST == DIOCTL_GET_GEO) &#123; void * dst = va2la(p-&gt;PROC_NR, p-&gt;BUF); void * src = va2la(TASK_HD, device &lt; MAX_PRIM ? &amp;hdi-&gt;primary[device] : &amp;hdi-&gt;logical[(device - MINOR_hd1a) % NR_SUB_PER_DRIVE]); phys_copy(dst, src, sizeof(struct part_info)); &#125; else &#123; assert(0); &#125;&#125;]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>设备号</tag>
        <tag>硬盘驱动程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》进程间通信（6-1）]]></title>
    <url>%2F2018%2F03%2F07%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[微内核与宏内核 微内核：让内核只负责它必须负责的工作，比如进程调度，将内核工作简单化的思想，便是微内核的基本思想。 宏内核：所有工作通过系统调用扔给内核态的做法，完成具体任务时，用户进程通过系统调用让内核来做事。 宏内核的优势在于其逻辑简单，直接了当，实现起来容易些，而且也因为它的直接，避免了像微内核那样在消息传递时占用资源。而微内核的优势在于，它的逻辑虽然相对复杂但是非常严谨，结构上显得非常优雅精致，而且程序更容易模块化，从而更容易移植。所以我们首要的任务就是实现一个进程间的通信机制（IPC）。IPCIPC是Inter—Process Communication的缩写，是进程间通信的意思，就是进程间发消息。IPC有同步和异步之分，同步是消息发送发和消息接收方都会一直等待消息，它的好处是： 操作系统不需要另外维护缓冲区来存放正在传递的消息 操作系统不需要保留一份消息副本 操作系统不需要维护接受队列 发送者和接受者都可以在任何时刻清晰且容易的知道消息是否送达 从实现系统调用的角度看，同步IPC更加合理，当使用系统调用时，我们的确需要等待内核返回结果之后再继续实现IPCIPC的机制已经清楚了，它的核心在int SYSVEC这个软中断以及与之对应的sys_call()这个函数。下面是新的系统调用sendrec:1234567sendrec: mov eax, _NR_sendrec mov ebx, [esp + 4] ; function mov ecx, [esp + 8] ; src_dest mov edx, [esp + 12] ; p_msg int INT_VECTOR_SYS_CALL ret sys_sendrec（）这个函数被设计得很简单，就是send消息交给msg_send（）处理，把RECEIVE消息交给msg_receive()处理。 msg_send()和msg_receive()核心代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377/***************************************************************************** * ldt_seg_linear *****************************************************************************//** * &lt;Ring 0~1&gt; Calculate the linear address of a certain segment of a given * proc. * * @param p Whose (the proc ptr). * @param idx Which (one proc has more than one segments). * * @return The required linear address. *****************************************************************************/PUBLIC int ldt_seg_linear(struct proc* p, int idx)&#123; struct descriptor * d = &amp;p-&gt;ldts[idx]; return d-&gt;base_high &lt;&lt; 24 | d-&gt;base_mid &lt;&lt; 16 | d-&gt;base_low;&#125;/***************************************************************************** * va2la *****************************************************************************//** * &lt;Ring 0~1&gt; Virtual addr --&gt; Linear addr. * * @param pid PID of the proc whose address is to be calculated. * @param va Virtual address. * * @return The linear address for the given virtual address. *****************************************************************************/PUBLIC void* va2la(int pid, void* va)&#123; struct proc* p = &amp;proc_table[pid]; u32 seg_base = ldt_seg_linear(p, INDEX_LDT_RW); u32 la = seg_base + (u32)va; if (pid &lt; NR_TASKS + NR_PROCS) &#123; assert(la == (u32)va); &#125; return (void*)la;&#125;/***************************************************************************** * reset_msg *****************************************************************************//** * &lt;Ring 0~3&gt; Clear up a MESSAGE by setting each byte to 0. * * @param p The message to be cleared. *****************************************************************************/PUBLIC void reset_msg(MESSAGE* p)&#123; memset(p, 0, sizeof(MESSAGE));&#125;/***************************************************************************** * block *****************************************************************************//** * &lt;Ring 0&gt; This routine is called after `p_flags' has been set (!= 0), it * calls `schedule()' to choose another proc as the `proc_ready'. * * @attention This routine does not change `p_flags'. Make sure the `p_flags' * of the proc to be blocked has been set properly. * * @param p The proc to be blocked. *****************************************************************************/PRIVATE void block(struct proc* p)&#123; assert(p-&gt;p_flags); schedule();&#125;/***************************************************************************** * unblock *****************************************************************************//** * &lt;Ring 0&gt; This is a dummy routine. It does nothing actually. When it is * called, the `p_flags' should have been cleared (== 0). * * @param p The unblocked proc. *****************************************************************************/PRIVATE void unblock(struct proc* p)&#123; assert(p-&gt;p_flags == 0);&#125;/***************************************************************************** * deadlock *****************************************************************************//** * &lt;Ring 0&gt; Check whether it is safe to send a message from src to dest. * The routine will detect if the messaging graph contains a cycle. For * instance, if we have procs trying to send messages like this: * A -&gt; B -&gt; C -&gt; A, then a deadlock occurs, because all of them will * wait forever. If no cycles detected, it is considered as safe. * * @param src Who wants to send message. * @param dest To whom the message is sent. * * @return Zero if success. *****************************************************************************/PRIVATE int deadlock(int src, int dest)&#123; struct proc* p = proc_table + dest; while (1) &#123; if (p-&gt;p_flags &amp; SENDING) &#123; if (p-&gt;p_sendto == src) &#123; /* print the chain */ p = proc_table + dest; printl("=_=%s", p-&gt;name); do &#123; assert(p-&gt;p_msg); p = proc_table + p-&gt;p_sendto; printl("-&gt;%s", p-&gt;name); &#125; while (p != proc_table + src); printl("=_="); return 1; &#125; p = proc_table + p-&gt;p_sendto; &#125; else &#123; break; &#125; &#125; return 0;&#125;/***************************************************************************** * msg_send *****************************************************************************//** * &lt;Ring 0&gt; Send a message to the dest proc. If dest is blocked waiting for * the message, copy the message to it and unblock dest. Otherwise the caller * will be blocked and appended to the dest's sending queue. * * @param current The caller, the sender. * @param dest To whom the message is sent. * @param m The message. * * @return Zero if success. *****************************************************************************/PRIVATE int msg_send(struct proc* current, int dest, MESSAGE* m)&#123; struct proc* sender = current; struct proc* p_dest = proc_table + dest; /* proc dest */ assert(proc2pid(sender) != dest); /* check for deadlock here */ if (deadlock(proc2pid(sender), dest)) &#123; panic("&gt;&gt;DEADLOCK&lt;&lt; %s-&gt;%s", sender-&gt;name, p_dest-&gt;name); &#125; if ((p_dest-&gt;p_flags &amp; RECEIVING) &amp;&amp; /* dest is waiting for the msg */ (p_dest-&gt;p_recvfrom == proc2pid(sender) || p_dest-&gt;p_recvfrom == ANY)) &#123; assert(p_dest-&gt;p_msg); assert(m); phys_copy(va2la(dest, p_dest-&gt;p_msg), va2la(proc2pid(sender), m), sizeof(MESSAGE)); p_dest-&gt;p_msg = 0; p_dest-&gt;p_flags &amp;= ~RECEIVING; /* dest has received the msg */ p_dest-&gt;p_recvfrom = NO_TASK; unblock(p_dest); assert(p_dest-&gt;p_flags == 0); assert(p_dest-&gt;p_msg == 0); assert(p_dest-&gt;p_recvfrom == NO_TASK); assert(p_dest-&gt;p_sendto == NO_TASK); assert(sender-&gt;p_flags == 0); assert(sender-&gt;p_msg == 0); assert(sender-&gt;p_recvfrom == NO_TASK); assert(sender-&gt;p_sendto == NO_TASK); &#125; else &#123; /* dest is not waiting for the msg */ sender-&gt;p_flags |= SENDING; assert(sender-&gt;p_flags == SENDING); sender-&gt;p_sendto = dest; sender-&gt;p_msg = m; /* append to the sending queue */ struct proc * p; if (p_dest-&gt;q_sending) &#123; p = p_dest-&gt;q_sending; while (p-&gt;next_sending) p = p-&gt;next_sending; p-&gt;next_sending = sender; &#125; else &#123; p_dest-&gt;q_sending = sender; &#125; sender-&gt;next_sending = 0; block(sender); assert(sender-&gt;p_flags == SENDING); assert(sender-&gt;p_msg != 0); assert(sender-&gt;p_recvfrom == NO_TASK); assert(sender-&gt;p_sendto == dest); &#125; return 0;&#125;/***************************************************************************** * msg_receive *****************************************************************************//** * &lt;Ring 0&gt; Try to get a message from the src proc. If src is blocked sending * the message, copy the message from it and unblock src. Otherwise the caller * will be blocked. * * @param current The caller, the proc who wanna receive. * @param src From whom the message will be received. * @param m The message ptr to accept the message. * * @return Zero if success. *****************************************************************************/PRIVATE int msg_receive(struct proc* current, int src, MESSAGE* m)&#123; struct proc* p_who_wanna_recv = current; /** * This name is a little bit * wierd, but it makes me * think clearly, so I keep * it. */ struct proc* p_from = 0; /* from which the message will be fetched */ struct proc* prev = 0; int copyok = 0; assert(proc2pid(p_who_wanna_recv) != src); if ((p_who_wanna_recv-&gt;has_int_msg) &amp;&amp; ((src == ANY) || (src == INTERRUPT))) &#123; /* There is an interrupt needs p_who_wanna_recv's handling and * p_who_wanna_recv is ready to handle it. */ MESSAGE msg; reset_msg(&amp;msg); msg.source = INTERRUPT; msg.type = HARD_INT; assert(m); phys_copy(va2la(proc2pid(p_who_wanna_recv), m), &amp;msg, sizeof(MESSAGE)); p_who_wanna_recv-&gt;has_int_msg = 0; assert(p_who_wanna_recv-&gt;p_flags == 0); assert(p_who_wanna_recv-&gt;p_msg == 0); assert(p_who_wanna_recv-&gt;p_sendto == NO_TASK); assert(p_who_wanna_recv-&gt;has_int_msg == 0); return 0; &#125; /* Arrives here if no interrupt for p_who_wanna_recv. */ if (src == ANY) &#123; /* p_who_wanna_recv is ready to receive messages from * ANY proc, we'll check the sending queue and pick the * first proc in it. */ if (p_who_wanna_recv-&gt;q_sending) &#123; p_from = p_who_wanna_recv-&gt;q_sending; copyok = 1; assert(p_who_wanna_recv-&gt;p_flags == 0); assert(p_who_wanna_recv-&gt;p_msg == 0); assert(p_who_wanna_recv-&gt;p_recvfrom == NO_TASK); assert(p_who_wanna_recv-&gt;p_sendto == NO_TASK); assert(p_who_wanna_recv-&gt;q_sending != 0); assert(p_from-&gt;p_flags == SENDING); assert(p_from-&gt;p_msg != 0); assert(p_from-&gt;p_recvfrom == NO_TASK); assert(p_from-&gt;p_sendto == proc2pid(p_who_wanna_recv)); &#125; &#125; else &#123; /* p_who_wanna_recv wants to receive a message from * a certain proc: src. */ p_from = &amp;proc_table[src]; if ((p_from-&gt;p_flags &amp; SENDING) &amp;&amp; (p_from-&gt;p_sendto == proc2pid(p_who_wanna_recv))) &#123; /* Perfect, src is sending a message to * p_who_wanna_recv. */ copyok = 1; struct proc* p = p_who_wanna_recv-&gt;q_sending; assert(p); /* p_from must have been appended to the * queue, so the queue must not be NULL */ while (p) &#123; assert(p_from-&gt;p_flags &amp; SENDING); if (proc2pid(p) == src) &#123; /* if p is the one */ p_from = p; break; &#125; prev = p; p = p-&gt;next_sending; &#125; assert(p_who_wanna_recv-&gt;p_flags == 0); assert(p_who_wanna_recv-&gt;p_msg == 0); assert(p_who_wanna_recv-&gt;p_recvfrom == NO_TASK); assert(p_who_wanna_recv-&gt;p_sendto == NO_TASK); assert(p_who_wanna_recv-&gt;q_sending != 0); assert(p_from-&gt;p_flags == SENDING); assert(p_from-&gt;p_msg != 0); assert(p_from-&gt;p_recvfrom == NO_TASK); assert(p_from-&gt;p_sendto == proc2pid(p_who_wanna_recv)); &#125; &#125; if (copyok) &#123; /* It's determined from which proc the message will * be copied. Note that this proc must have been * waiting for this moment in the queue, so we should * remove it from the queue. */ if (p_from == p_who_wanna_recv-&gt;q_sending) &#123; /* the 1st one */ assert(prev == 0); p_who_wanna_recv-&gt;q_sending = p_from-&gt;next_sending; p_from-&gt;next_sending = 0; &#125; else &#123; assert(prev); prev-&gt;next_sending = p_from-&gt;next_sending; p_from-&gt;next_sending = 0; &#125; assert(m); assert(p_from-&gt;p_msg); /* copy the message */ phys_copy(va2la(proc2pid(p_who_wanna_recv), m), va2la(proc2pid(p_from), p_from-&gt;p_msg), sizeof(MESSAGE)); p_from-&gt;p_msg = 0; p_from-&gt;p_sendto = NO_TASK; p_from-&gt;p_flags &amp;= ~SENDING; unblock(p_from); &#125; else &#123; /* nobody's sending any msg */ /* Set p_flags so that p_who_wanna_recv will not * be scheduled until it is unblocked. */ p_who_wanna_recv-&gt;p_flags |= RECEIVING; p_who_wanna_recv-&gt;p_msg = m; if (src == ANY) p_who_wanna_recv-&gt;p_recvfrom = ANY; else p_who_wanna_recv-&gt;p_recvfrom = proc2pid(p_from); block(p_who_wanna_recv); assert(p_who_wanna_recv-&gt;p_flags == RECEIVING); assert(p_who_wanna_recv-&gt;p_msg != 0); assert(p_who_wanna_recv-&gt;p_recvfrom != NO_TASK); assert(p_who_wanna_recv-&gt;p_sendto == NO_TASK); assert(p_who_wanna_recv-&gt;has_int_msg == 0); &#125; return 0;&#125; 其中： block():阻塞一个进程 unblock()：解除一个进程阻塞 deadloch():简单的判断是否发生死锁。方法是判断消息的发送是否构成一个环，如果构成环则意味着发生死锁。假设有进程A想要想进程B发送M，那么过程将会是这样的： A首先准备好M A通过系统调用sendrec，最终调用msg_send 简单判断是否发生锁死 判断目标进程B是否等待来自A的消息： 如果是：消息被复制给B，B被解除阻塞，继续运行； 如果不是：A被阻塞，并被加入到B的发送队列中假设有进程B想要接送消息，那么过程将会是： B准备一个空的消息结构体M，用于接受消息。 B通过系统调用sendrec，最终调用msg_receive 判断B是否有个来自硬件的消息，如果是，并且B准备接送户来自中断的消息或者准备接受任意消息，则马上准备一个消息给B，并返回。 如果B想接受来自任意进程的消息，则从自己的发送队列中选取第一个，将其消息复制给M。 如果B是想接受来自特定进程A的消息，则先判断A是否正在等待B发送消息，若是的话，将消息复给M 如果此时没有任何进程发消息给B，B会被阻塞。 增加消息机制之后的进程调度现在每个进程增加了两种可能的状态：SENDING和RECEIVING。相应的，我们需要在进程调度的时候区别对待了。凡是处在SENDING和RECEIVING状态的进程，我们不再让它们获得CPU了，也就是说，将它们阻塞了。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》输入输出系统（5-2）]]></title>
    <url>%2F2018%2F03%2F06%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%EF%BC%885-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[显示器初识TTYTTY在Linux中就是终端。当按下ALT+F1、ALT+F2、ALT+F3等组合键时，会切换到不同的屏幕。对于不同的TTY可以理解成下面：虽然不同的TTY对应的输入设备是同一个键盘，但是输出却好比是在不同的显示器上，因为不同的TTY对应的屏幕画面可能不同。实际上，画面的不同，仅仅是显示了显存的不同位置罢了。既然3个CONSOLE公用一块显存，那就有一种方式在切换CONSOLE的瞬间，让屏幕显示显存中某个位置的内容。屏幕上每一个字符对应的2字节的定义如下所示：可以看到，第字节表示的是字符本身，高字节用来定义字符的颜色。 寄存器VGA视频子系统的寄存器如下：这么多的寄存器，只有一个端口0X3D5，然后配合Address Register。下图中每一个寄存器都对应一个索引值，当想要访问其中一个的时候，只需要先向Adress Register写对应的索引值，然后在通过端口0x3D5进程的操作就是针对索引值对应的寄存器了。![mark](http://p29pmm8g4.bkt.clouddn.com/blog/180306/6aKGfjHmCk下面我们让光标跟随我们敲入的字符，设置光标位置：123456disable_int(); out_byte(CRTC_ADDR_REG, CURSOR_H); out_byte(CRTC_DATA_REG, ((disp_pos/2)&gt;&gt;8)&amp;0xFF); out_byte(CRTC_ADDR_REG, CURSOR_L); out_byte(CRTC_DATA_REG, (disp_pos/2)&amp;0xFF); enable_int(); make运行结果如下：接着，我们通过设置Start Adressb High Register和Start Adress Low Register来重新设置显示开始地址，从而实现滚屏的功能。当我们按下shift+上箭头时，则卷动屏幕向上15行 TTY任务在TTY任务中执行一个循环，这个循环将轮询每一个TTY，处理它的事件，包括从键盘缓冲区读取数据、显示字符等。它的运行方式如下：其实轮询到每一个TTY时，不外乎做两件事： 处理输入：查看是不是当前TTY，如果是则从键盘缓冲区读取数据。 处理输出：如果有要显示的内容则显示它。下面要做的TTY任务不再简单，主要表现为： 每一个TTY都应该有自己的读和写的动作。所以在keyboard_read（）内部，函数需要了解自己是被哪一个TTY调用。我们通过为函数传入一个参数来做到这一点，这个参数是指向当前TTY的指针。 为了让输入输出分离，被keyboard_read（）调用的in_process()不应该再直接回显示符，而应该将回显的任务交给TTY来完成，这样我们就需要为每个TTY建立一块缓冲区，用以放置将被回显的字符。 每个TTY回显字符时操作的console是不同的，所以每个TTY都应该有个成员来记载其对应的console信息。TTY任务框架的搭建TTY结构如下：1234567891011121314#define TTY_IN_BYTES 256 /* tty input queue size */struct s_console;/* TTY */typedef struct s_tty&#123; u32 in_buf[TTY_IN_BYTES]; /* TTY 输入缓冲区 */ u32* p_inbuf_head; /* 指向缓冲区中下一个空闲位置 */ u32* p_inbuf_tail; /* 指向键盘任务应处理的键值 */ int inbuf_count; /* 缓冲区中已经填充了多少 */ struct s_console * p_console;&#125;TTY; CONSOLE结构如下：1234567typedef struct s_console&#123; unsigned int current_start_addr; /* 当前显示到了什么位置 */ unsigned int original_addr; /* 当前控制台对应显存位置 */ unsigned int v_mem_limit; /* 当前控制台占的显存大小 */ unsigned int cursor; /* 当前光标位置 */&#125;CONSOLE; 整个程序的流程如下：在task_tty()中，通过循环来处理每一个TTY的读和写操作，读写操作都放在了tty_do_read()和tty_do_write()两个函数中，这样就让taske_tty()很简洁，而且逻辑清晰。读操作会调用keyboard_read()，当然此时已经多了一个参数；写操作会调用out_char()，它会将字符写入指定的CONSOLE。，当TTY任务开始运行时，所有TTY都将被初始化，并且全局变量nr_current_console会被赋值为0.然后循环开始并一直进行下去。对于每一个TTY，首先执行tty_do_read（），它将调用kerboard_read()并将读入的字符交给函数in_process（）来处理，如果是需要输出的字符，会被in_process（）放入当前接受处理的TTY的缓冲区中。然后tty_do_write()会接着执行，如果缓冲区中有数据，就被送入out_char显示出来。 多控制台下面是多控制台示意图：表示了某时刻显存的使用情况。其中灰色框表示当前屏幕，黑色小方格显示显存已经写入的字符。运行结果如下:在控制台0按下数次shift+箭头上 完善键盘处理回车键和退格键当敲击回车键和退格键时，我们王TTY缓冲区中写入“\n”和“\b”，然后在out_char中做出相应的处理，如下：1234567891011121314151617181920212223242526272829PUBLIC void in_process(TTY* p_tty, u32 key)&#123; char output[2] = &#123;'\0', '\0'&#125;; if (!(key &amp; FLAG_EXT)) &#123; put_key(p_tty, key); &#125; else &#123; int raw_code = key &amp; MASK_RAW; switch(raw_code) &#123; case ENTER: put_key(p_tty, '\n'); break; case BACKSPACE: put_key(p_tty, '\b'); break; 。。。。。。PRIVATE void put_key(TTY* p_tty, u32 key)&#123; if (p_tty-&gt;inbuf_count &lt; TTY_IN_BYTES) &#123; *(p_tty-&gt;p_inbuf_head) = key; p_tty-&gt;p_inbuf_head++; if (p_tty-&gt;p_inbuf_head == p_tty-&gt;in_buf + TTY_IN_BYTES) &#123; p_tty-&gt;p_inbuf_head = p_tty-&gt;in_buf; &#125; p_tty-&gt;inbuf_count++; &#125;&#125; 然后修改out_char：123456789101112131415161718192021222324252627282930313233343536373839404142434445PUBLIC void out_char(CONSOLE* p_con, char ch)&#123; u8* p_vmem = (u8*)(V_MEM_BASE + p_con-&gt;cursor * 2); switch(ch) &#123; case '\n': if (p_con-&gt;cursor &lt; p_con-&gt;original_addr + p_con-&gt;v_mem_limit - SCREEN_WIDTH) &#123; p_con-&gt;cursor = p_con-&gt;original_addr + SCREEN_WIDTH * ((p_con-&gt;cursor - p_con-&gt;original_addr) / SCREEN_WIDTH + 1); &#125; break; case '\b': if (p_con-&gt;cursor &gt; p_con-&gt;original_addr) &#123; p_con-&gt;cursor--; *(p_vmem-2) = ' '; *(p_vmem-1) = DEFAULT_CHAR_COLOR; &#125; break; default: if (p_con-&gt;cursor &lt; p_con-&gt;original_addr + p_con-&gt;v_mem_limit - 1) &#123; *p_vmem++ = ch; *p_vmem++ = DEFAULT_CHAR_COLOR; p_con-&gt;cursor++; &#125; break; &#125; while (p_con-&gt;cursor &gt;= p_con-&gt;current_start_addr + SCREEN_SIZE) &#123; scroll_screen(p_con, SCR_DN); &#125; flush(p_con);&#125;/*======================================================================* flush*======================================================================*/PRIVATE void flush(CONSOLE* p_con)&#123; set_cursor(p_con-&gt;cursor); set_video_start_addr(p_con-&gt;current_start_addr);&#125; 可以看到回车键直接把光标挪到了下一行的开头，而退格键则把光标挪到上一个字符的位置，并在那里写一个空格，以便清除原来的字符。由于不断的回车会让光标快速的移动到屏幕的底端。所以在这里还要判断光标是否已经移出了屏幕，如果是的话将会触发屏幕滚动。另外，输出的任何类型的字符时，都做了边界检验，以防止影响到别的控制台，甚至试图写到显存之外的内存。运行结果如下： 区分任务和用户进程前面的TTY我们称之为任务，A、B、C则为用户进程。在具体的实现上，让用户进程运行在ring3，任务继续留在ring1。如下图： printf为进程指定TTY当某个进程调用printf时，操作系统必须知道往哪个控制台输出才行。而当系统调用发生,ring3跳入ring0时，系统只能知道当前系统调用是由哪个进程触发的。所以我们必须为每个进程指定一个与之相对应的TTY，这可以通过在进程表中增加一个成员来实现。 printf（）的实现printf()的实现并不简单，首先是它的参数个数和类型都可变，而且其表示格式的参数形式多样，在printf()中。都要加以识别。下面我们先实现printf（）只支持%X一种格式。如下：123456789int printf(const char *fmt,...)&#123; int i; char buf[256]; va_list arg=(va_list)((char*)(&amp;fmt)+4); i=vsprintf(buf,fmt,arg); write(buf,i); return i;&#125; 系统调用增加一个系统调用的过程如下所示： 使用print分（）make运行结果如下图：]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>于渊</tag>
        <tag>系统调用</tag>
        <tag>显示器</tag>
        <tag>TTY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》输入输出系统（5-1）]]></title>
    <url>%2F2018%2F03%2F06%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%EF%BC%885-1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[键盘操作系统需要交互，首先就是键盘 从中断开始：键盘的初体验 因为8259A的IRQ1就是键盘，现在我们写一个键盘的处理程序：1234PUBLIC void keyboard_handler(int irq)&#123; disp_str("*");&#125; 这个结果就是每按一次键盘，就会打印一个星号。然后添加中断处理程序，并打开键盘中断：12345PUBLIC void init_keyboard()&#123; put_irq_handler(KEYBOARD_IRD,keyboard_handler);/*设定键盘中断程序*/ enable_irq(KEYBOARD_IRQ);/*开键盘中断*/&#125; 然后在proto.h中声明init_keyboard()并调用它。make之后，运行结果如下。然后问题出现了，按了一次以后就没法再按出星号了。 AT、PS/2键盘下图左边是PS/2键盘的接口，右边是AT键盘的接口，现在主流的都是USB的了。 键盘敲击的过程在键盘中存在一个叫做键盘编码器的芯片，它通常是Intel 8048以及兼容芯片，作用是监视键盘的输入，并把适当的数据传送给计算机。另外在计算机主板上还有一个键盘控制器，用来接受和解码来自键盘的数据，并与8259A以及软件等进行通信。如下图：敲击键盘有两个方面的含义：动作和内容。动作有三类:按下、保持按下以及放开；内容则是键盘上的不同的键.8048既要反应“哪个”安检产生动作，还要反映产生了什么内容。敲击键盘产生的编码被称为扫描码，当一个键被按下或者保持按下时，将会产生Make Code，当弹起时，产生Break Code。当8048检测到一个键的动作，会把相应的扫描码发送给8042，8042会把它转换成相应的扫描码，并将其放置在缓冲区，然后8042告诉8259A产生中断（IRQ1）。如果此时键盘又有新的键被按下，8042将不再接受，一直到缓冲区被清空。所以我们只能按下一次就没有反应了，因为缓冲区的内容没有被取走。为了了解如何从缓冲区中读取扫描码，我们要学习8042：对于输入和输出缓冲区，可以用in和out指令来进行相应的读取操作。如下，在keyboard_handler中添加：1in_byte(0x60); 运行结果如下：我们发现结果是16进制数，所以我们用如下表格建立对应关系，即可看到想要的结果了： 用数组表示扫描码扫描码是一些数字，我们建立一个数组，以扫描码为下标，对应的元素就是相应的字符。数组是3个值一组，三个值是单独按某键、Shift+某键和有0xE0前缀扫描码对应的字符。Esc、Enter被定义成不冲突的宏即可：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133u32 keymap[NR_SCAN_CODES * MAP_COLS] = &#123;/* scan-code !Shift Shift E0 XX *//* ==================================================================== *//* 0x00 - none */ 0, 0, 0,/* 0x01 - ESC */ ESC, ESC, 0,/* 0x02 - '1' */ '1', '!', 0,/* 0x03 - '2' */ '2', '@', 0,/* 0x04 - '3' */ '3', '#', 0,/* 0x05 - '4' */ '4', '$', 0,/* 0x06 - '5' */ '5', '%', 0,/* 0x07 - '6' */ '6', '^', 0,/* 0x08 - '7' */ '7', '&amp;', 0,/* 0x09 - '8' */ '8', '*', 0,/* 0x0A - '9' */ '9', '(', 0,/* 0x0B - '0' */ '0', ')', 0,/* 0x0C - '-' */ '-', '_', 0,/* 0x0D - '=' */ '=', '+', 0,/* 0x0E - BS */ BACKSPACE, BACKSPACE, 0,/* 0x0F - TAB */ TAB, TAB, 0,/* 0x10 - 'q' */ 'q', 'Q', 0,/* 0x11 - 'w' */ 'w', 'W', 0,/* 0x12 - 'e' */ 'e', 'E', 0,/* 0x13 - 'r' */ 'r', 'R', 0,/* 0x14 - 't' */ 't', 'T', 0,/* 0x15 - 'y' */ 'y', 'Y', 0,/* 0x16 - 'u' */ 'u', 'U', 0,/* 0x17 - 'i' */ 'i', 'I', 0,/* 0x18 - 'o' */ 'o', 'O', 0,/* 0x19 - 'p' */ 'p', 'P', 0,/* 0x1A - '[' */ '[', '&#123;', 0,/* 0x1B - ']' */ ']', '&#125;', 0,/* 0x1C - CR/LF */ ENTER, ENTER, PAD_ENTER,/* 0x1D - l. Ctrl */ CTRL_L, CTRL_L, CTRL_R,/* 0x1E - 'a' */ 'a', 'A', 0,/* 0x1F - 's' */ 's', 'S', 0,/* 0x20 - 'd' */ 'd', 'D', 0,/* 0x21 - 'f' */ 'f', 'F', 0,/* 0x22 - 'g' */ 'g', 'G', 0,/* 0x23 - 'h' */ 'h', 'H', 0,/* 0x24 - 'j' */ 'j', 'J', 0,/* 0x25 - 'k' */ 'k', 'K', 0,/* 0x26 - 'l' */ 'l', 'L', 0,/* 0x27 - ';' */ ';', ':', 0,/* 0x28 - '\'' */ '\'', '"', 0,/* 0x29 - '`' */ '`', '~', 0,/* 0x2A - l. SHIFT */ SHIFT_L, SHIFT_L, 0,/* 0x2B - '\' */ '\\', '|', 0,/* 0x2C - 'z' */ 'z', 'Z', 0,/* 0x2D - 'x' */ 'x', 'X', 0,/* 0x2E - 'c' */ 'c', 'C', 0,/* 0x2F - 'v' */ 'v', 'V', 0,/* 0x30 - 'b' */ 'b', 'B', 0,/* 0x31 - 'n' */ 'n', 'N', 0,/* 0x32 - 'm' */ 'm', 'M', 0,/* 0x33 - ',' */ ',', '&lt;', 0,/* 0x34 - '.' */ '.', '&gt;', 0,/* 0x35 - '/' */ '/', '?', PAD_SLASH,/* 0x36 - r. SHIFT */ SHIFT_R, SHIFT_R, 0,/* 0x37 - '*' */ '*', '*', 0,/* 0x38 - ALT */ ALT_L, ALT_L, ALT_R,/* 0x39 - ' ' */ ' ', ' ', 0,/* 0x3A - CapsLock */ CAPS_LOCK, CAPS_LOCK, 0,/* 0x3B - F1 */ F1, F1, 0,/* 0x3C - F2 */ F2, F2, 0,/* 0x3D - F3 */ F3, F3, 0,/* 0x3E - F4 */ F4, F4, 0,/* 0x3F - F5 */ F5, F5, 0,/* 0x40 - F6 */ F6, F6, 0,/* 0x41 - F7 */ F7, F7, 0,/* 0x42 - F8 */ F8, F8, 0,/* 0x43 - F9 */ F9, F9, 0,/* 0x44 - F10 */ F10, F10, 0,/* 0x45 - NumLock */ NUM_LOCK, NUM_LOCK, 0,/* 0x46 - ScrLock */ SCROLL_LOCK, SCROLL_LOCK, 0,/* 0x47 - Home */ PAD_HOME, '7', HOME,/* 0x48 - CurUp */ PAD_UP, '8', UP,/* 0x49 - PgUp */ PAD_PAGEUP, '9', PAGEUP,/* 0x4A - '-' */ PAD_MINUS, '-', 0,/* 0x4B - Left */ PAD_LEFT, '4', LEFT,/* 0x4C - MID */ PAD_MID, '5', 0,/* 0x4D - Right */ PAD_RIGHT, '6', RIGHT,/* 0x4E - '+' */ PAD_PLUS, '+', 0,/* 0x4F - End */ PAD_END, '1', END,/* 0x50 - Down */ PAD_DOWN, '2', DOWN,/* 0x51 - PgDown */ PAD_PAGEDOWN, '3', PAGEDOWN,/* 0x52 - Insert */ PAD_INS, '0', INSERT,/* 0x53 - Delete */ PAD_DOT, '.', DELETE,/* 0x54 - Enter */ 0, 0, 0,/* 0x55 - ??? */ 0, 0, 0,/* 0x56 - ??? */ 0, 0, 0,/* 0x57 - F11 */ F11, F11, 0, /* 0x58 - F12 */ F12, F12, 0, /* 0x59 - ??? */ 0, 0, 0, /* 0x5A - ??? */ 0, 0, 0, /* 0x5B - ??? */ 0, 0, GUI_L, /* 0x5C - ??? */ 0, 0, GUI_R, /* 0x5D - ??? */ 0, 0, APPS, /* 0x5E - ??? */ 0, 0, 0, /* 0x5F - ??? */ 0, 0, 0,/* 0x60 - ??? */ 0, 0, 0,/* 0x61 - ??? */ 0, 0, 0, /* 0x62 - ??? */ 0, 0, 0, /* 0x63 - ??? */ 0, 0, 0, /* 0x64 - ??? */ 0, 0, 0, /* 0x65 - ??? */ 0, 0, 0, /* 0x66 - ??? */ 0, 0, 0, /* 0x67 - ??? */ 0, 0, 0, /* 0x68 - ??? */ 0, 0, 0, /* 0x69 - ??? */ 0, 0, 0, /* 0x6A - ??? */ 0, 0, 0, /* 0x6B - ??? */ 0, 0, 0, /* 0x6C - ??? */ 0, 0, 0, /* 0x6D - ??? */ 0, 0, 0, /* 0x6E - ??? */ 0, 0, 0, /* 0x6F - ??? */ 0, 0, 0, /* 0x70 - ??? */ 0, 0, 0, /* 0x71 - ??? */ 0, 0, 0, /* 0x72 - ??? */ 0, 0, 0, /* 0x73 - ??? */ 0, 0, 0, /* 0x74 - ??? */ 0, 0, 0, /* 0x75 - ??? */ 0, 0, 0, /* 0x76 - ??? */ 0, 0, 0, /* 0x77 - ??? */ 0, 0, 0, /* 0x78 - ??? */ 0, 0, 0, /* 0x78 - ??? */ 0, 0, 0, /* 0x7A - ??? */ 0, 0, 0, /* 0x7B - ??? */ 0, 0, 0, /* 0x7C - ??? */ 0, 0, 0, /* 0x7D - ??? */ 0, 0, 0, /* 0x7E - ??? */ 0, 0, 0,/* 0x7F - ??? */ 0, 0, 0&#125;; 键盘输入缓冲区这个是用来放置中断例程接受到的扫描码。为了解决当扫描码不止一个字符时的问题。它的用法如图所示：白色框表示空闲字节，灰色框表示已用字节。 用新加的任务处理键盘操作终端任务是要处理屏幕输出等内容的，为了简化我们现在只是不停的调用keyboard_read()：123456PUBLIC void task_tty()&#123; while(1)&#123; keyboard_read(); &#125;&#125; keyboard_read()首先判断kb_in.count是否为0，如果不为0表明缓冲区中有扫描码，就开始读取。 解析扫描码显示字符因为键盘的键的功能是不一样的，有的是一种功能不是一个ASCII。我们先处理可以打印的123456789101112131415161718192021222324252627282930313233343536373839PUBLIC void keyboard_read()&#123; u8 scan_code; char output[2]; int make; /* TRUE: make; FALSE: break. */ memset(output, 0, 2); if(kb_in.count &gt; 0)&#123; disable_int(); scan_code = *(kb_in.p_tail); kb_in.p_tail++; if (kb_in.p_tail == kb_in.buf + KB_IN_BYTES) &#123; kb_in.p_tail = kb_in.buf; &#125; kb_in.count--; enable_int(); /* 下面开始解析扫描码 */ if (scan_code == 0xE1) &#123; /* 暂时不做任何操作 */ &#125; else if (scan_code == 0xE0) &#123; /* 暂时不做任何操作 */ &#125; else &#123; /* 下面处理可打印字符 */ /* 首先判断Make Code 还是 Break Code */ make = (scan_code &amp; FLAG_BREAK ? FALSE : TRUE); /* 如果是Make Code 就打印，是 Break Code 则不做处理 */ if(make) &#123; output[0] = keymap[(scan_code&amp;0x7F)*MAP_COLS]; disp_str(output); &#125; &#125; /* disp_int(scan_code); */ &#125;&#125; 上面的总体思想是0xE0和0xE1单独处理，其余都是单字节的，运行结果如下： 处理shift、alt、ctrl先对这三个按键的状态进行判断，因为有左右之分，所以有6个键，当按下shift_l时，相应的变量就变为TRUE,如果立即释放则变为FALSE。如果if(shift_l||shift_r)成立，则表示左shift被按下且未被释放，此时colum值变为1。运行一下：对于其他功能键，我们统一放在in_process()中，并在不可打印的字符的定义中，都加一个FLAG_EXT。运行结果如下：]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>键盘交互</tag>
        <tag>AT、PS/2键盘</tag>
        <tag>键盘扫描码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》进程（4-2）]]></title>
    <url>%2F2018%2F03%2F04%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%9B%E7%A8%8B%EF%BC%884-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[多进程前面我们完成了ring0到ring1的跳转，它可以随时被中断，可以在中断处理程序完成之后被恢复。进程此时已经有了两种状态：运行和睡眠。接着我们只需要让其中一个进程处在运行状态，其余进程处在睡眠状态即可。 添加一个进程体 12345678910void TestB()&#123; int i =0x1000; while(1)&#123; disp_str("B"); disp_int(i++); disp_str("."); delay(1); &#125;&#125; 进程表初始化代码扩充进程之间的区别真的不大。每一次循环的不同在于，从TASK结构中读取不同的任务入口地址\堆栈栈顶和进程名，然后赋给相应的进程表项。需要注意以下两点： 由于堆栈是从高地址到低地址生长的，所以在给每一个进程分配堆栈空间的时候，也是从高地址往低地址进行。 每一个进程都在GDT中分配一个描述符用来对应进程的LDT。LDT因为每一个进程都会在GDT中对应一个LDT描述符。于是在for循环中，我们将每个进程表项中的成员p_proc-&gt;ldt_sel赋值。下面是初始化LDT：123456789101112int i; PROCESS* p_proc = proc_table; u16 selector_ldt = INDEX_LDT_FIRST &lt;&lt; 3; for(i=0;i&lt;NR_TASKS;i++)&#123; init_descriptor(&amp;gdt[selector_ldt&gt;&gt;3], vir2phys(seg2phys(SELECTOR_KERNEL_DS), proc_table[i].ldts), LDT_SIZE * sizeof(DESCRIPTOR) - 1, DA_LDT); p_proc++; selector_ldt += 1 &lt;&lt; 3; &#125; 修改中断程序一个进程由sleep状态变为run状态，无非是将esp指向进程表项的开始处，然后在执行lldt之后精力一系列pop指令恢复各个寄存器的值。一切信息都包含在进程表中，所以，要想恢复不同的进程，只需要将esp指向不同的进程表就可以了。在离开内核栈的时候，执行如下语句：1mov esp,[p_proc_ready] 全局变量p_proc_ready是指向进程表结构的指针，我们只需要在这一句执行之前把它赋予不同的值就可以了。因为这部分即关于时钟中断，又关与进程调度。所以我们可以创建一个clock.c，也可以创建一个proc.c。1234PUBLIC void clock_handler(int irq)&#123; disp_str("#");&#125; make之后，结果如下：接着进行进程切换：1234567PUBLIC void clock_handler(int irq)&#123; disp_str("#"); p_proc_ready++; if (p_proc_ready &gt;= proc_table + NR_TASKS) p_proc_ready = proc_table;&#125; 每一次我们让p_proc_ready指向进程表中的下一个表项，如果切换前已经到达进程表结尾则回到第一个表项。然后再make：可以看到A和B交替出现。这说明第二个进程运行成。 系统调用系统调用和API类似，当应用程序很多事做不了的时候，只能交给操作系统来做。所以一个事情，可能应用程序做了一部分，操作系统做一部分，这就涉及到特权级的问题了。下面是本操作系统的运行过程： 实现一个简单的系统调用我们通过实现get_tick()得到当前总共发生多少次时钟中断。设置一个全局变量ticks，每次发生一次时钟中断，它就加1.进程可以随时通过get_tick()这个系统调用来得到这个值。代码如下：1234567891011121314%include "sconst.inc"_NR_get_ticks equ 0 ; 要跟 global.c 中 sys_call_table 的定义相对应！INT_VECTOR_SYS_CALL equ 0x90global get_ticks ; 导出符号bits 32[section .text]get_ticks: mov eax, _NR_get_ticks int INT_VECTOR_SYS_CALL ret get_ticks的应用因为时钟中断发生的时间间隔是一定的，如果我们知道这个实践间隔，就可以用get_ticks函数来写一个判断时间的函数，进而代替delay() 8253/8254 PIT中断的发生实际上是由一个被称为PIT（Programmable Interval Timer）的芯片来触发的。在AT以及以后又Intel 8253换为Intel 8254。8253有三个计数器：从上可知，中断实际是由8253的Counter0产生的。计数器有一个输入频率，在PC上是1193180Hz，在每一个时钟周期，计数器值会减1，当减到0就会触发一个输出。由于计数器是16位的，所以最大值是65535，因此，默认的时钟中断的发生频率是1193180/65536~18.2Hz。我们可以通过编程来控制8253.比如，想让系统每10ms产生一次中断，也就是让输出频率为100Hz，那么需要为计数器赋值为1193180/100~11932.因为控制8253是通过端口的写操作完成的。如下：以下是8253模式控制寄存器也就是端口43h写入寄存器的格式。下面是计数器模式位：下面是读/写/锁位:下面是计数器选择位：make一下，运行结果如下： 进程调度避免对称—进程的节奏感前面的进程延迟相同，现在将其改变下A、B、C三个的延迟分别为300、900、1500ms，运行结果如下：从这个我们可以想到，通过延迟的不同设置不同的优先级。通过“轻重缓急”反应在时间上，来表达优先级调度，最重要的事情应该被赋予更高的优先级，应该给予更多的时间。我们给每一个进程都添加一个变量，在一段时间 的开头，这个变量的值又大又下，进程获得一个运行周期，这个变量就减1，当减到0，此进程就不再获得执行的机会，指导所有进程都为0。由于每一次进程调度的时候只有某一个进程的ticks会减少1，所以总共调度的次数应该是3个进程的ticks之和（150+50+30）=230。所以: 进程A执行循环的次数为：（100+20x2+30x3）/20=230/20=11.5次 进程B执行循环的次数为：（0+20x2+30x3）/20=230/20=6.5次 进程C执行循环的次数为：（0+0x2+30x3）/20=230/20=4.5次将各个进程的延迟时间改为10m后，make一下，运行如下：]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>进程调度</tag>
        <tag>多进程</tag>
        <tag>8253/8254</tag>
        <tag>PIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》进程（4-1）]]></title>
    <url>%2F2018%2F03%2F04%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%9B%E7%A8%8B%EF%BC%884-1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[进程概述进程介绍系统中运行的若干进程可以类比成一个人在一天内要做的若干样工作：总体看来，每样工作相对独立，并可产生某种结果；从细节上看，每样工作都具有自己的办法、工具和需要的资源；从时间上看，每一个时刻只能有一项工作正在处理中，各项工作可以轮换来做，这对于最终结果没有影响。进程类似，从宏观上看，它有自己的目标，或者说功能，同时又能受控于进程调度模块，从微观来看，她可以利用系统的资源，有自己的代码和数据，同时拥有自己的堆栈；进程需要被调度，就好比一个人轮换做不同的工作。示意图如下： 形成进程的必要考虑因为进程数是多余CPU数的，于是在同一时刻，总是有“正在运行的”和“正在休息的”进程。所以，对于“正在休息的”进程，我们需要让它在重新醒来的时候记住自己挂起之前的状态，以便让原来的任务继续执行下去。所以，我们要一个数据结构记录一个进程的状态，在进程要被挂起的时候，进程信息就被写入这个数据结构，等到进程重新启动的时候，这个信息重新被读出来。如下图： 最简单的进程我们设想，当一个进程运行的时候，突然发生了时钟中断，特权级从ring1跳到ring0，开始执行时钟中断处理程序，中断处理程序这时调用进程调度模块，指定下一个应该运行的程序，当中断处理程序结束时，下一个进程准备就绪并开始运行，特权级又从ring0跳回ring1。我们把这个过程按照时间顺序整理如下： 进程A运行中 时钟中断发生，ring1-&gt;ring0，时钟中断处理程序启动。 进程调度，下一个应该运行的进程B被指定 进程B被恢复，ring0-&gt;ring1 进程B运行中。而要想实现这些功能，我们必须完成的应该有以下几项： 时钟中断处理程序 进程调度模块 两个进程进程切换图：准备工作进程控制块PCB（也叫做进程表）它相当于进程的提纲，通过PCB我们可以很方便的进行进程管理。因为我们会有跟多个PCB所以会形成如图所示的进程表：进程栈和内核栈当寄存器的值已经被保存到进程表内，进程调度模块就开始执行了，寄存器被压到进程表之后，esp汁指向进程表某个位置的。为了避免错误的出现，一定要将esp指向专门的内核栈区域。这样在短短的进程切换过程中，esp的位置出现在3个不同的区域： 进程栈：进程运行时自身的堆栈 进程表：存储进程状态信息的数据结构 内核栈：进程调度模块运行时使用的堆栈第一步:ring0-&gt;ring1 在开始第一个进程时，我们用iretd来实现由ring0-&gt;ring1的转移，一旦转移成功，便可以认为已经在一个进程中运行了。如下：1234567891011121314restart: mov esp, [p_proc_ready] lldt [esp + P_LDT_SEL] lea eax, [esp + P_STACKTOP] mov dword [tss + TSS3_S_SP0], eaxrestart_reenter: dec dword [k_reenter] pop gs pop fs pop es pop ds popad add esp, 4 iretd 其中，指针p_proc_ready是指向PCB的指针，PCB的信息被结构体s_proc存储。当要恢复一个进程时，便将esp指向这个结构体的开始处，然后运行一系列的pop命令，将寄存器值弹出。进程表的开始位置结构图如下： 时钟中断处理程序我们只完成最简单的ring0到ring1的转移，做到这一点用一个iretd指令就够了 PCB、进程体、GDT、TSS既然在进程开始之前要用到进程表中各项的值，我们应该先将这些值进行初始化，只要制定好各段寄存器、eip、esp以及eflags，它就可以正常运行，至于其他寄存器是用不到的，所以我们得出这样的必须初始化的寄存器列表：cs、ds、es、fs、gs、ss、esp、eip、eflags。在Loader中，gs对应的描述符DPL为3，所以进程中的代码是有访问权限访问显存的；其他段寄存器对应的描述符基地址和段界限与先前的段寄存器对应的秒速恢复基地址金和段界限相同，只是改变它们的RPL和TI，以表示它们运行的特权级。进程表和与之相关的TSS的对应关系如图：主要分为三个部分： 进程表和GDT。进程表内的LDTSelector对应的GDT中的一个描述符，而这个描述符所指向的内存空间就存在进程表内。 进程表和进程。进程表就是进程的描述，进程运行过程中如果被中断，各个寄存器的值都会被保存进进程表中。但是，在我们的第一个进程开始之前，并不需要初始化太多内容，只需要知道进程的入口地址就足够了。 GDT和TSS。GDT中需要有一个描述符来对应TSS，需要事先初始化这个描述符。接着开始具体初始化，第一步，首先准备一个小的进程体：12345678910void TestA()&#123; int i = 0; while(1)&#123; disp_str("A"); disp_int(i++); disp_str("."); delay(1); &#125;&#125; 这个进程体（函数）的功能就是打印一个字符并显示数字，并稍微停顿。接着我们要注视掉hlt，并让程序跳转到kernel_main()中。delay()函数也就是一个循环嵌套。第二步，初始化进程表。首先收进程表的结构定义：1234567891011121314151617181920typedef struct s_stackframe &#123; u32 gs; /* \ */ u32 fs; /* | */ u32 es; /* | */ u32 ds; /* | */ u32 edi; /* | */ u32 esi; /* | pushed by save() */ u32 ebp; /* | */ u32 kernel_esp; /* &lt;- 'popad' will ignore it */ u32 ebx; /* | */ u32 edx; /* | */ u32 ecx; /* | */ u32 eax; /* / */ u32 retaddr; /* return addr for kernel.asm::save() */ u32 eip; /* \ */ u32 cs; /* | */ u32 eflags; /* | pushed by CPU during interrupt */ u32 esp; /* | */ u32 ss; /* / */&#125;STACK_FRAME; 然后在global.c中声明一个进程表：1PUBLIC PROCESS proc_table[NR_TASKS]; 其中NR_TASKS定义了最大允许进程，我们将其设为1。为了以后扩展，我们将其还是声明成一个数组。接着就初始化进程表：1234567891011121314151617PROCESS* p_proc = proc_table; p_proc-&gt;ldt_sel = SELECTOR_LDT_FIRST; memcpy(&amp;p_proc-&gt;ldts[0], &amp;gdt[SELECTOR_KERNEL_CS&gt;&gt;3], sizeof(DESCRIPTOR)); p_proc-&gt;ldts[0].attr1 = DA_C | PRIVILEGE_TASK &lt;&lt; 5; // change the DPL memcpy(&amp;p_proc-&gt;ldts[1], &amp;gdt[SELECTOR_KERNEL_DS&gt;&gt;3], sizeof(DESCRIPTOR)); p_proc-&gt;ldts[1].attr1 = DA_DRW | PRIVILEGE_TASK &lt;&lt; 5; // change the DPL p_proc-&gt;regs.cs = (0 &amp; SA_RPL_MASK &amp; SA_TI_MASK) | SA_TIL | RPL_TASK; p_proc-&gt;regs.ds = (8 &amp; SA_RPL_MASK &amp; SA_TI_MASK) | SA_TIL | RPL_TASK; p_proc-&gt;regs.es = (8 &amp; SA_RPL_MASK &amp; SA_TI_MASK) | SA_TIL | RPL_TASK; p_proc-&gt;regs.fs = (8 &amp; SA_RPL_MASK &amp; SA_TI_MASK) | SA_TIL | RPL_TASK; p_proc-&gt;regs.ss = (8 &amp; SA_RPL_MASK &amp; SA_TI_MASK) | SA_TIL | RPL_TASK; p_proc-&gt;regs.gs = (SELECTOR_KERNEL_GS &amp; SA_RPL_MASK) | RPL_TASK; p_proc-&gt;regs.eip= (u32)TestA; p_proc-&gt;regs.esp= (u32) task_stack + STACK_SIZE_TOTAL; p_proc-&gt;regs.eflags = 0x1202; // IF=1, IOPL=1, bit 2 is always 1. 进程表的初始化主要有寄存器、LDTSelector和LDT。LDTSelector被赋值为SELECTOR_LDT_FIRST。LDT中共有两个描述符，分别被初始化成内核代码段和内核数据段，只是改变一下DPL以让其运行在低的特权级下。要初始化的寄存器比较多，其中eip指向TestA，这表名进程将从TestA的入口开始运行。另外，esp指向了单独的栈，栈的大小为STACK_SIZE_TOTAL。最后一行是设置eflags,0x1202恰好设置了IF位，并把IOPL设为1.这样进程就可以使用I/O指令，并且中断会在iretd执行时被打开。第三步，准备GDT和TSS。到此，只有TSS和它对应的描述符没有初始化了。在init_prot（），填充TSS以及对应的描述符。 启动进程make以后，就运行成功了： 第一个进程回顾从上面的进程启动的示意图可以看出，进程体TestA()在内核被LOADER放置到内存中之后就准备好了。 第二步，丰富中断处理程序让时钟中断开始起作用现在打开i8259.c的init_8259A(),同时设置EOI。为了让中断显示出来，我们将通过改变屏幕第0行、第0列字符的方式来说明中断例程正在运行。 现场的保护和恢复使用进程表是为了保存进程的状态，以便中断处理程序完成之后需要被恢复的进程能够被顺利地恢复。在进程表中，我们为每一个寄存器预留了位置，以便将其保存下来，这样就可以在进程调度模块中尽情的使用这些寄存器，而不必担心会对进程产生不良影响。 赋值tss.esp0中断的打开意味着ring0和ring1之间频繁的切换，两个层级之间的切换包含两方面，一是代码的跳转，还有一个不容忽视的地方，就是堆栈也在切换。TSS的用处知识保存ring0堆栈信息，而堆栈的信息就是ss和esp两个寄存器。由于要为先一次ring1-&gt;ring0做准备，所以用iretd返回之前要保证tss.esp0是正确的。当进程被中断切换到内核态时，当前的各个寄存器应该被立即保存（压栈）。也就是tss.esp0应该是当前进程的进程表中保存寄存器值的地方，即struct s_proc中struct中s_stackframe的最高地址处。这样进程被挂起后才恰好保存寄存到正确的位置。现在的中断程序变成了：在中断发生的开始，esp的值是刚刚从TSS里面取到的进程表A中regs的最高地址，然后各个寄存器值被压栈入进程表，最后esp指向regs的最低地址处，然后设置tss.esp0的值，准备下一次进程被中断时使用。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>进程</tag>
        <tag>中断重入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》内核雏形（3-2）]]></title>
    <url>%2F2018%2F02%2F28%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%86%85%E6%A0%B8%E9%9B%8F%E5%BD%A2%EF%BC%883-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跳入保护模式首先是GDT以及对应的选择子，我们只定义三个描述符，分别是0~4GB的可执行段、0~4GB可读写段和一个指向显存开始地址的段。因为段地址已经被确定为BaseOfLoader,所以Loader中出现的标号的物理地址可以用下面的公式表示：1物理地址 = BaseOfLoader x 10h + 变量的偏移 然后运行后，如果看到字母“p”则代表我们进入了保护模式，如图所示： 重新放置内核以及控制器的转让下图是一个内存的使用分布图。虽然引导扇区将剩余的内存空间分割成了两块，但实际上引导扇区在完成了它的使命之后就没有用了，可以视为空闲内存。运行之后，可以看到K字母，即代表成功由内核在控制了。 扩充内核切换堆栈和GDT代码如下：1234567891011121314151617181920212223242526272829303132SELECTOR_KERNEL_CS equ 8; 导入函数extern cstart; 导入全局变量extern gdt_ptr[SECTION .bss]StackSpace resb 2 * 1024StackTop: ; 栈顶[section .text] ; 代码在此global _start ; 导出 _start_start:mov esp, StackTop ; 堆栈在 bss 段中 sgdt [gdt_ptr] ; cstart() 中将会用到 gdt_ptr call cstart ; 在此函数中改变了gdt_ptr，让它指向新的GDT lgdt [gdt_ptr] ; 使用新的GDT ;lidt [idt_ptr] jmp SELECTOR_KERNEL_CS:csinitcsinit: ; “这个跳转指令强制使用刚刚初始化的结构”——&lt;&lt;OS:D&amp;I 2nd&gt;&gt; P90. push 0 popfd ; Pop top of stack into EFLAGS hlt 从上可知，用简单的4个语句就完成了切换堆栈和更换GDT的任务。其中，StackTop定义在.bass段中，堆栈大小为2KB。操做GDT时用到的gdt_ptr和cstart分别是一个全局变量和全局函数，他们定义在start.c中，如下：12345678910111213141516171819202122232425262728include "type.h"#include "const.h"#include "protect.h"PUBLIC void* memcpy(void* pDst, void* pSrc, int iSize);PUBLIC void disp_str(char * pszInfo);PUBLIC u8 gdt_ptr[6]; /* 0~15:Limit 16~47:Base */PUBLIC DESCRIPTOR gdt[GDT_SIZE];PUBLIC void cstart()&#123; disp_str("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" "-----\"cstart\" begins-----\n"); /* 将 LOADER 中的 GDT 复制到新的 GDT 中 */ memcpy(&amp;gdt, /* New GDT */ (void*)(*((u32*)(&amp;gdt_ptr[2]))), /* Base of Old GDT */ *((u16*)(&amp;gdt_ptr[0])) + 1 /* Limit of Old GDT */ ); /* gdt_ptr[6] 共 6 个字节：0~15:Limit 16~47:Base。用作 sgdt/lgdt 的参数。*/ u16* p_gdt_limit = (u16*)(&amp;gdt_ptr[0]); u32* p_gdt_base = (u32*)(&amp;gdt_ptr[2]); *p_gdt_limit = GDT_SIZE * sizeof(DESCRIPTOR) - 1; *p_gdt_base = (u32)&amp;gdt;&#125; cstart()首先把位于Loader中的原GDT全部复制给心得GDT，然后把gdt_ptr中的内容换成新的GDT的基地址和界限。复制GDT使用的是函数memcpy。运行结果如下： 整理文件 boot.asm和loader.asm放在单独的目录/boot中，相应的头文件也放在里面； klib.asm和string.asm放在/lib中，作为库； kernel.asm和start.c放在/kernel里面目录树如下：Makefile当我们把文件放在不同的文件夹了以后，编译的命令会更加的复杂，所以，我们将使用Makefile，从而输入一行命令就可以完成整个编译过程，相关的文件放在/boot中，具体代码如下：12345678910111213141516171819202122232425# Makefile for boot# Programs, flags, etc.ASM = nasmASMFLAGS = -I include/# This ProgramTARGET = boot.bin loader.bin# All Phony Targets.PHONY : everything clean all# Default starting positioneverything : $(TARGET)clean : rm -f $(TARGET)all : clean everythingboot.bin : boot.asm include/load.inc include/fat12hdr.inc $(ASM) $(ASMFLAGS) -o $@ $&lt;loader.bin : loader.asm include/load.inc include/fat12hdr.inc include/pm.inc $(ASM) $(ASMFLAGS) -o $@ $&lt; 以字符#开头的行是注释、=用来定义变量，ASM和ASMFLAGS就是两个变量，使用他们的时候要用$(ASM)和$(ASMFLAGS)。Makefile的最重要的语法如下：12target: prerequisites command 上面这样的形式表示： 要想得到target，需要执行命令command. target依赖prerequisites，当prerequisites中至少有一个文件比target文件新时，command才被执行。比如这个Makefile的最后两行，翻译出来就是： 要想得到loader.bin，需要执行“$(ASM) $(ASMFLAGS) -o $@ $&lt;”。 loader.bin依赖一下文件： loader.asm include/load.inc include/pm.inc include/fat12hdr.inc当他们中至少有一个比loader.bin新的时候，command被执行。其中 $@代表target $&lt;代表prerequisites的第一个名字。所以执行“make clean”，将会执行“rm -f $(TARGET)”也就是“rm -f boot.bin loader.bin”以下是执行make all和make的结果图：接着对makefile扩展之后，我们可以通过make building 和make image很方便的把引导扇区、load.bin和kernel。bin写入虚拟软盘。如下所示：然后再启动bochs，同时在start.c加上显示cstart end，来表示我们的make正常的进行了编译连接了，结果如图所示：添加中断处理中断要做的工作为：设置8259A和建立IDT。先写函数设置8259A:1234567891011121314151617181920212223242526272829303132PUBLIC void init_8259A()&#123; /* Master 8259, ICW1. */ out_byte(INT_M_CTL, 0x11); /* Slave 8259, ICW1. */ out_byte(INT_S_CTL, 0x11); /* Master 8259, ICW2. 设置 '主8259' 的中断入口地址为 0x20. */ out_byte(INT_M_CTLMASK, INT_VECTOR_IRQ0); /* Slave 8259, ICW2. 设置 '从8259' 的中断入口地址为 0x28 */ out_byte(INT_S_CTLMASK, INT_VECTOR_IRQ8); /* Master 8259, ICW3. IR2 对应 '从8259'. */ out_byte(INT_M_CTLMASK, 0x4); /* Slave 8259, ICW3. 对应 '主8259' 的 IR2. */ out_byte(INT_S_CTLMASK, 0x2); /* Master 8259, ICW4. */ out_byte(INT_M_CTLMASK, 0x1); /* Slave 8259, ICW4. */ out_byte(INT_S_CTLMASK, 0x1); /* Master 8259, OCW1. */ out_byte(INT_M_CTLMASK, 0xFF); /* Slave 8259, OCW1. */ out_byte(INT_S_CTLMASK, 0xFF);&#125; 相应端口的宏如下：123456789/* 8259A interrupt controller ports. */#define INT_M_CTL 0x20 /* I/O port for interrupt controller &lt;Master&gt; */#define INT_M_CTLMASK 0x21 /* setting bits in this port disables ints &lt;Master&gt; */#define INT_S_CTL 0xA0 /* I/O port for second interrupt controller&lt;Slave&gt; */#define INT_S_CTLMASK 0xA1 /* setting bits in this port disables ints &lt;Slave&gt; */....../* 中断向量 */#define INT_VECTOR_IRQ0 0x20#define INT_VECTOR_IRQ8 0x28 这个函数只用到了一个函数，就是用来写端口的out_byte，该函数体位于kliba.asm。其中不仅有out_byte对端口进行写操作还有in_byte对端口进行读操作，由于端口操作可能需要时间，所以两个函数中加了点空操作表，以便有微笑的延迟。代码如下：123456789101112131415161718192021; ========================================================================; void out_byte(u16 port, u8 value);; ========================================================================out_byte: mov edx, [esp + 4] ; port mov al, [esp + 4 + 4] ; value out dx, al nop ; 一点延迟 nop ret; ========================================================================; u8 in_byte(u16 port);; ========================================================================in_byte: mov edx, [esp + 4] ; port xor eax, eax in al, dx nop ; 一点延迟 nop ret 这两个函数放在include/proto.h中，这是一个新建立的头文件，用来存放函数声明。然后，还要修改Makefile，不但要添加新的目标kernel/i8259.o，而且由于头文件的变化，kernel/start.o的依赖关系也稍微有变化：12345678910OBJS = kernel/kernel.o kernel/start.o kernel/i8259.o kernel/global.o kernel/protect.o lib/klib.o lib/kliba.o lib/string.oDASMOUTPUT = kernel.bin.asm......kernel/start.o: kernel/start.c include/type.h include/const.h include/protect.h \ include/proto.h include/string.h $(CC) $(CFLAGS) -o $@ $&lt;kernel/i8259.o : kernel/i8259.c include/type.h include/const.h include/protect.h \ include/proto.h $(CC) $(CFLAGS) -o $@ $&lt; 我们使用gcc -M自动生成依赖关系如下图：。下面初始化IDT，它和初始化GDT类似，所以初始化GDT的方法可以拿着用，先前的gdt[]等变量都在头文件global.h中了，这样增加了代码的美感和可读性。GATE定义在protect.h中，如下：12345678910111213/* 门描述符 */typedef struct s_gate&#123; u16 offset_low; /* Offset Low */ u16 selector; /* Selector */ u8 dcount; /* 该字段只在调用门描述符中有效。如果在利用 调用门调用子程序时引起特权级的转换和堆栈 的改变，需要将外层堆栈中的参数复制到内层 堆栈。该双字计数字段就是用于说明这种情况 发生时，要复制的双字参数的数量。*/ u8 attr; /* P(1) DPL(2) DT(1) TYPE(4) */ u16 offset_high; /* Offset High */&#125;GATE; 接着，在kernel.asm中添加两句，导入idt_ptr这个符号，并加载IDT。我们对异常的处理总体是，如果有错误码，则直接把向量号压栈，然后执行一个函数exception_handler；如果没有错误码，则现在栈中压入一个0xfffffff,再把向量号压栈并随后执行exception_handler。下面是该函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PUBLIC void exception_handler(int vec_no,int err_code,int eip,int cs,int eflags)&#123; int i; int text_color = 0x74; /* 灰底红字 */ char * err_msg[] = &#123;"#DE Divide Error", "#DB RESERVED", "-- NMI Interrupt", "#BP Breakpoint", "#OF Overflow", "#BR BOUND Range Exceeded", "#UD Invalid Opcode (Undefined Opcode)", "#NM Device Not Available (No Math Coprocessor)", "#DF Double Fault", " Coprocessor Segment Overrun (reserved)", "#TS Invalid TSS", "#NP Segment Not Present", "#SS Stack-Segment Fault", "#GP General Protection", "#PF Page Fault", "-- (Intel reserved. Do not use.)", "#MF x87 FPU Floating-Point Error (Math Fault)", "#AC Alignment Check", "#MC Machine Check", "#XF SIMD Floating-Point Exception" &#125;; /* 通过打印空格的方式清空屏幕的前五行，并把 disp_pos 清零 */ disp_pos = 0; for(i=0;i&lt;80*5;i++)&#123; disp_str(" "); &#125; disp_pos = 0; disp_color_str("Exception! --&gt; ", text_color); disp_color_str(err_msg[vec_no], text_color); disp_color_str("\n\n", text_color); disp_color_str("EFLAGS:", text_color); disp_int(eflags); disp_color_str("CS:", text_color); disp_int(cs); disp_color_str("EIP:", text_color); disp_int(eip); if(err_code != 0xFFFFFFFF)&#123; disp_color_str("Error code:", text_color); disp_int(err_code); &#125;&#125; 以下就是中断异常的情况：所有的中断都会触发一个函数spurious_irq()，这个仅仅是把IRQ号打印出来。接着，我们向主8259A相应端口写入了0xFD，由于0XFD对应的二进制是11111101，于是键盘中断被打开，而其他中断任然处于屏蔽状态，最后在kernel.asm中添加sti指令设置IF位，然后make后，当我们敲击键盘任意键就如出现如下图：]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>NASM</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>内核</tag>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》内核雏形（3-1）]]></title>
    <url>%2F2018%2F02%2F28%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%86%85%E6%A0%B8%E9%9B%8F%E5%BD%A2%EF%BC%883-1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在Linux下红汇编写Hello World因为在后面的很多工作中，都要用到汇编编程，所以我们先试试用汇编在Linux下编写Hello World，具体代码如下：123456789101112131415161718192021222324252627; 编译链接方法; (ld 的‘-s’选项意为“strip all”);; $ nasm -f elf hello.asm -o hello.o; $ ld -s hello.o -o hello; $ ./hello; Hello, world!; $[section .data] ; 数据在此strHello db "Hello, world!", 0AhSTRLEN equ $ - strHello[section .text] ; 代码在此global _start ; 我们必须导出 _start 这个入口，以便让链接器识别_start: mov edx, STRLEN mov ecx, strHello mov ebx, 1 mov eax, 4 ; sys_write int 0x80 ; 系统调用 mov ebx, 0 mov eax, 1 ; sys_exit int 0x80 ; 系统调用 运行结果如下：以上代码我们只要明白一点，链接程序只能通过global关键字将默认入口点“_start”导出即可。 汇编和C同步使用这部分是今后会经常用到的，两者的调用方法如下图：foo.asm的具体代码如下：12345678910111213141516171819202122232425262728293031323334353637383940; 编译链接方法; (ld 的‘-s’选项意为“strip all”);; $ nasm -f elf foo.asm -o foo.o; $ gcc -c bar.c -o bar.o; $ ld -s hello.o bar.o -o foobar; $ ./foobar; the 2nd one; $extern choose ; int choose(int a, int b);[section .data] ; 数据在此num1st dd 3num2nd dd 4[section .text] ; 代码在此global _start ; 我们必须导出 _start 这个入口，以便让链接器识别。global myprint ; 导出这个函数为了让 bar.c 使用_start: push dword [num2nd] ; `. push dword [num1st] ; | call choose ; | choose(num1st, num2nd); add esp, 8 ; / mov ebx, 0 mov eax, 1 ; sys_exit int 0x80 ; 系统调用; void myprint(char* msg, int len)myprint: mov edx, [esp + 8] ; len mov ecx, [esp + 4] ; msg mov ebx, 1 mov eax, 4 ; sys_write int 0x80 ; 系统调用 ret bar.c的具体代码如下：12345678910111213void myprint(char* msg, int len);int choose(int a, int b)&#123; if(a &gt;= b)&#123; myprint("the 1st one\n", 13); &#125; else&#123; myprint("the 2nd one\n", 13); &#125; return 0;&#125; 运行结果如图：从代码中可以看出，其实global和extern两个关键字才是最关键的，可以方便地在汇编和C之间自由变换。 ELF（Executable and Linkable format）下图为ELF文件的结构由ELF头、程序头表、节和节头表（实际上一个文件不一定包含全部这些内容，而且它们的位置也不一定如下，只有ELF头的位置是固定的，其余部分都是由ELF头中的各项值来决定的）下面是ELFheader的数据类型：在终端输入1vi /usr/include/elf.h 可以看到：其中各项额意义为： e_ident：其中包含用来表示ELF文件的字符，以及其他一些与机器无关的信息。从下图可以很清楚的看出foobar文件的该信息： e_type:标识文件的类型，其中2代表可执行文件 e_machine:表示改程序需要的体系结构，3为Intel80386 e_version:文件版本 e_entry:程序的入口，这里为0x80480A0 e_phoff:文件中的偏移量这里为0x34 e_ehsize:大小 e_phentsize:每一个条目的大小 e_phnum:条目数 e_shstrndx:包含节名称的字符串是第几个节。从上面的Program header可以看出，foobar在内存中的加载为如下图所示：从Loader到内核研究完了ELF之后，我们接着就该完成Loader要做的两件事了 加载内存到内核 跳入保护模式用Loader加载ELF首先，我们把FAT12文件有关的东西放进fat12hdr.inc中，供boot.asm和loader.asm共享，所以boot.asm开头部分的代码就如下图：下面我们修改loader.asm，让它把内核放进内存，其代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275org 0100hBaseOfStack equ 0100hBaseOfKernelFile equ 08000h ; KERNEL.BIN 被加载到的位置 ---- 段地址OffsetOfKernelFile equ 0h ; KERNEL.BIN 被加载到的位置 ---- 偏移地址 jmp LABEL_START ; Start; 下面是 FAT12 磁盘的头, 之所以包含它是因为下面用到了磁盘的一些信息%include "fat12hdr.inc"LABEL_START: ; &lt;--- 从这里开始 ************* mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, BaseOfStack mov dh, 0 ; "Loading " call DispStr ; 显示字符串 ; 下面在 A 盘的根目录寻找 KERNEL.BIN mov word [wSectorNo], SectorNoOfRootDirectory xor ah, ah ; `. xor dl, dl ; | 软驱复位 int 13h ; /LABEL_SEARCH_IN_ROOT_DIR_BEGIN: cmp word [wRootDirSizeForLoop], 0 ; `. jz LABEL_NO_KERNELBIN ; | 判断根目录区是不是已经读完, dec word [wRootDirSizeForLoop] ; / 读完表示没有找到 KERNEL.BIN mov ax, BaseOfKernelFile mov es, ax ; es &lt;- BaseOfKernelFile mov bx, OffsetOfKernelFile ; bx &lt;- OffsetOfKernelFile mov ax, [wSectorNo] ; ax &lt;- Root Directory 中的某 Sector 号 mov cl, 1 call ReadSector mov si, KernelFileName ; ds:si -&gt; "KERNEL BIN" mov di, OffsetOfKernelFile cld mov dx, 10hLABEL_SEARCH_FOR_KERNELBIN: cmp dx, 0 ; `. jz LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR; | 循环次数控制, 如果已经读完 dec dx ; / 了一个 Sector, 就跳到下一个 mov cx, 11LABEL_CMP_FILENAME: cmp cx, 0 ; `. jz LABEL_FILENAME_FOUND ; | 循环次数控制, 如果比较了 11 个字符都 dec cx ; / 相等, 表示找到 lodsb ; ds:si -&gt; al cmp al, byte [es:di] ; if al == es:di jz LABEL_GO_ON jmp LABEL_DIFFERENTLABEL_GO_ON: inc di jmp LABEL_CMP_FILENAME ; 继续循环LABEL_DIFFERENT: and di, 0FFE0h ; else`. 让 di 是 20h 的倍数 add di, 20h ; | mov si, KernelFileName ; | di += 20h 下一个目录条目 jmp LABEL_SEARCH_FOR_KERNELBIN; /LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR: add word [wSectorNo], 1 jmp LABEL_SEARCH_IN_ROOT_DIR_BEGINLABEL_NO_KERNELBIN: mov dh, 2 ; "No KERNEL." call DispStr ; 显示字符串%ifdef _LOADER_DEBUG_ mov ax, 4c00h ; `. int 21h ; / 没有找到 KERNEL.BIN, 回到 DOS%else jmp $ ; 没有找到 KERNEL.BIN, 死循环在这里%endifLABEL_FILENAME_FOUND: ; 找到 KERNEL.BIN 后便来到这里继续 mov ax, RootDirSectors and di, 0FFF0h ; di -&gt; 当前条目的开始 push eax mov eax, [es : di + 01Ch] ; `. mov dword [dwKernelSize], eax ; / 保存 KERNEL.BIN 文件大小 pop eax add di, 01Ah ; di -&gt; 首 Sector mov cx, word [es:di] push cx ; 保存此 Sector 在 FAT 中的序号 add cx, ax add cx, DeltaSectorNo ; cl &lt;- LOADER.BIN 的起始扇区号(0-based) mov ax, BaseOfKernelFile mov es, ax ; es &lt;- BaseOfKernelFile mov bx, OffsetOfKernelFile ; bx &lt;- OffsetOfKernelFile mov ax, cx ; ax &lt;- Sector 号LABEL_GOON_LOADING_FILE: push ax ; `. push bx ; | mov ah, 0Eh ; | 每读一个扇区就在 "Loading " 后面 mov al, '.' ; | 打一个点, 形成这样的效果: mov bl, 0Fh ; | Loading ...... int 10h ; | pop bx ; | pop ax ; / mov cl, 1 call ReadSector pop ax ; 取出此 Sector 在 FAT 中的序号 call GetFATEntry cmp ax, 0FFFh jz LABEL_FILE_LOADED push ax ; 保存 Sector 在 FAT 中的序号 mov dx, RootDirSectors add ax, dx add ax, DeltaSectorNo add bx, [BPB_BytsPerSec] jmp LABEL_GOON_LOADING_FILELABEL_FILE_LOADED: call KillMotor ; 关闭软驱马达 mov dh, 1 ; "Ready." call DispStr ; 显示字符串 jmp $;============================================================================;变量;----------------------------------------------------------------------------wRootDirSizeForLoop dw RootDirSectors ; Root Directory 占用的扇区数wSectorNo dw 0 ; 要读取的扇区号bOdd db 0 ; 奇数还是偶数dwKernelSize dd 0 ; KERNEL.BIN 文件大小;============================================================================;字符串;----------------------------------------------------------------------------KernelFileName db "KERNEL BIN", 0 ; KERNEL.BIN 之文件名; 为简化代码, 下面每个字符串的长度均为 MessageLengthMessageLength equ 9LoadMessage: db "Loading "Message1 db "Ready. "Message2 db "No KERNEL";============================================================================;----------------------------------------------------------------------------; 函数名: DispStr;----------------------------------------------------------------------------; 作用:; 显示一个字符串, 函数开始时 dh 中应该是字符串序号(0-based)DispStr: mov ax, MessageLength mul dh add ax, LoadMessage mov bp, ax ; ┓ mov ax, ds ; ┣ ES:BP = 串地址 mov es, ax ; ┛ mov cx, MessageLength ; CX = 串长度 mov ax, 01301h ; AH = 13, AL = 01h mov bx, 0007h ; 页号为0(BH = 0) 黑底白字(BL = 07h) mov dl, 0 add dh, 3 ; 从第 3 行往下显示 int 10h ; int 10h ret;----------------------------------------------------------------------------; 函数名: ReadSector;----------------------------------------------------------------------------; 作用:; 从序号(Directory Entry 中的 Sector 号)为 ax 的的 Sector 开始, 将 cl 个 Sector 读入 es:bx 中ReadSector: ; ----------------------------------------------------------------------- ; 怎样由扇区号求扇区在磁盘中的位置 (扇区号 -&gt; 柱面号, 起始扇区, 磁头号) ; ----------------------------------------------------------------------- ; 设扇区号为 x ; ┌ 柱面号 = y &gt;&gt; 1 ; x ┌ 商 y ┤ ; -------------- =&gt; ┤ └ 磁头号 = y &amp; 1 ; 每磁道扇区数 │ ; └ 余 z =&gt; 起始扇区号 = z + 1 push bp mov bp, sp sub esp, 2 ; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2] mov byte [bp-2], cl push bx ; 保存 bx mov bl, [BPB_SecPerTrk] ; bl: 除数 div bl ; y 在 al 中, z 在 ah 中 inc ah ; z ++ mov cl, ah ; cl &lt;- 起始扇区号 mov dh, al ; dh &lt;- y shr al, 1 ; y &gt;&gt; 1 (其实是 y/BPB_NumHeads, 这里BPB_NumHeads=2) mov ch, al ; ch &lt;- 柱面号 and dh, 1 ; dh &amp; 1 = 磁头号 pop bx ; 恢复 bx ; 至此, "柱面号, 起始扇区, 磁头号" 全部得到 ^^^^^^^^^^^^^^^^^^^^^^^^ mov dl, [BS_DrvNum] ; 驱动器号 (0 表示 A 盘).GoOnReading: mov ah, 2 ; 读 mov al, byte [bp-2] ; 读 al 个扇区 int 13h jc .GoOnReading ; 如果读取错误 CF 会被置为 1, 这时就不停地读, 直到正确为止 add esp, 2 pop bp ret;----------------------------------------------------------------------------; 函数名: GetFATEntry;----------------------------------------------------------------------------; 作用:; 找到序号为 ax 的 Sector 在 FAT 中的条目, 结果放在 ax 中; 需要注意的是, 中间需要读 FAT 的扇区到 es:bx 处, 所以函数一开始保存了 es 和 bxGetFATEntry: push es push bx push ax mov ax, BaseOfKernelFile ; ┓ sub ax, 0100h ; ┣ 在 BaseOfKernelFile 后面留出 4K 空间用于存放 FAT mov es, ax ; ┛ pop ax mov byte [bOdd], 0 mov bx, 3 mul bx ; dx:ax = ax * 3 mov bx, 2 div bx ; dx:ax / 2 ==&gt; ax &lt;- 商, dx &lt;- 余数 cmp dx, 0 jz LABEL_EVEN mov byte [bOdd], 1LABEL_EVEN:;偶数 xor dx, dx ; 现在 ax 中是 FATEntry 在 FAT 中的偏移量. 下面来计算 FATEntry 在哪个扇区中(FAT占用不止一个扇区) mov bx, [BPB_BytsPerSec] div bx ; dx:ax / BPB_BytsPerSec ==&gt; ax &lt;- 商 (FATEntry 所在的扇区相对于 FAT 来说的扇区号) ; dx &lt;- 余数 (FATEntry 在扇区内的偏移)。 push dx mov bx, 0 ; bx &lt;- 0 于是, es:bx = (BaseOfKernelFile - 100):00 = (BaseOfKernelFile - 100) * 10h add ax, SectorNoOfFAT1 ; 此句执行之后的 ax 就是 FATEntry 所在的扇区号 mov cl, 2 call ReadSector ; 读取 FATEntry 所在的扇区, 一次读两个, 避免在边界发生错误, 因为一个 FATEntry 可能跨越两个扇区 pop dx add bx, dx mov ax, [es:bx] cmp byte [bOdd], 1 jnz LABEL_EVEN_2 shr ax, 4LABEL_EVEN_2: and ax, 0FFFhLABEL_GET_FAT_ENRY_OK: pop bx pop es ret;----------------------------------------------------------------------------;----------------------------------------------------------------------------; 函数名: KillMotor;----------------------------------------------------------------------------; 作用:; 关闭软驱马达KillMotor: push dx mov dx, 03F2h mov al, 0 out dx, al pop dx ret;---------------------------------------------------------------------------- 下面接着就是写一个内核出来，文件名为kernel.asm12345678910111213; 编译链接方法; $ nasm -f elf kernel.asm -o kernel.o; $ ld -s kernel.o -o kernel.bin #‘-s’选项意为“strip all”[section .text] ; 代码在此global _start ; 导出 _start_start: ; 跳到这里来的时候，我们假设 gs 指向显存 mov ah, 0Fh ; 0000: 黑底 1111: 白字 mov al, 'K' mov [gs:((80 * 1 + 39) * 2)], ax ; 屏幕第 1 行, 第 39 列。 jmp $ 显示字符时涉及内存操作，所以用到GDT，我们假设在Loader中段寄存器gs已经指向显存的开始。运行结果如下：]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>NASM</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>内核</tag>
        <tag>ELF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-4）]]></title>
    <url>%2F2018%2F02%2F27%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[突破512字节的限制前面我们的工作是完成了一个简陋的引导扇区，虽然感觉没做啥，但是我们实际上积累了很多代码，熟悉了保护模式。并且对存储管理、特权级控制等有了一个整体的认识。下面，我们要想办法将自己的OS进入到保护模式，虽然进入保护模式不难，但是总会收到引导扇区512字节的限制，所以下面，我们再建立一个文件，将其通过引导扇区加载入内存，然后将控制权交给它。首先，我们先理清楚一个问题，是不是被引导扇区加载到内存的就是操作系统的内核呢，我们先看看一个操作系统从开机到开始运行要经过一个怎样的过程：引导-&gt;加载内核入内存-&gt;跳入保护模式-&gt;开始执行内核。所以，很明显，在内核开始执行前，不仅仅要加载内核，还有跳入保护模式等等，而这些工作都由引导扇区来做，很有可能不止512字节，所以我们把这个过程交给叫做Loader的模块来做。引导扇区负责把Loader加载到内存，并把控制权交给它，然后其他工作都由Loader来做，而它就没有512字节的限制了。 FAT12 FAT12是DOS时代就开始使用的文件系统，直到现在还在使用。几乎所有的文件系统都会把磁盘划分为若干层次（扇区：磁盘上的最小数据单元；簇：一个或者多个扇区；分区：通常指整个文件系统）以方便组织和管理，所以我们将软盘做成FAT12格式，以方便Kernel的操作。引导扇区是整个软盘的第0个扇区，在这个扇区中有一个很重要的数据结构叫做BPB(BIOS Parameter Block)，引导扇区的格式如下图：其中，名称以BPB开头的域输入BPB,以BS_开头的域只是引导扇区的一部分。以下是整个软盘的结构图：接下来，我们试着把Loader复制到软盘上，并引导扇区找到并加载它。为简单起见，我们规定Loader只能放在根目录中，而根目录信息存放在FAT2后面的根目录区中。所以先研究根目录区。根目录区位于第二个FAT表之后，开始的扇区号为19，它有若干个目录条目组成，条目最多有BPB_RootEntCnt个。由于根目录的大小依赖BPB_RootEntCnt的，所以长度不固定。根目录区中的条目格式：当我们寻找Loader时，只要发现文件名正确就认为它是我们要找的那一个文件。其中最重要的信息是DIR_FstClus，即文件开始簇号，它会告诉我们文件存放在磁盘的什么位置，从而让我们可以找到它。由于一簇只包含一个扇区，所以简化起见，下面都用扇区来替代簇。，需要注意的是，数据区的第一个簇号是2。所以，我们必须计算根目录区所占的扇区数才能知道数据区的第一个簇在哪里。假设根目录区总共有RootDirSectors个扇区，则有： 1RootDirSectors = ((BPB_RootEntCnt*32)+(BPB_BytsPerSec-1))/BPB_BytsPerSec 有了以上公式，可以通过根目录区找到文件并看到内容，而FAT的作用在于，如果文件大于512字节，我们需要FAT表来找到所有的簇。 DOS可以识别的引导盘既然引导扇区需要有BPB等头信息才能被微软识别，我们就先加上它，让程序开头变成下面的形式：1234567891011121314151617181920212223jmp short LABEL_START ; Start to boot. nop ; 这个 nop 不可少 ; 下面是 FAT12 磁盘的头 BS_OEMName DB 'ForrestY' ; OEM String, 必须 8 个字节 BPB_BytsPerSec DW 512 ; 每扇区字节数 BPB_SecPerClus DB 1 ; 每簇多少扇区 BPB_RsvdSecCnt DW 1 ; Boot 记录占用多少扇区 BPB_NumFATs DB 2 ; 共有多少 FAT 表 BPB_RootEntCnt DW 224 ; 根目录文件数最大值 BPB_TotSec16 DW 2880 ; 逻辑扇区总数 BPB_Media DB 0xF0 ; 媒体描述符 BPB_FATSz16 DW 9 ; 每FAT扇区数 BPB_SecPerTrk DW 18 ; 每磁道扇区数 BPB_NumHeads DW 2 ; 磁头数(面数) BPB_HiddSec DD 0 ; 隐藏扇区数 BPB_TotSec32 DD 0 ; wTotalSectorCount为0时这个值记录扇区数 BS_DrvNum DB 0 ; 中断 13 的驱动器号 BS_Reserved1 DB 0 ; 未使用 BS_BootSig DB 29h ; 扩展引导标记 (29h) BS_VolID DD 0 ; 卷序列号 BS_VolLab DB 'OrangeS0.02'; 卷标, 必须 11 个字节 BS_FileSysType DB 'FAT12 ' ; 文件系统类型, 必须 8个字节 把生成的Boot.bin写入磁盘引导扇区，运行的效果没有变。说明我们现在的软盘已经能被DOS以及Linux识别了，我们已经可以方便地往上添加或删除文件了。 一个最简单的Loader我们先写一个最小的，让其显示一个字符，然后进入死循环。新建一个loader.asm，其代码如下：123456789org 0100h mov ax, 0B800h mov gs, ax mov ah, 0Fh ; 0000: 黑底 1111: 白字 mov al, 'L' mov [gs:((80 * 0 + 39) * 2)], ax ; 屏幕第 0 行, 第 39 列。 jmp $ ; 到此停住 我们将其编译,命令如下：1nasm loader.asm -o loader.bin 为了以后扩展不出问题，我们将编译后的二进制文件放在某个段内偏移0x100的位置。 加载Loader如内存要加载一个文件如内存，免不了要读软盘，这时就要用到BIOS中断int 13h。它的用法如下：。从上可知，中断需要的参数不是原来提到的从第0扇区开始的扇区号，而是柱面号、磁头号以及在当前柱面上的扇区号3个分量，所以需要我们自己来转换一下。对于1.44MB的软盘来说，总共有两面，每面80个磁道，每个磁道有18个扇区。下面的公式就是软盘容量的由来：12 x 80 x 18 x 512 =1.44MB 于是，磁头号、柱面号和起始扇区号可以用下图方法来计算：下面，我们先写一个读软盘区的函数：123456789101112131415161718192021222324252627push bp mov bp, sp sub esp, 2 ; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2] mov byte [bp-2], cl push bx ; 保存 bx mov bl, [BPB_SecPerTrk] ; bl: 除数 div bl ; y 在 al 中, z 在 ah 中 inc ah ; z ++ mov cl, ah ; cl &lt;- 起始扇区号 mov dh, al ; dh &lt;- y shr al, 1 ; y &gt;&gt; 1 (y/BPB_NumHeads) mov ch, al ; ch &lt;- 柱面号 and dh, 1 ; dh &amp; 1 = 磁头号 pop bx ; 恢复 bx ; 至此, "柱面号, 起始扇区, 磁头号" 全部得到 mov dl, [BS_DrvNum] ; 驱动器号 (0 表示 A 盘).GoOnReading: mov ah, 2 ; 读 mov al, byte [bp-2] ; 读 al 个扇区 int 13h jc .GoOnReading ; 如果读取错误 CF 会被置为 1, ; 这时就不停地读, 直到正确为止 add esp, 2 pop bp ret 因为这段代码中用到了堆栈，要在程序开头初始化ss和esp1234567BaseOfStack equ 07c00h ; 堆栈基地址(栈底, 从这个位置向低地址生长)....mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, BaseOfStack 读扇区的函数写好了，下面我们就开始在软盘中寻找Loader.bin12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061xor ah, ah ; `. xor dl, dl ; | 软驱复位 int 13h ; / ; 下面在 A 盘的根目录寻找 LOADER.BIN mov word [wSectorNo], SectorNoOfRootDirectoryLABEL_SEARCH_IN_ROOT_DIR_BEGIN: cmp word [wRootDirSizeForLoop], 0 ; `. 判断根目录区是不是已经读完 jz LABEL_NO_LOADERBIN ; / 如果读完表示没有找到 LOADER.BIN dec word [wRootDirSizeForLoop] ; / mov ax, BaseOfLoader mov es, ax ; es &lt;- BaseOfLoader mov bx, OffsetOfLoader ; bx &lt;- OffsetOfLoader mov ax, [wSectorNo] ; ax &lt;- Root Directory 中的某 Sector 号 mov cl, 1 call ReadSector mov si, LoaderFileName ; ds:si -&gt; "LOADER BIN" mov di, OffsetOfLoader ; es:di -&gt; BaseOfLoader:0100 cld mov dx, 10hLABEL_SEARCH_FOR_LOADERBIN: cmp dx, 0 ; `. 循环次数控制, jz LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR ; / 如果已经读完了一个 Sector, dec dx ; / 就跳到下一个 Sector mov cx, 11LABEL_CMP_FILENAME: cmp cx, 0 jz LABEL_FILENAME_FOUND ; 如果比较了 11 个字符都相等, 表示找到 dec cx lodsb ; ds:si -&gt; al cmp al, byte [es:di] jz LABEL_GO_ON jmp LABEL_DIFFERENT ; 只要发现不一样的字符就表明本 DirectoryEntry ; 不是我们要找的 LOADER.BINLABEL_GO_ON: inc di jmp LABEL_CMP_FILENAME ; 继续循环LABEL_DIFFERENT: and di, 0FFE0h ; else `. di &amp;= E0 为了让它指向本条目开头 add di, 20h ; | mov si, LoaderFileName ; | di += 20h 下一个目录条目 jmp LABEL_SEARCH_FOR_LOADERBIN; /LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR: add word [wSectorNo], 1 jmp LABEL_SEARCH_IN_ROOT_DIR_BEGINLABEL_NO_LOADERBIN: mov dh, 2 ; "No LOADER." call DispStr ; 显示字符串%ifdef _BOOT_DEBUG_ mov ax, 4c00h ; `. int 21h ; / 没有找到 LOADER.BIN, 回到 DOS%else jmp $ ; 没有找到 LOADER.BIN, 死循环在这里%endifLABEL_FILENAME_FOUND: ; 找到 LOADER.BIN 后便来到这里继续 jmp $ ; 代码暂时停在这里 这段代码就是遍历根目录区所有的扇区，将每一个扇区加载入内存，然后从中寻找文件名为Loader.bin的条目，直到找到为止。找到的那一刻，es:di是指向条目中字母N后面的那个字符。接着我们编译出boot.bin1nasm boot.asm -o boot.bin ,然后在bximage生成一个软盘映像，然后在Linux下输入命令：12345nasm loader.asm -o loader.bindd if=boot.bin of=a.img bs=512 count=1 conv=notruncsudo mount -o loop a.img /mnt/floppysudo cp loader.bin /mnt/floppy/ -v sudo umount /mnt/floppy 向Loader交出控制权上面代码调试通过后，我i门就已经成功的将Loader加载入内存了，接着我们加上一个跳转。开始执行Loader1234jmp BaseOfLoader:OffsetOfLoader ; 这一句正式跳转到已加载到内 ; 存中的 LOADER.BIN 的开始处， ; 开始执行 LOADER.BIN 的代码。 ; Boot Sector 的使命到此结束。 最后的结果如下 保护下的“操作系统”为了让自己的操作系统内核至少应该可以在Linux下用GCC编译链接，所以我们假设已经有了一个内核，Loader肯定要加载它乳内存，而且内核开始执行对的时候肯定已经在保护模式下了，所以Loader要做的只要有两件事： 加载内核如内存 跳入保护模式将来的内核是在Linux下编译链接出的ELF格式文件，直接放进内存肯定不行，下一章就会开始研究ELF格式。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>FAT12</tag>
        <tag>Loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-3）]]></title>
    <url>%2F2018%2F01%2F24%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[页式存储说到这个，应该不会太陌生，但是对它可能值停留在理论学习阶段，没法像数据结构那样，理性的认识，下面我们先从几个问题出发 什么叫做“页”所谓“页”，就是一块内存，在80386中，页的大小是固定的4096字节。而后来，页的大小还可以是2MB或者4MB，并且可以访问多于4GB的内存。 逻辑地址、线性地址、物理地址在未打开分页机制时，线性地址等同于物理地址。当分页开启时，分段机制将逻辑地址转换成线性地址，然后在通过分页机制变为物理地址。 为什么分页-分段管理机制，已经提供了很好的保护机制，而分页的主要目的是在线实现虚拟存储器。线性地址中，任意一个页都能映射到物理地址中的任何一个页。1.分页机制概述分页机制就像一个函数：物理地址 = f(线下地址)我们通过下图看看f是怎样的。如图所示，转换使用两级页表，第一级叫做页目录，大小为4KB，存储在一个物理页中，每个表项4字节长，公有1024个表项。每个表项对应第二级的一个页表，第二级的每一个页表也有1024个表项，每一个表项对应一个物理页。页目录的表项简称PDE，页表的表项简称PTE.进行转化时，先是从由寄存器cr3指定的页目录中根据线性地址的高10位得到页表地址，然后在页表中根据线性地址的第12到21位得到物理页首地址，将这个首地址加上线性地址低12位，便得到了物理地址。分页机制是否生效的开关位于cr0的最高位PG位。如果PG=1，则分页机制生效。2.编写代码启动分页机制下面，我们在pmtest2.asmde 基础进行修改，将实验内存写入和读取的描述符、代码以及数据统统去掉，并添加这样一个函数SetupPaging,代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PageDirBase equ 200000h ; 页目录开始地址: 2MPageTblBase equ 201000h ; 页表开始地址: 2M+4K...LABEL_DESC_PAGE_DIR: Descriptor PageDirBase, 4095, DA_DRW;Page DirectoryLABEL_DESC_PAGE_TBL: Descriptor PageTblBase, 1023, DA_DRW|DA_LIMIT_4K;Page Tables...SelectorPageDir equ LABEL_DESC_PAGE_DIR - LABEL_GDTSelectorPageTbl equ LABEL_DESC_PAGE_TBL - LABEL_GDT...; 启动分页机制 --------------------------------------------------------------SetupPaging: ; 为简化处理, 所有线性地址对应相等的物理地址. ; 首先初始化页目录 mov ax, SelectorPageDir ; 此段首地址为 PageDirBase mov es, ax mov ecx, 1024 ; 共 1K 个表项 xor edi, edi xor eax, eax mov eax, PageTblBase | PG_P | PG_USU | PG_RWW.1: stosd add eax, 4096 ; 为了简化, 所有页表在内存中是连续的. loop .1 ; 再初始化所有页表 (1K 个, 4M 内存空间) mov ax, SelectorPageTbl ; 此段首地址为 PageTblBase mov es, ax mov ecx, 1024 * 1024 ; 共 1M 个页表项, 也即有 1M 个页 xor edi, edi xor eax, eax mov eax, PG_P | PG_USU | PG_RWW.2: stosd add eax, 4096 ; 每一页指向 4K 的空间 loop .2 mov eax, PageDirBase mov cr3, eax mov eax, cr0 or eax, 80000000h mov cr0, eax jmp short .3.3: nop ret; 分页机制启动完毕 ---------------------------------------------------------- 可以看到，PageDirBase和PageTblBase是两个宏，指定了页目录表和页表在内存中的位置。页目录表位于地址处2MB，有1024个表项，占用4KB空间爱你，紧接着页目录表便是页表，位于地址2MB+4KB处。为了罗技清晰和代码编写便捷，我们分别定义两个段，用来存放页目录表和页表，大小分别是4KB和4MB。为了简单起见，我们就爱那个所有线性地址映射到相同的物理地址，于是线性地址和物理地址的关系符合下面的公式:物理地址 = f（线性地址） = 线性地址下面，我们看看PDE和PTE 3.PDE和PTBPDE:PTE： 读写权限。此位与U/S位和寄存器cr0中的WP位相互作用。R/W=0表示只读；R/W=1表示刻度并可写。 U/S指定一个页或者一组页的特权级。此位与R/W位和寄存器cr0中的WP位相互作用。U/S=0表示系统级别，如果CPL为0、1、2那么他便是在此级别；U/S=1表示用户级别，如果CPL为3，那么他便是在此级别。如果cr0中WP位为0，那么即便用户级页面的R/W=0，系统级陈翔任然具备写权限；如果WP位为1，那么系统级程序也不能写入用户级只读页。 PWT用于控制对单个页或者页表的缓冲策略。 PCD用于控制对单个页湖综合页表的缓冲。 A指示页或页表是否被访问。 D指示页或页表是否被写入 PS决定页大小 PAT选择PAT条目 G指示全局页CPU会将最近常用的页目录和页表项保存在一个叫做TLB的缓冲区中。只有在TLB中找不到被请求页的转换信息时，才会到内存中去寻找。当页目录或页表项被更改时，操作系统应该马上使TLB中对应的条目无效，以便下次使用到此条目时让他获得更新。当cr0被加载时，所有TLB都会自动无效，除非页或页表条目的G位被设置。4.cr3cr0指向页目录表，它的结构如图：cr3又叫做PDBR。它的高20位将是页目录表首地址的高20位，页目录首地址的低12位会是0，也就是说页目录表会是4KB对齐的。类似的，PDE中的页表基址以及PTE的页基址也是如此。5.克勤克俭用内存前面，我们用来 4MB的空间来存放页表，并用它映射了4GB的内存空间，而我们的物理内存不见得有这么大，这显然是太浪费了。如果我们的内存总数只有16MB的话，知识页表就占有25%的内存空间爱你了。而实际上如果仅仅是对等映射的话，16MB的内存只要4个页表就够了。所以我们有必要知道内存有多大，然后根据内存大小确定多少页表是够用的。那么程序如何知道机器内存有多少内存呢？实际上方法不止一个，在此，我们仅介绍一种通用性比较器的，就是利用中断15h.在调用它之前，需要填充如下寄存器： eax int 15h 可完成许多工作，主要由ax的值决定，我们想要获取内存信息，需要将ax赋值为0E820h。 ebx 放置着“后续值”，第一次调用时ebx必须为0. es:di 指向一个地址范围描述符结构ARDS，BIOS将会填充此结构。 ecx es：di所指向的地址范围描述符结构的大小，以字节为单位。 edxd 0534D4150h(‘SMAP’) BIOS将会使用此标志，对调用者将要请求的系统映像信息进行校验，这些信息会被BIOS放置到es:di所指向的结构中。中断调用之后，结果存放于下列寄存器之中。 CF CF=0表示没有错误，否则存在错误。 eax 0534D4150h(‘SMAP’). es:di 返回的地址房范围描述符结构指针，和输入值相同。 ecx BIOS填充在地址范围描述中的字节数量，被BIOS所返回的最小值是20字节。 ebx 这里放置着为等到下一个地址描述符所需要的后续值，这个值的实际形势依赖于具体的BIOS的实现，调用者不必关心他的具体形式，只需在下次迭代时将其原封不懂的放置在ebx中，就可以通过它获取下一个地址范围描述符。如果它的值为0，表示它是组后一个地址范围描述符。6.进一步体会分页机制在此之前，不知道你有没有注意股哦一个细节，如果你写一个程序，并改个名复制一份，然后同时调用，你会发现，从变量地址到寄存器的值，几乎全部都是一样的！这就是分页机制的功劳，下面我们就来摸摸你下这个效果。先执行某个线性地址处的模块，然后通过改变cr3来转换地址映射关系，再执行同一个线性地址处的模块，由于地址映射已经改变，所以两次得到的应该是不同的输出。映射关系转化前的情形如图：从上图很清楚的可以看到，LinearAddrDemo地址映射到ProcFoo打印出红色的字符串Foo，所以执行时我们应该可以看到红色的Foo。随后，我们改版地址映射关系，变化成如图所示：页目录表和页表的切换让LinearAddrDemo映射到ProcBar处，所以当我们再一次调用过程ProcPagingDemo时，程序将装异到ProcBar处执行，我们将看到红色的字符串Bar。中断和异常中断我们一直在用，最近的一次是通过int 15h得到了计算机内存信息。但是这都是在实模式下进行的，然后在保护模式下显示出来。这是因为在保护模式下，中断机制发生了很大变化，原来的中断向量表已经被IDT所代替，实模式下能用的BIOS中断在保护模式下已经不能用了。你可能没有听过IDT，它也是个描述符，叫做中断描述符表。IDT中的描述符可以是下面三种之一： 中断门描述符 陷阱门描述符 任务门描述符IDT的作用是将每一个中断向量和一个描述符对应起来。下图是中断向量到中断处理程序的对应过程。联系调用门，我们知道，其实中断门和陷阱门的作用机理几乎是一样的，只不过使用调用门时使用call指令，而这里我们使用int指令。其中，IDT中的任务门在某些操作系统中根本就没有用到，所以我们不做过多关注。对比调用门我们知道，在中断门和陷阱门中BYTE4的低5位变成了保留位，而不再是Param Count。而且，表示TYPE的4位也将变为0XE(中断门或0XF(陷阱门。知道这些还不够，因为中断还涉及处理器与硬件的联系等。中断和异常机制中断和异常都是在程序执行过程中的强制转移，转移到相应的处理程序。中断通常在程序执行时因为硬件而随机发生，它们通常用来处理处理器外部的事件，比如外围设备的请求。当然软件也可以通过int n指令来产生中断。异常则通常在处理器执行指令过程中检测到错误时发生。他们通俗来讲，都是软件或者硬件发生了某种情形而通知处理器的行为。那么。处理器可以处理哪些问题，以及如何处理呢？下表给出了答案：三种错误类型： Fault 是一种可被更正的异常，而且一旦被更正，程序可以不失连续地继续执行。当一个fault发生时，处理器会吧产生fault的指令之前的状态保存起来。 Trap 是一种在发生trap的指令之后立即被报告的异常，它也允许程序或任务不失连续性的继续执行。异常处理程序的返回地址将会是产生trap的指令之后的那条指令。 Abort 是一种不总是报告精确异常发生未知的异常，他不允许陈翔或任务继续执行，而是用来报告严重错误的。外部中断中断有外部中断，由硬件产生的中断，另一种是由指令int n产生的中断。外部中断，分为不可屏蔽中断（NMI）和可屏蔽中断两种。分别由CPU的两根引脚NMI和INTR来接收。如图：可屏蔽中断与CPU的关系是通过对可编程中断控制器8259A建立起来的。8259A是中断机制中所有外围设备的一个代理，这个代理不但可以根据优先级在同时发生中断的设备中选择应该处理的请求，而且可以通过对其寄存器的设置来屏蔽或打开相应的中断。主8259A对应的端口地址为20h和21h，从8259A对应的端口地址是A0h和A1h。编程操作8259A对8259A的设置是通过向相应的端口写入特定的ICW（Initialization Command Word）来实现的，它的格式如下：下面是设置8259A的代码项目地址：下载地址密码：akis12345678910111213141516171819202122232425262728293031323334353637383940414243; Init8259A ---------------------------------------------------------------------------------------------Init8259A: mov al, 011h out 020h, al ; 主8259, ICW1. call io_delay out 0A0h, al ; 从8259, ICW1. call io_delay mov al, 020h ; IRQ0 对应中断向量 0x20 out 021h, al ; 主8259, ICW2. call io_delay mov al, 028h ; IRQ8 对应中断向量 0x28 out 0A1h, al ; 从8259, ICW2. call io_delay mov al, 004h ; IR2 对应从8259 out 021h, al ; 主8259, ICW3. call io_delay mov al, 002h ; 对应主8259的 IR2 out 0A1h, al ; 从8259, ICW3. call io_delay mov al, 001h out 021h, al ; 主8259, ICW4. call io_delay out 0A1h, al ; 从8259, ICW4. call io_delay mov al, 11111110b ; 仅仅开启定时器中断 ;mov al, 11111111b ; 屏蔽主8259所有中断 out 021h, al ; 主8259, OCW1. call io_delay mov al, 11111111b ; 屏蔽从8259所有中断 out 0A1h, al ; 从8259, OCW1. call io_delay ret; Init8259A --------------------------------------------------------------------------------------------- 这段代码分别往主、从两个8259A各写入了4个ICW。在往8259A写入ICW2时，我们看到IRQ0对应了中断向量号20h，于是，IRQ0~IRQ7就对应中断向量20h~27h；类似的还有其他的。在代码后半部分，我们通过对端口21h和A1h的操作屏蔽了所有的外部中断，这一次写入的不再是ICW了，而是OCW(Operation Control Word)格式如下：可见，若想屏蔽某一个中断，将对应的那一位设为1即可。 建立IDT以及实现一个中断对8259A操作完成后，就是建立IDT了。为了方便操作，我们把IDT放进一个单独的段中。在pmtest9a.asm中可以看到，这个iDT不能再简单了，全部的255个描述符完全相同，都设置指向SelectorCode32:SpuriousHandler的中断门。SUpriousHandler也很简单，在屏幕的右上角打印红色的！，然后进入死循环。我们可以修改下IDT,把80h号中断单独列出来，并新增加一个函数来处理这个中断：UserIntHandler，它和SuprioustHandler很类似，只是在函数末尾通过iretd指令返回，而不是进入四循环。代码如pmtest9c.asm，运行结果如下： 时钟中断可屏蔽中断与NMI的区别在于是否收到IF位的影响，而8259A的中断屏蔽寄存器（IMR）也影响着中断是否会被响应。所以，外部可屏蔽中断的发生就受到两个因素的影响，只有当IF位为1，并且IMR相应位为0时才会发生。在代码pmtest9.asm的387行到392行可以看到，这个中断处理程序很简单，除了发送EOI的两行语句以及iretd，只有一条指令，就是把屏幕第0行、第70行的字符增一，变成ASCII中位于它后面的字符、由于第0行、第70行已被写入字符I,所以第一次中断发生时，那里会变成J，再次中断就变成K,以后每发生一次时钟中断，字符就会变动一次，就会看到不断变化中的字符。 保护模式下的I/O保护模式对I/O也做了限制，用户进程如果不被允许，是无法进行I/O操作的，这种限制通过两个方面来实现，IOPL和I/O许可位图。 IOPL她位于寄存器eflags的第12、13位，如图指令in、ins、out、outs、cli、sti只有在CPL&lt;=IOPL时才执行。可以改变IOPL的指令只有popf和iretd，只有运行在ring0的程序才能将其改变。运行在低特权级下的程序无法改变IOPL.指令popf同样可以用来改变IF,只有CPL&lt;=IOPL时，popf才可以成功将IF改变。 I/O许可位图之所以叫做位图，是因为它的每一位表示一个字节的端口地址是否可用，若为0表示可用，若为1表示不可用。由于每一个任务都可以有单独的TSS，所以每一个任务可以有它单独的I/O许可位图。I/O许可位图必须以0FFh结尾。若I/O许可位图基址大于或等于TSS段界限，就表示没有I/O许可位图，若CPL&lt;=IOPL，则所有I/O指令都会引起异常。I/O许可位图的使用使得即时在同一特权级下不同的任务也可以有不同的I/O访问权限保护模式小结“保护模式”包含如下几个方面的含义： 在GDT、LDT以及IDT中，每一个描述符都有自己的界限和属性等内容，是对描述符所描述对象的一种限定和保护 分页机制中的PDE和PTE都含有R/W以及U/S位，提供页级保护 页式存储的使用使得应用程序使用的是线性地址空间而不是物理地址，于是物理内存就被保护起来 中断不再像实模式下一样使用，也提供特权检验等内容 I/O指令不再随便使用，于是端口被保护起龙 在程序运行过程中，如果遇到不同特权级间的访问等情况，会对CPL、RPL、DPL、IOPL等内容进行非常严格的检验，同时可能伴随堆栈的切换，这都对不同层级的程序进行了保护。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>页式存储</tag>
        <tag>中断和异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-2）]]></title>
    <url>%2F2018%2F01%2F20%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[保护模式进阶前面我们学习了保护模式，对它的一个整体有了了解，其中突出讲解了保护模式下的强大寻址能力，但是保护模式不仅仅有这个优点，下面我们继续学习保护模式。 1.补个坑前面我们还是把保护模式写在引导扇区，这就限制在了512字节，我们就借用DOS的引导扇区来解除这个限制。首先，我们按照如下操作进行： 到Bochs官网下载FreeDOs。解压后将其中的a.img复制到工作目录下，并改名为freedos.img。 然后用bximage深层一个软盘映像，命名为pm.img。 在修改bochsrc，为如下： 1234567891011121314151617181920212223242526################################################################ Configuration file for Bochs################################################################ how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file=$BXSHARE/BIOS-bochs-latest vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest # what disk images will be usedfloppya: 1_44=freedos.img, status=insertedfloppyb: 1_44=pm.img, status=inserted# choose the boot disk.boot: a# where do we send log messages?# log: bochsout.txt# disable the mousemouse: enabled=0# enable key mapping, using US layout as default.keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map 然后启动bochs ,初始化b盘，如图： 再将代码中的07c00h改为0100h，并重新编译如图 1nasm pmtest2.asm -o pmtest2.com 再将pmtest2.com复制到软盘pm.img上,执行如下图命令： 123sudo mount -o loop pm.img /mnt/floppysudo cp pmtest2.com /mnt/floppy/sudo umount /mnt/floppy 最后的调试结果如图： 2.保护模式进阶正题坑补完了，下面正式开始保护模式的进阶学习，前面我们提到实模式下1MB的寻址能力太差了，上一篇为了突出重点，所以最后直接写的死循环，所以想要退出，只能重启电脑，现在我们尝试体验下保护模式强大的寻址能力。首先实验下读写大地址内存。在前面的代码的基础上，新建一个段段以5MB为基址，远远超出实模式下的1MB界限。新增的代码段为：123LABEL_DESC_DATA: Descriptor 0, DataLen-1, DA_DRW ; DataLABEL_DESC_STACK: Descriptor 0, TopOfStack, DA_DRWA+DA_32; Stack, 32 位LABEL_DESC_TEST: Descriptor 0500000h, 0ffffh, DA_DRW 在上篇代码的这个位置：123SelectorData equ LABEL_DESC_DATA - LABEL_GDTSelectorStack equ LABEL_DESC_STACK - LABEL_GDTSelectorTest equ LABEL_DESC_TEST - LABEL_GDT 然后需要添加的代码如下：123456789101112131415161718192021222324[SECTION .data1] ; 数据段ALIGN 32[BITS 32]LABEL_DATA:SPValueInRealMode dw 0; 字符串PMMessage: db "In Protect Mode now. ^-^", 0 ; 在保护模式中显示OffsetPMMessage equ PMMessage - $$StrTest: db "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0OffsetStrTest equ StrTest - $$DataLen equ $ - LABEL_DATA; END of [SECTION .data1]; 全局堆栈段[SECTION .gs]ALIGN 32[BITS 32]LABEL_STACK: times 512 db 0TopOfStack equ $ - LABEL_STACK - 1; END of [SECTION .gs] 如下图所示接下来我就不贴代码了，主要分析代码，理解其中原理，具体代码可以在这里下载密码为：xang 3.代码以及原理分析我们直接看到第166行，也就是[SECTION .s32]段，这一段首先将ds、es、gs分别初始化，ds指向新增的数据段，es指向新增的5MB内存，gs指向显存。之后是显示字符串，再然后是开始读写大地址内存了（第198行到200行），由于要读写2次相同的内存，所以我们读写分别用函数TestRead、TestWrite来表示这两个函数的入口分别在206行和222行，其中TestRead还调用了DispAL（将al中的字节用16进制数表示，字的前景色任然是红色）和DispReturn（模拟回车，让下一个字符显示在下一行的开头处）这两个函数。注意edi始终要指向显示的下一个字符的位置，所以，如果程序除了显示字符外还用到edi，需要事先保存它的值，以免在显示时产生混乱。最后，我们说下如何在保护模式下跳转到实模式。因为我们不能从323位代码返回实模式，只能从16位返回，这是因为无法实现从32位代码段返回时，cs高速缓冲寄存器中的属性符合实模式的要求（实模式不能改变段属性）。所以我们增加了第15行Normal描述符，在返回实模式之前，应该把选择子SelectorNormal加载到ds、es、ss.下面我们再看看返回到实模式的段[SECTION .s16code]，如上所说，把Normal赋给ds、es、fs、gs和ss，然后cr0的PE位置为0，接下来跳转。这块还不理解，以后理解了再补上！！！再跳回实模式之后，关闭A20，打开中断，重新回到原来的样子。 4.LDT（Local Descriptor Table）- 感性认识LDT是局部描述符表的建成，我们先还是通过代码来对它产生感性认识。在这里，我就不再贴代码了，仅仅把重要的代码写出来，方便理解。下面有这个部分的完整可执行代码下载。下面是代码执行完的结果：[这里下载]https://pan.baidu.com/s/1mkj6GPi)密码为：uzja - 代码分析在pmtest3.asm中，从11行开始到134行，是对LDT的初始化，包括对选择子的创建。接着是新增的两个节，其中一个是新的描述符表，也就是LDT，另一个是代码段，对应新增的LDT中的一个描述符。然后在217行到220行，是加载ldte，这里和GDT很相似，但是在选择子上，多了一个SA_TIL,这个属性在pm.inc中可以看到，是：1SA_TIL EQU 4 从上图可知这个属性将SelectorLDTCodeA的TI位 置为1.这一位是区别GDT的选择子和LDT的选择子的关键。如果TI被置位，那么系统将从LDT中寻找相应描述符。总结下这部分内容，我们已经看到，在描述符中段基址段界限定义了一个段的范围，这无疑是一种对段的保护。所以，不知不觉，我们已经接触到了一些保护机制。接下来，我们将加深对“保护”的理解，下面，我们即将介绍的是特权级。 5.特权级 特权级概述在IA32的分段机制中，特权级总共有4个特权级别，从高到低分别为0、1、2、3.数字越小特权级越大。所以我们也将高特权的称为内层，而把低特权级称为外层。 CPL、DPL、RPLCPU通过识别以上三种特权级进行特权级检验。首先，CPL（Current Priviliege Level）。它是当前只想能够的程序或者任务的特权级，被存储在cs和ss的第0位和第1位上。在通常情况下，CPL等于代码所在的段的特权级。在遇到一致代码段时，可以被相同或者更低特权的代码访问。否则不改变CPL。其次，DPL（Descriptor Privilege Level）。DPL表示段或者门的特权级。它被存储在段描述符或者门描述符的DPL字段中。根据门或者段的类型不同，DPL将会被区别对待。在数据段中，DPL规定了可以访问此段的最低特级权；在非一致代码段，DPL规定访问此段的特权级；在调用门，DPL规定了当前执行的程序或任务可以访问此调用门的最低特权级，和数据段一样。最后，RPL（Requested Privilege Level）。RPL是通过段选择子的第0位和第1位表现出来的。CPU通过检测RPL和CPl来确认一个访问请求是否合法。也就是说，如果RPL的数字比CPL大，呢么RPL将会起决定性作用。操作系统往往用RPL来避免低特权应用访问高特权段内的数据。 一个特权级检验实验由上面我们很容易知道，对于数据的访问，特权级检验还是比较简单的，只要CPL和RPL都小于被访问的数据段的DPL就可以了。我们现在就开始实验：首先，将先前例子中的数据段描述符的DPL修改一下，将LABEL_DESC_DATA对应的段描述符的DPL修改为1：1LABEL_DESC_DATA: Descriptor 0, DataLen - 1, DA_DRW+DA_DPL1 ; Data 运行后结果不变。接着，继续将刚修改过的数据段的选择子RPL改为31SelectorData equ LABEL_DESC_DATA - LABEL_GDT+SA_RPL3 这时，出现错误了这个错误很好理解，我们违反了特权级的规则，用RPL=3的选择子去访问DPL=1的段，浴室引起异常。而我们又没有相应的异常处理模块，于是出错。下面，我们再看看不同特权级之间的转移情况是怎样的。 不同特权级代码之间的转移程序从一个代码段到另一个代码段之前，目标代码的选择子会被加载到cs中。作为加载过程的一部分，处理器会坚持描述符的界限、类型、特权级等。程序控制转移的发生，可以是由指令jmp、call、ret、sysenter、sysexit、int或iret引起，也可以由中断和异常机制引起。6.特权级转移 首先，同门先来看看通过jmp或者call进行直接转移对通过jmp或call进行直接转移，如果目标是非一致性代码段，要求CPL必须等于目标段的DPL，同时要求RPL小雨等于DPL；如果是一致代码段，则要求CPL大于或者等于目标段的DPL，此时RPL不做检查。所以想要自由的进行不同特权级之间的转移，就需要用门或者TSS.-接着， “门”的初体验门也是一种描述符，它的结构如下：门描述符的结构就是这样子，直观可以看出，一个门描述了有一个选择子和一个偏移所指定的线性地址，程序正是同这个地址进行转移的。门描述符分为4种：（1）调用门（Call Gates）（2）中断门（Interrupt Gates）（3）陷阱门（Trap Gates）（4）任务门（Task Gates）我们先看看调用门，值关注它的工作方式，在代码段pmtest3.asm的基础上增加一个代码段作为调用门转移的目标段：1234567891011121314151617[SECTION .sdest]; 调用门目标段[BITS 32]LABEL_SEG_CODE_DEST: ;jmp $ mov ax, SelectorVideo mov gs, ax ; 视频段选择子(目的) mov edi, (80 * 12 + 0) * 2 ; 屏幕第 12 行, 第 0 列。 mov ah, 0Ch ; 0000: 黑底 1100: 红字 mov al, 'C' mov [gs:edi], ax retfSegCodeDestLen equ $ - LABEL_SEG_CODE_DEST; END of [SECTION .sdest] 我们带酸用call指令掉哦也难怪将要建立的调用门，所以，在这段代码的结尾调用了一个retf指令。接着，计入这个代码段的描述符，选择子以及初始化这个描述符的代码。1LABEL_DESC_CODE_DEST: Descriptor 0,SegCodeDestLen-1, DA_C+DA_32; 非一致代码段,32 1SelectorCodeDest equ LABEL_DESC_CODE_DEST - LABEL_GDT 123456789; 初始化测试调用门的代码段描述符 xor eax, eax mov ax, cs shl eax, 4 add eax, LABEL_SEG_CODE_DEST mov word [LABEL_DESC_CODE_DEST + 2], ax shr eax, 16 mov byte [LABEL_DESC_CODE_DEST + 4], al mov byte [LABEL_DESC_CODE_DEST + 7], ah 初始化描述符已经能够很熟悉了，以后就不再赘述了。下面添加调用门：123; 门 目标选择子,偏移,DCount, 属性LABEL_CALL_GATE_TEST: Gate SelectorCodeDest, 0, 0, DA_386CGate+DA_DPL0 这个，我们用了一个宏Gate来初始化，这个宏可以在pm.inc中找到。他和Descriptor宏有点类似，也是将描述符的构成要素分别安置在相应的位置，是代码看起来非常清晰。我们的门描述符的属性是DA_386CGate，表示它是一个调研那个门。里面指定的选择子是SelectorCodeDest，表明代码段是刚刚新调价的代码段。偏移地址是0，表示将跳转到目标代码段的开头出。另外，我们把其DPL指定为0.好了，现在调用门准备就绪了，它指向的位置是SelectorCodeDest：0，即标号LABEL_SEG_CODE_DEST处的代码。到这里，我们就可以用call指令来使用这个调用门了，这个call指令被放进局部任务之前，由于我们新加的代码以指令retf结尾，所以代码最终将会跳回call指令的下面继续执行，所以，我们最终会看到在pmtest3执行结果的基础上，多出一个红色的字母C。如图所示：总结起来，调用门听起来很可怕，本质上只不过是个入口地址，只是增加了若干的属性而已。我们接下来，激昂要用它来实现不同特权级的代码之间的转移，下图是特权检测的规则：从上可知，通过调用门和call指令，可以实现从低特权级到高特权级的转移。 下面，我们看一下整个转移过程是怎样的。 根据目标代码段的DPL从TSS中选择应该切换至哪个ss和esp 从TSS中读取新的ss和esp。在这个过程中如果发现ss、esp或者TSS界限错误都会导致无效TSS异常 对ss描述符进行检验，若异常，同样产生异常 暂时性地保存当前ss和esp的值 加载新的ss和esp 将刚刚保存起来的ss和esp的值压入新栈 从调用者堆栈中将参数复制到被调用者堆栈中，复制参数的数目由调用门中Param Count一项来决定。 将当前的cs和eip压栈。 加载调用门中指定的心得cs和eip，开始执行被调用者过程。综上，使用调用门的过程实际上分为两个部分，一部分是从低特权级到高特权级，通过调用门和call指令来实现；另一部分是从高特权级到di低特权级，通过ret指令来实现。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>Bochs</tag>
        <tag>NASM</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+Coding+万网域名建站教学--如何被百度谷歌收录]]></title>
    <url>%2F2018%2F01%2F18%2FHexo-Github-Coding-%E4%B8%87%E7%BD%91%E5%9F%9F%E5%90%8D%E5%BB%BA%E7%AB%99%E6%95%99%E5%AD%A6-%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这篇博文主要是写搭建好博客以后，想要自己的网站能被其他人看到，那么最起码能在百度或者谷歌中搜索出来。 1.准备工作首先必须得满足以下条件才能用我的方法： 一个备案过了的域名比如wcqwolflow.com,域名可以在万网上买 在Github上部署好的博客 在Coding部署好的博客被谷歌收录特别简单，但是被百度收录巨麻烦，Coding可以看成是国内的Github，因为Github嫌弃百度蜘蛛爬取的太频繁，所以屏蔽的百度。所以我的思路就是，通过对我的域名的解析操作，让国内的域名解析到Yourname.Coding.me让国外的域名解析到Yourname.github.io最后的成果就是可以通过China.com解析到如下图：2.具体步骤第一步：在Github和Coding上同时部署和发布你的小站这个网上教程一大堆，最后的结果就是执行命令123hexo cleanhexo ghexo d 后，在Coding和Github上都可以看到自己的博客文件如下：Coding：Github： 第二步：在Github和Coding上都绑定自己的域名其中要在Coding的Page服务里修改成如下：在Github的Setting里修改成如下：第三步：注册DNSPOD，并在购买域名的商家处修改DNS服务器为图中记录类型为NS的地方：在这里解释下为什么选择DNSPOD，我在万网买的一年的域名，但是万网的线路类型选择了世界以后，在DNS解析时，还是没法将海外的解析成wcq19941215.github.io，所以换成了DNSPOD图中的参数设置： 到此，域名设置都完成了，我们可以在百度和谷歌里输入site:你的域名。会显示类似下图的样子：我们点击提交网址可以看到上面的图片，具体怎么提交给百度和谷歌的方式有一大堆，可以自己去看看。 3.最关键的地方你如果按照我的做了，你在如图画圈的地方应该看到的是抓取成功 (有跳转)，那么意味着，百度蜘蛛永远无法爬取到你的网站：这是因为Coding的银牌会员默认是跳转首页，然后再跳转到你的仓库的，解决办法如下：首先在Coding的Page服务页面找到这个然后在你网站首页加上这个：加这个的方法是，在你本地找到hexo放置的地方themes\next\layout_partials\footer.swig 加上下面代码如图：123&lt;span&gt; Hosted by &lt;a href="https://pages.coding.me" style="font-weight: bold"&gt;Coding Pages&lt;/a&gt; &lt;/span&gt; 两天左右，等DNS迭代递归全球服务器解析完成和Coding首页审核完成，你就会在百度中看到这个：]]></content>
      <categories>
        <category>博客搭建遇到的坑</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>Hexo</tag>
        <tag>DNS解析</tag>
        <tag>百度抓取成功 (有跳转)</tag>
        <tag>谷歌收录</tag>
        <tag>Coding</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2.1）]]></title>
    <url>%2F2018%2F01%2F16%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[保护模式和开始理解操作系统一样，我们可能对什么是保护模式完全不了解，没关系，我们先从下面代码开始。 1. 认识保护模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576%include "pm.inc" ;常量 ，宏 ，以及一些说明org 07c00h jmp LABEL_BEGIN[SECTION .gdt]; GDT; 段基址， 段界限， 属性LABEL_GDT: Descriptor 0, 0, 0;空描述符LABEL_DESC_CODE32: Descriptor 0, SegCode32Len - 1, DA_C+DA_32;非一致代码段LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW;显存首地址; GDT结束GdtLen equ $-LABEL_GDT ;GDT长度GdtPtr dw GdtLen-1 ;GDT界限 dd 0 ;GDT基地址 ;GDT选择子SelectorCode32 equ LABEL_DESC_CODE32 -LABEL_GDTSelectorVideo equ LABEL_DESC_VIDEO -LABEL_GDT; END of [SECTION .gdt][SECTION .s16][BITS 16]LABEL_BEGIN: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, 0100h ;初始化32位代码段描述符 xor eax,eax mov ax, cs shl eax,4 add eax,LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32+2],ax shr eax,16 mov byte [LABEL_DESC_CODE32+4],al mov byte [LABEL_DESC_CODE32+7],ah ;为加载GDTR做准备 xor eax,eax mov ax,ds shl eax,4 add eax,LABEL_GDT;eax&lt;-gdt基地址 mov dword [GdtPtr+2],eax;[GdtPtr+2]&lt;-gdt基地址 ;加载GDTR lgdt [GdtPtr] ;关中断 cli ;打开地址线A20 in al,92h or al,00000010b out 92h,al ;准备切换到保护模式 mov eax,cr0 or eax,1 mov cr0,eax ;真正进入保护模式 jmp dword SelectorCode32:0;执行这一句会吧SelectorCODE32装入cs, ;并且跳转到Code32Selector:0; ;END of [SECTION .s16][SECTION .s32];32位代码段，由实模式跳入[BITS 32]LABEL_SEG_CODE32: mov ax,SelectorVideo mov gs,ax;视频段选择子（目的） mov edi,(80*11+79)*2;屏幕第11行，第79列。 mov ah,0Ch ;0000:黑底 1100：红字 mov al,'P' mov [gs:edi],ax ;到此停止 jmp $SegCode32Len equ $-LABEL_SEG_CODE32;END of [SECTION .32] 可能上述代码，你看到一半就不耐烦了，没关系，先执行一下它，和前面一个章节一样，先生成pmtest.bin文件，看看效果再说，执行如图所示命令：得到的结果如下：可以看到，在屏幕的右边有个红色的“P”,显然程序的最后一部分将其写入了显存中（PS:该项目的地址都在第二篇博文里） 2. 代码解释首先，看[SECTION .gdt]段，其中的Descriptor是在pm.inc中的宏。具体意义先不用管，只用了解这是一个数据结构，8字节大小。如下:12345678910111213; 节选自pm.inc;描述符; usage: Descriptor Base, Limit, Attr; Base: dd; Limit: dd (low 20 bits available); Attr: dw (lower 4 bits of higher byte are always 0)%macro Descriptor 3 dw %2 &amp; 0FFFFh ; 段界限1 dw %1 &amp; 0FFFFh ; 段基址1 db (%1 &gt;&gt; 16) &amp; 0FFh ; 段基址2 dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) ; 属性1 + 段界限2 + 属性2 db (%1 &gt;&gt; 24) &amp; 0FFh ; 段基址3%endmacro ; 共 8 字节 在这个段中，并列的三个Decriptor，所构成的数据就是GDT()GdtLen是它的长度，GdtPtr包含6字节，前2字节是GDT的界限，后4字节是GDT的基地址.后面两个段[SECTION .16]和[SECTION .32]很容易理解是16位和32位代码段，意思就是在16位中修改了GDT中的值，然后跳转到32位，执行最后一小段显示红色P的代码，然后进入无线循环。也就是真正进入保护模式。从这个我们可以了解如下内容： 我们定义了一个叫做GDT的数据结构（可能现在有人会想，为啥到现在都不讲什么是保护模式，它有什么用？不急慢慢往后看这部分的内容很多的） 后面的16位的段，进行了一些对GDT的操作 最后jmp到了32位，执行写入显存显示红字，然后结束了 我们不明白的有： GDT是什么？有什么用？ 程序对它进行了什么操作 jmp SelectorCode32：0 和以前的jmp有什么不同 3.GDT（Global Descriptor Table）首先解释保护模式和实模式。在IA32下，cpu有保护模式和实模式两种工作模式。当我们打开PC时，cpu工作在实模式下，经过莫衷机制后，才进入保护模式。在保护模式下CPU有巨大的寻址能力，并且为32位操作系统提供了更好的硬件保障。在Intel8086时，CPU有16位的寄存器、16位的数据总线以及20位的地址总线和1MB的寻址能力。一个地址由段和偏移两部分组成，物理地址的计算公式如下：1物理地址 = 段值 * 16 + 偏移 从80386开始，CPU进入32位，有32位地址线，所以寻址空间达到4GB。所以但从寻址看，16位已经不满足了。所以需要新方法来提供更强大的寻址能力。在实模式下，16位寄存器通过段+偏移来达到1MB的寻址能力，而32为寄存器一个就可以寻址4GB的空间了，但在保护模式下，任然可用过段+偏移的方式，但是，这时的段的概念已经发生根本性的变化了。这时的段只是索引，指向了一个数据结构—GDT（也可以是LDT以后会讲）。其中的表项有个专门的明治，叫做描述符。总的来说，GDT的作用是用来提供段式存储机制。这种机制是通过寄存器和GDT中的描述符共同提供的，下面我们看看代码段和数据段描述符的结构： 在本例中的描述符有三个节选上面的 代码如下：1234567[SECTION .gdt]; GDT; 段基址， 段界限， 属性LABEL_GDT: Descriptor 0, 0, 0;空描述符LABEL_DESC_CODE32: Descriptor 0, SegCode32Len - 1, DA_C +DA_32;非一致代码段LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW;显存首地址; GDT结束 其中DESC_VIDEO的基地址为0B000h，是显存处。现在我们知道了GDT中的每一个描述符定义一个段，那么cs、ds等段寄存器是这样和这些段对应的：12mov ax,SelectorVideomov gs,ax 其中SelectorVideo为：1SelectorVideo equ LABEL_DESC_VIDEO - LABEL_GDT 其中SelectorVideo直观可以看出是DESC_VIDEO这个描述符相对于GDT基址的偏移。实际上它有专门的名称，叫做选择子，它也不是一个偏移。总之，整个段式寻址示意图如下： 到此，我们对这段代码理解的差不多了，仅剩下[SECTION .16]段了，其实也很容易了，既然下[SECTION .32]是32位程序，那么下[SECTION .16]的任务就是从实模式向保护模式跳转了。 4.实模式向保护模式的跳转首先，我们把[SECTION .16]段，拿出来仔细看看12345678910111213141516171819202122232425262728293031323334353637383940414243[SECTION .s16][BITS 16]LABEL_BEGIN: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, 0100h ;初始化32位代码段描述符 xor eax,eax mov ax, cs shl eax,4 add eax,LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32+2],ax shr eax,16 mov byte [LABEL_DESC_CODE32+4],al mov byte [LABEL_DESC_CODE32+7],ah ;为加载GDTR做准备 xor eax,eax mov ax,ds shl eax,4 add eax,LABEL_GDT;eax&lt;-gdt基地址 mov dword [GdtPtr+2],eax;[GdtPtr+2]&lt;-gdt基地址 ;加载GDTR lgdt [GdtPtr] ;关中断 cli ;打开地址线A20 in al,92h or al,00000010b out 92h,al ;准备切换到保护模式 mov eax,cr0 or eax,1 mov cr0,eax ;真正进入保护模式 jmp dword SelectorCode32:0;执行这一句会吧SelectorCODE32装入cs, ;并且跳转到Code32Selector:0;;END of [SECTION .s16] 初始化32位代码段描述符12345 add eax,LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32+2],axshr eax,16mov byte [LABEL_DESC_CODE32+4],almov byte [LABEL_DESC_CODE32+7],ah 先把[SECTION .s32]赋值给eax,然后把他分为3个部分，分别给[LABEL_DESC_CODE32的相应位置，至此初始化完成。然后，因为保护模式下的中方段处理机制是不一样的的，不关掉中断会出现错误。接着打开A20,因为它默认是关闭的。（具体这块的解释因为涉及到8086的历史问题，就不再赘述了）最后的一部分代码中的寄存器cr0如图所示所以代码中的0到1，是决定性的，因为cr0的0号位置是PE,此位是0时为实模式，为1时是保护模式！ 执行完1mov cr0 , eax 系统就运行在保护模式下了。但是此时cs的值任然是实模式下的值，我们需要把代码段的选择子装入cs。所以才有了：1jmp dword SelectorCOde32:0 这个jmp看起来稍微复杂了点，因为它不得不放在16位的段中，目标却是32位的。至此，我们成功进入保护模式。下面我们总结进入保护模式的主要步骤： 准备GDT. 用lgdt加载gdte. 关中断。 打开A20。 置cr0的PE位为1. 跳转，进入保护模式。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>Bochs</tag>
        <tag>NASM</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE's:一个操作系统实现》搭建工作环境（1）]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%90%AD%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[BOchs虚拟机可以让我们像上帝一样，随时让时间“停住”钻进计算机里的小计算机里，CPU、内存、硬盘等尽收眼底 Bochs虚拟机的安装安装环境：Window7 64位下的Vm虚拟机（11.0.4）下的Ubuntu16.0.4 Bochs2.6.9安装过程： 1我在官网下载好bochs-2.6.9.tar.gz后，放在MyOS目录下，第一步解压1sudo tar zxvf bochs-2.6.9.tar.gz Bochs下载链接 2进入bochs-2.6.9目录下开始编译安装：1sudo make 1sudo make install 3安装完成后如图 Bochs的使用1创建一个软盘映像代码如图所示：完成以后，在当前目录下就多出了一个a.img 现在我们有了“计算机”和“软盘”，是时候将引导扇区写进软盘了。我们使用dd命令：1dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc 其中 boot.bin 文件需要复制到和a.img同一目录下。这行代码中“conv=notrunc”若不用，a.img会被截断，因为boot.bin比a.img小。 2配置Bochs这一步是为了说明虚拟级的内存大小、硬盘映射和软盘映射都是哪些文件。配置文件bochsrc内容如下：12345678910111213141516171819202122232425################################################################ Configuration file for Bochs################################################################ how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file=$BXSHARE/BIOS-bochs-latest vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest # what disk images will be usedfloppya: 1_44=a.img, status=inserted# choose the boot disk.boot: floppy# where do we send log messages?# log: bochsout.txt# disable the mousemouse: enabled=0# enable key mapping, using US layout as default.keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map 然后再输入命令：1bochs -f bochsrc 会出现下面内容，然后选择6，若出现黑色的框也就是Bochs那就是成功啦，然后再终端输入c,大功告成！！ 用Bochs调试操作系统我们以开始的引导扇区为例，在07c00h处设置断点，从这里开始执行，然后单步执行，和其他调试工具一样。同时在任何时刻你都可以查看CPU寄存器，或者查看某个内存地址处的内容。下面我们具体操作一下：注意！！！： bochs 2.3.5 以上的版本没有dump_cpu了,可以用r，fp，mmx，sse，dreg，sreg，creg命令代替。 附录调试命令： 接着安装GCC和NASM查看某软件是否安装的命令 * -v下载安装某软件的命令，123sudo apt-get install build-essential ***例子：安装nasmsudo apt-get install build-essential nasm]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>NASM</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>Bochs2.6.9虚拟机</tag>
        <tag>Bochs配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE's:一个操作系统实现》准备工作（0）]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[马上开始动手写最小的一个“操作系统” 1.准备的工具 具有Window或者Linux的计算机 汇编编译器NASM下载地址：http://www.nasm.us/ VM虚拟机（11.1.3） MASM2015当作汇编的编辑器 2.操作系统源码123456789101112131415161718 org 07c00h ;告诉编译器程序加载到7c00处 mov ax,cs mov ds,ax mov es,ax call DispStr ;调用显示字符串例程 jmp $ ;无限循环DispStr: mov ax, BootMessage mov bp, ax ;ES:BP=串地址 mov cx, 16 ;CX=串长度 mov ax, 01301h ;AH=13,AL=01h mov bx, 000ch ;页号为0（BH=0）黑底红字（Bl=OCh，高亮） mov dl, 0 int 10h ;10h号中断 retBootMessage: db "His World dwj!" times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节dw 0xaa55 ; 结束标志 3编译源码制作img文件（软盘镜像文件）操作系统要在裸机上跑（没有操作系统的电脑），所以使用VM虚拟机来运行我们写的操作系统，同时又因为现在很多人的电脑都没有光驱了，所以没法制作光盘来做启动盘，这个时候可以用如下命令：1nasm boot.asm -o boot.img 来生成img文件，这个文件就等同于软盘文件，可以放在虚拟机里跑。具体的例子如图： （1）首先在MASM上编写汇编源码（各行代码含义后面会讲到）： （2）然后在cmd中，找到boot.asm的位置，如图： （3）然后输入命令：1nasm boot.asm -o boot.img 就可以看到，新生成了boot.img （4）打开虚拟机新建，如下列图：一路NEXT，直到下图：然后可以得到一个空白的裸机，用来跑自己写的OS用：因为我用的.img文件做虚拟软盘，所以需要编辑虚拟机设置：然后选择自己的boot.img文件在那即可 即可显示Hello World!是不是有点小激动呢，哈哈。但是，事实上，这个东西还算不上完整的操作系统，只是最简单的引导扇区，但是它和其他软件不同，它是直接在裸机上跑的，已经具备了操作系统的一个特性。 4代码解释org 07c00h：以为计算机电源被打开时，它会先进行加电自检，然后寻找启动盘，这行代码就是告诉BIOS，一旦发现了引导扇区，就将这段512字节的内容装载到0000:7c00处，然后将控制权交给这段引导代码。到此，计算机不再由BIOS中固有的程序控制，而编程由自己的OS的一部分来控制。 mov ax,cs mov ds,axmov es,ax：这三个mov指令，是将ds和es两个段寄存器指向与cs相同的段。 mov ax, BootMessage：把BootMessage中的值的首地址传给寄存器ax(pS：Nasm中，不加[]的标签或者变量都被认为是地址)。 ($-$$)：开始汇编处，距离本行的相对位置。 dw 0xaa55：计算机只有找到0xaa55为结束，才会认为是软盘启动。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>NASM</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王超群的博客世界]]></title>
    <url>%2F2018%2F01%2F04%2F%E7%8E%8B%E8%B6%85%E7%BE%A4%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[写在开头的话一直都想搞个博客，但是一直都有事情耽搁了，现在在做毕设，刚好可以把以前没做的事都好好的做做。包括操作系统的实现、机器学习、算法与数据结构等等，都系统的学一下，弥补在大学没有深入学习的遗憾。 首先是博客搭建以前用过腾讯云+wordpress在Linux下建站，但是没时间管理，所以弃了，现在用的是Github+hexo，感觉很不错，也让人有欲望写学习笔记和写心得，现在把搭建博客的流程详细记录一下，为第一篇博文练手，也可以给其他像我一样想这样建立自己博客的朋友提供一个参考。具体的搭建流程可以参考https://www.cnblogs.com/visugar/p/6821777.html 下面我只把HEXO使用的相关命令贴出来： 一、将本地与git仓库对应连接起来1、绑定用户12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 2、配置ssh1$ ssh-keygen -t rsa -C "email@example.com" 3、测试ssh1$ ssh -T git@github.com 4、克隆仓库到本地1$ git clone git@github.com:Your Name/*****.github.io.git 5、初始化仓库1$ git init 二、上传项目、文件、文件夹1、上传README文件123456$ git init$ touch README.md$ git add README.md$ git commit -m 'first_commit$ git remote add origin git@github.com:Your Name/*****.github.io.git$ git push origin master 2、上传项目、文件、文件夹123456$ git add . $ git commit -m 'first_commit'$ git remote add origin git@github.com:Your Name/*****.github.io.git（如果错误 git remote rm origin）$ git push -u origin master（如果错误 git pull origin master） 三、下载项目12$ git init$ git pull git@github.com:Your Name/*****.github.io.git 其次是学习主要在完成毕设的同时，学习OS，首先学习下ORANGE’S：一个操作系统的实现这本书，手头有这本书的扫描版和相关光盘附件。 下载地址：https://pan.baidu.com/s/1o8US7J8 密码：byf9 然后再学习MIT6.828课程。预计在2018年2月就学完第一块了。剩下的计划慢慢来吧。]]></content>
      <tags>
        <tag>江汉大学</tag>
        <tag>HEXO</tag>
        <tag>Orange S：一个操作系统的实现(有光盘)</tag>
      </tags>
  </entry>
</search>
