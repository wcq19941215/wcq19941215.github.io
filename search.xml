<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（11）--盛最多水的容器（中等题）]]></title>
      <url>/2019/07/23/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8811%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-盛最多水的容器"><a href="#题目-盛最多水的容器" class="headerlink" title="题目:盛最多水的容器"></a>题目:盛最多水的容器</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (<span class="selector-tag">i</span>, ai) 。在坐标内画 n 条垂直线，垂直线 <span class="selector-tag">i</span> 的两个端点分别为 (<span class="selector-tag">i</span>, ai) 和 (<span class="selector-tag">i</span>, <span class="number">0</span>)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">说明：你不能倾斜容器，且 n 的值至少为 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/35086262/61675730-1b517400-ad2c-11e9-8184-dda9df514747.jpg" alt="question_11"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">双指针游标，每游一次，对比当前值和最大值，保留最大值，然后判断左右谁小，谁小就移动谁。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxArea(vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">       <span class="built_in">while</span>(i&lt;j)</span><br><span class="line">       &#123;</span><br><span class="line">           r=<span class="built_in">max</span>(r,<span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j])*(j-i));</span><br><span class="line">           (<span class="built_in">height</span>[i]&lt;<span class="built_in">height</span>[j])?i++:j--;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="built_in">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">24</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 盛最多水的容器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（15）--正则表达式匹配（困难题）]]></title>
      <url>/2019/06/14/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8815%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-正则表达式匹配"><a href="#题目-正则表达式匹配" class="headerlink" title="题目:正则表达式匹配"></a>题目:正则表达式匹配</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</span><br><span class="line"></span><br><span class="line">'.' 匹配任意单个字符</span><br><span class="line">'*' 匹配零个或多个前面的那一个元素</span><br><span class="line"></span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br><span class="line"></span><br><span class="line"><span class="section">说明:</span></span><br><span class="line"></span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: "a" 无法匹配 "aa" 整个字符串。</span></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"c*a*b"</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span></span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">"mississippi"</span></span><br><span class="line">p = <span class="string">"mis*is*p*."</span></span><br><span class="line"><span class="section">输出: false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">递归解决方案：</span><br><span class="line">在想到递归之前，我一直想用最简单的<span class="keyword">if</span> <span class="keyword">else</span>解决，在理清了思路以后，发现每次遇到p[j]==<span class="string">'*'</span>时就进行不下去了，这时我意识到自己的思路还没有理清，所以推倒重来。然后发现，其实可以把思路精简为如下<span class="number">3</span>种情况进行思考：</span><br><span class="line"> <span class="number">1</span>、当p[j]和s[i]都是字母的时候</span><br><span class="line">    此时非常好分析，直接比较即可，如果匹配则j++，i++就可以了</span><br><span class="line"> <span class="number">2</span>、当p[j]=<span class="string">'.'</span>时</span><br><span class="line">    直接跳过p[j]进行到下一个即可，类似情况<span class="number">1</span></span><br><span class="line"> <span class="number">3</span>、当p[j]=<span class="string">'*'</span></span><br><span class="line">    这是最麻烦的一种情况，但是*可以这么理解，它相当于对前一个字符的补充说明，说明前一个字符到底是<span class="number">0</span>个还是多个,那么就可以视为*是和字母或者<span class="string">'.'</span>是绑定在一起的，每当匹配字母或者<span class="string">''</span>就检查后面是否跟着一个<span class="string">'*'</span>。举个栗子，s:abbc和p:ab*c 当检查到第一个b的时候，发现p中的b后有一个*，此时只有两种可能，一是跳过p中的b*，b*的含义相当于有<span class="number">0</span>个b，那么这时就会让s中的第一个b和p中的c匹配，如果不成功，那么就进行第二种情况，b*的含义就为多个b,那么s往后移动一位，p不变，再然后就是s中的b与p当前的b比较，然后重复上述过程跳过b*，s中的c就会与p中的c进行匹配,匹配成功结束. </span><br><span class="line">伪码如下：</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">string</span> p</span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        取p的第二个字符p[<span class="number">1</span>],s的第一个字符s[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>]==<span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            上述分析中的两种情况，<span class="number">1</span>是p中的b*视为<span class="number">0</span>个b，所以跳过；<span class="number">2</span>是b*视为多个b，所以s往后移动一位</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>))||(isMatch(s.substr(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            当p[<span class="number">0</span>]为普通字母或者<span class="string">'.'</span>时，s和p直接后移一位即可</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">具体代码如下，基本就是将伪码就行完善</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.size()&lt;=<span class="number">0</span>)<span class="keyword">return</span> s.size()&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> match=(s.size()&gt;<span class="number">0</span>&amp;&amp;(s[<span class="number">0</span>]==p[<span class="number">0</span>]||p[<span class="number">0</span>]==<span class="string">'.'</span>));</span><br><span class="line">        <span class="keyword">if</span>((p.size()&gt;<span class="number">1</span>)&amp;&amp;(p[<span class="number">1</span>]==<span class="string">'*'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>))||(match&amp;&amp;isMatch(s.substr(<span class="number">1</span>),p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> match&amp;&amp;isMatch(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">548</span> ms</span><br></pre></td></tr></table></figure>
<p>递归耗时严重，后续会增加其他方法，目前还在思考中。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 正则表达式匹配 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【科研笔记】CTeX的套件中MiKTeX版本太低，无法更新包的解决办法]]></title>
      <url>/2018/12/11/%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91-CTeX%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>当前CTeX套装中的MiKTeX过于陈旧，很多宏包已经无法自动更新了。因此，需要重新安装新版MiKTeX来解决问题。</p>
<h2 id="工具准备："><a href="#工具准备：" class="headerlink" title="工具准备："></a>工具准备：</h2><p>(1)CTeX套装： CTeX_2.9.2.164_Full.exe ，网址：www.ctex.org/CTeXDownload<br>务必选择Full版本</p>
<p>(2)下载最新版 MiKTeX：basic-miktex-2.9.6753-x64.exe ，网址<br><a href="https://miktex.org/" target="_blank" rel="noopener">MiKTeX</a></p>
<a id="more"></a>
<h2 id="开始安装："><a href="#开始安装：" class="headerlink" title="开始安装："></a>开始安装：</h2><p>(1)安装CTeX，在如图一步时，不要勾选MiKTeX，因为默认的版本过低，已经没法连接上了，所以自己手动安装最新版。剩下就一路Next即可。</p>
<p><img src="https://user-images.githubusercontent.com/35086262/49799794-c9517480-fd80-11e8-9ea2-c60de6233fc5.png" alt="image"></p>
<p>(2)安装下载好的最新版本的MikTeX：注意！！！在选择目录的时候，选择CTeX的安装目录，同时将MikTeX安装的文件夹的名字改为MiKTeX，如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/35086262/49799861-fb62d680-fd80-11e8-97e6-bff3cd621508.png" alt="image"></p>
<p>(3)安装完毕以后，进入如下Miktex的控制台，并更新包。<br><img src="https://user-images.githubusercontent.com/35086262/49800019-71ffd400-fd81-11e8-9804-ddaf4e4cdbb1.png" alt="image"></p>
<h2 id="最后注意"><a href="#最后注意" class="headerlink" title="最后注意"></a>最后注意</h2><p>PS：在编译时，可能出现报错或者无法生成pdf的情况，往往是因为包没有更新，所以进入Miktex的控制台更新包，然后再shift+ctrl+p再编译运行生成pdf一次就可以解决。</p>
]]></content>
      
        <categories>
            
            <category> 科研笔记 </category>
            
            <category> 论文部分 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CTeX </tag>
            
            <tag> MiKTeX </tag>
            
            <tag> windows api error 2 </tag>
            
            <tag> windows api error 3 </tag>
            
            <tag> MiKTeX包无法更新 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法作业1-右移数组]]></title>
      <url>/2018/11/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1-%E5%8F%B3%E7%A7%BB%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-右移数组"><a href="#题目-右移数组" class="headerlink" title="题目:右移数组"></a>题目:右移数组</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已知一个长度为 <span class="built_in">n</span> 的数组和一个正整数 k，并且最多只能使用一个用于交换数 组元素的附加空间单元，试设计算法得到原数组循环右移 k 次的结果并分析算法的时间复杂度。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>在自己尝试的过程中，发现了一个很有趣的规律，<br>例如</p>
<p>arr=1 2 3 4 5 n=5,k=2</p>
<p>显然右移两位以后的数组为</p>
<pre><code>4 5 1 2 3
</code></pre><p>而该数组的逆序为</p>
<pre><code>3 2 1 5 4
</code></pre><p>恰好是123 45子数组的逆序<br>由此，该算法就很容易了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nixu</span><span class="params">(<span class="keyword">char</span>* arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;<span class="comment">//arr为数组，n为数组长度，k为右移位数</span></span><br><span class="line">										 </span><br><span class="line">	<span class="keyword">char</span> tmp;</span><br><span class="line">	<span class="keyword">while</span> (start &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = arr[start];</span><br><span class="line">		arr[start] = arr[end];</span><br><span class="line">		arr[end] = tmp;</span><br><span class="line">		start++;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>, k = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数组长度:"</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">char</span> *arr = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数组:"</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; arr;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strlen</span>(arr) == n)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"请重新输入数组，因为数组长度不为n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入右移次数:"</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	nixu(arr, <span class="number">0</span>, n - k - <span class="number">1</span>);</span><br><span class="line">	nixu(arr, n - k, n - <span class="number">1</span>);</span><br><span class="line">	nixu(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; arr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 作业练习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 逆序数组 </tag>
            
            <tag> 右移数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法作业3-多米诺骨牌]]></title>
      <url>/2018/11/26/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-多米诺骨牌"><a href="#题目-多米诺骨牌" class="headerlink" title="题目:多米诺骨牌"></a>题目:多米诺骨牌</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现有 n 块 “多米诺骨牌” s1; s2; 。 。 。 ; sn 水平放成一排，每块骨牌 si 包含左右两 个部分，每个部分赋予一个非负整数值，如下图所示为包含 <span class="number">6</span> 块骨牌的序列。骨牌可做 <span class="number">180</span> 度旋转，使得原来在左边的值变到右边，而原来在右边的值移到左边，假设不论 si 如何</span><br><span class="line">旋转，L<span class="string">[i]</span> 总是存储 si 左边的值，R<span class="string">[i]</span> 总是存储 si 右边的值，W <span class="string">[i]</span> 用于存储 si 的状态： 当 L<span class="string">[i]</span> &lt;=R<span class="string">[i]</span> 时记为 <span class="number">0</span>，否则记为<span class="number">1</span>，试采用分治法设计算法</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>在实验过程中，很容易观察到，在骨牌首尾补充两张牌00，00，就可以讲问题分成左右两个部分，就可以分别求出MAX0,MAX1,然后比较两者的值较大者就是题目要求的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_duominuo</span><span class="params">(<span class="keyword">int</span>* L, <span class="keyword">int</span>* R, <span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>* w)</span> </span>&#123;<span class="comment">//这里的start end是骨牌的序号</span></span><br><span class="line">	<span class="comment">/*思路</span></span><br><span class="line"><span class="comment">	很容易观察到，在骨牌收尾补充两张牌00，00，就可以讲问题分成左右两个部分，就可以分别求出MAX0,MAX1,然后比较两者的值</span></span><br><span class="line"><span class="comment">	较大者就是题目要求的结果。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = <span class="number">0</span>,maxL1,maxR1,MAX1, maxL0, maxR0, MAX0, tmp;</span><br><span class="line">	<span class="keyword">if</span> (end - start == <span class="number">1</span>)<span class="comment">//此时证明只有两张牌，直接计算即可</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> R[start] * L[end];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (L[mid] &gt; R[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			w[mid] = <span class="number">1</span>;</span><br><span class="line">			maxL1=max_duominuo(L, R, start, mid, w);</span><br><span class="line">			maxR1=max_duominuo(L, R, mid, end, w);</span><br><span class="line">			MAX1 = maxL1 + maxR1;</span><br><span class="line">			tmp = L[mid];</span><br><span class="line">			L[mid] = R[mid];</span><br><span class="line">			R[mid] = tmp;</span><br><span class="line"></span><br><span class="line">			w[mid] = <span class="number">0</span>;</span><br><span class="line">			maxL0 = max_duominuo(L, R, start, mid, w);</span><br><span class="line">			maxR0 = max_duominuo(L, R, mid, end, w);</span><br><span class="line">			MAX0 = maxL0 + maxR0;</span><br><span class="line">			<span class="keyword">if</span> (MAX1 &gt; MAX0)</span><br><span class="line">			&#123;</span><br><span class="line">				w[mid] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> MAX1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				w[mid] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> MAX0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			w[mid] = <span class="number">0</span>;</span><br><span class="line">			maxL0 = max_duominuo(L, R, start, mid, w);</span><br><span class="line">			maxR0 = max_duominuo(L, R, mid, end, w);</span><br><span class="line">			MAX0 = maxL0 + maxR0;</span><br><span class="line">			tmp = L[mid];</span><br><span class="line">			L[mid] = R[mid];</span><br><span class="line">			R[mid] = tmp;</span><br><span class="line"></span><br><span class="line">			w[mid] = <span class="number">1</span>;</span><br><span class="line">			maxL1 = max_duominuo(L, R, start, mid, w);</span><br><span class="line">			maxR1 = max_duominuo(L, R, mid, end, w);</span><br><span class="line">			MAX1 = maxL1 + maxR1;</span><br><span class="line">			<span class="keyword">if</span> (MAX1 &gt; MAX0)</span><br><span class="line">			&#123;</span><br><span class="line">				w[mid] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> MAX1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				w[mid] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> MAX0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>,MAX=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入骨牌个数n="</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"骨牌过少，无法计算"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> *L = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> *R = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> *w = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入骨牌S"</span> &lt;&lt; i &lt;&lt; <span class="string">"的左骨牌数值: "</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; L[i];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入骨牌S"</span> &lt;&lt; i &lt;&lt; <span class="string">"的右骨牌数值: "</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; R[i];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (L[i] &lt;= R[i])</span><br><span class="line">		&#123;</span><br><span class="line">			w[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			w[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	R[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	L[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	L[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	R[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	MAX = max_duominuo(L,R,<span class="number">0</span>,n+<span class="number">1</span>,w);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"最大值为："</span> &lt;&lt; MAX&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"各个骨牌的状态为："</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; w[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> 作业练习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分治法 </tag>
            
            <tag> 多米诺骨牌 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（14）--最长公共前缀（简单题）]]></title>
      <url>/2018/11/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8814%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-最长公共前缀"><a href="#题目-最长公共前缀" class="headerlink" title="题目:最长公共前缀"></a>题目:最长公共前缀</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 <span class="string">""</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>很简单，不赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_speed_up= []()&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">1</span>)<span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;strs[<span class="number">0</span>].length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;strs.size())</span><br><span class="line">            &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">if</span>(strs[j][i]==strs[<span class="number">0</span>][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">            result=result+strs[<span class="number">0</span>][i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">4</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 最长公共前缀 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（13）--罗马数字转整数（简单题）]]></title>
      <url>/2018/11/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8813%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-罗马数字转整数"><a href="#题目-罗马数字转整数" class="headerlink" title="题目:罗马数字转整数"></a>题目:罗马数字转整数</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符： <span class="keyword">I</span>， V， X， L，<span class="keyword">C</span>，<span class="keyword">D</span> 和 M。</span><br><span class="line"></span><br><span class="line">字符          数值</span><br><span class="line"><span class="keyword">I</span>             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line"><span class="keyword">C</span>             <span class="number">100</span></span><br><span class="line"><span class="keyword">D</span>             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">例如， 罗马数字 <span class="number">2</span> 写做 II ，即为两个并列的 <span class="number">1</span>。<span class="number">12</span> 写做 XII ，即为 X + II 。 <span class="number">27</span> 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 <span class="number">4</span> 不写做 IIII，而是 IV。数字 <span class="number">1</span> 在数字 <span class="number">5</span> 的左边，所表示的数等于大数 <span class="number">5</span> 减小数 <span class="number">1</span> 得到的数值 <span class="number">4</span> 。同样地，数字 <span class="number">9</span> 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line"><span class="keyword">I</span> 可以放在 V (<span class="number">5</span>) 和 X (<span class="number">10</span>) 的左边，来表示 <span class="number">4</span> 和 <span class="number">9</span>。</span><br><span class="line">X 可以放在 L (<span class="number">50</span>) 和 <span class="keyword">C</span> (<span class="number">100</span>) 的左边，来表示 <span class="number">40</span> 和 <span class="number">90</span>。 </span><br><span class="line"><span class="keyword">C</span> 可以放在 <span class="keyword">D</span> (<span class="number">500</span>) 和 M (<span class="number">1000</span>) 的左边，来表示 <span class="number">400</span> 和 <span class="number">900</span>。</span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 <span class="number">1</span> 到 <span class="number">3999</span> 的范围内。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"III"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"IV"</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"IX"</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>很简单，不赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_speed_up= []()&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'I'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'V'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">4</span>;</span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'I'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'X'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">9</span>;</span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'I'</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">'X'</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">'V'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'V'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">5</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'X'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'L'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">40</span>;</span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'X'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'C'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">90</span>;</span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'X'</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">'L'</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">'C'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">10</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'L'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">50</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'C'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">400</span>;</span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'C'</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="string">'M'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">900</span>;</span><br><span class="line">                i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'C'</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">'D'</span>&amp;&amp;s[i+<span class="number">1</span>]!=<span class="string">'M'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">100</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">500</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">             <span class="keyword">if</span>(s[i]==<span class="string">'M'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+<span class="number">1000</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">40</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 罗马数字转整数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（12）--整数转罗马数字（中等题）]]></title>
      <url>/2018/11/19/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8812%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目:整数转罗马数字"></a>题目:整数转罗马数字</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">罗马数字包含以下七种字符： <span class="keyword">I</span>， V， X， L，<span class="keyword">C</span>，<span class="keyword">D</span> 和 M。</span><br><span class="line"></span><br><span class="line">字符          数值</span><br><span class="line"><span class="keyword">I</span>             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line"><span class="keyword">C</span>             <span class="number">100</span></span><br><span class="line"><span class="keyword">D</span>             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">例如， 罗马数字 <span class="number">2</span> 写做 II ，即为两个并列的 <span class="number">1</span>。<span class="number">12</span> 写做 XII ，即为 X + II 。 <span class="number">27</span> 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 <span class="number">4</span> 不写做 IIII，而是 IV。数字 <span class="number">1</span> 在数字 <span class="number">5</span> 的左边，所表示的数等于大数 <span class="number">5</span> 减小数 <span class="number">1</span> 得到的数值 <span class="number">4</span> 。同样地，数字 <span class="number">9</span> 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line"><span class="keyword">I</span> 可以放在 V (<span class="number">5</span>) 和 X (<span class="number">10</span>) 的左边，来表示 <span class="number">4</span> 和 <span class="number">9</span>。</span><br><span class="line">X 可以放在 L (<span class="number">50</span>) 和 <span class="keyword">C</span> (<span class="number">100</span>) 的左边，来表示 <span class="number">40</span> 和 <span class="number">90</span>。 </span><br><span class="line"><span class="keyword">C</span> 可以放在 <span class="keyword">D</span> (<span class="number">500</span>) 和 M (<span class="number">1000</span>) 的左边，来表示 <span class="number">400</span> 和 <span class="number">900</span>。</span><br><span class="line">给定一个整数，将其转为罗马数字。输入确保在 <span class="number">1</span> 到 <span class="number">3999</span> 的范围内。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">9</span></span><br><span class="line">输出: <span class="string">"IX"</span></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: L = <span class="number">50</span>, V = <span class="number">5</span>, III = <span class="number">3.</span></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>很简单，不赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> _ = []()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = num;</span><br><span class="line">		<span class="keyword">int</span> q = tmp / <span class="number">1000</span>;</span><br><span class="line">		tmp = tmp % <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">int</span> b = tmp / <span class="number">100</span>;</span><br><span class="line">		tmp = tmp % <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">int</span> s = tmp / <span class="number">10</span>;</span><br><span class="line">		tmp = tmp % <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> g = tmp;</span><br><span class="line">		<span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">if</span> (q != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (q &lt;= <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (q)</span><br><span class="line">				&#123;</span><br><span class="line">					result = result + <span class="string">'M'</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (b == <span class="number">9</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				result = result + <span class="string">"CM"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (b == <span class="number">4</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					result = result + <span class="string">"CD"</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (b &lt;= <span class="number">3</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">while</span> (b)</span><br><span class="line">						&#123;</span><br><span class="line">							result = result + <span class="string">'C'</span>;</span><br><span class="line">							b--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span><span class="comment">//500~800</span></span><br><span class="line">					&#123;</span><br><span class="line">						result = result + <span class="string">'D'</span>;</span><br><span class="line">						b = b - <span class="number">5</span>;</span><br><span class="line">						<span class="keyword">while</span> (b)</span><br><span class="line">						&#123;</span><br><span class="line">							result = result + <span class="string">'C'</span>;</span><br><span class="line">							b--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s == <span class="number">9</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				result = result + <span class="string">"XC"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (s == <span class="number">4</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					result = result + <span class="string">"XL"</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (s &lt;= <span class="number">3</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">while</span> (s)</span><br><span class="line">						&#123;</span><br><span class="line">							result = result + <span class="string">'X'</span>;</span><br><span class="line">							s--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span><span class="comment">//500~800</span></span><br><span class="line">					&#123;</span><br><span class="line">						result = result + <span class="string">'L'</span>;</span><br><span class="line">						s = s - <span class="number">5</span>;</span><br><span class="line">						<span class="keyword">while</span> (s)</span><br><span class="line">						&#123;</span><br><span class="line">							result = result + <span class="string">'X'</span>;</span><br><span class="line">							s--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (g != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">if</span> (g == <span class="number">9</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				result = result + <span class="string">"IX"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (g == <span class="number">4</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					result = result + <span class="string">"IV"</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (g &lt;= <span class="number">3</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">while</span> (g)</span><br><span class="line">						&#123;</span><br><span class="line">							result = result + <span class="string">'I'</span>;</span><br><span class="line">							g--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span><span class="comment">//500~800</span></span><br><span class="line">					&#123;</span><br><span class="line">						result = result + <span class="string">'V'</span>;</span><br><span class="line">						g = g - <span class="number">5</span>;</span><br><span class="line">						<span class="keyword">while</span> (g)</span><br><span class="line">						&#123;</span><br><span class="line">							result = result + <span class="string">'I'</span>;</span><br><span class="line">							g--;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">32</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 整数转罗马数字 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（10）--三数之和（中等题）]]></title>
      <url>/2018/10/26/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%8810%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-三数之和"><a href="#题目-三数之和" class="headerlink" title="题目:三数之和"></a>题目:三数之和</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = <span class="number">0</span> ？找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line">例如, 给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">思路有两种，一种是先排序，然后找到三元素，最后去重，难点是如何记录和去除重复的，此方法比较麻烦，所以放弃。</span><br><span class="line">第二种就是,先排序，然后固定一个值，接着用双指针的思想去找到相加为<span class="number">0</span>的三元素，期间，遇到有重复的跳过即可。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>)<span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">0</span>;mid&lt;=nums.size()<span class="number">-1</span>;mid++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;<span class="number">0</span>&amp;&amp;nums[mid]==nums[mid<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l=mid+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[mid]+nums[r]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(l==mid+<span class="number">1</span>||r==nums.size()<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                        l++;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[l]==nums[l<span class="number">-1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            l++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[r]==nums[r+<span class="number">1</span>])</span><br><span class="line">                            &#123;</span><br><span class="line">                                r--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                                l++;</span><br><span class="line">                                r--;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[l]+nums[mid]+nums[r]&lt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">140</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 三数之和 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（9）--回文数（简单题）]]></title>
      <url>/2018/10/26/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%889%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-回文数"><a href="#题目-回文数" class="headerlink" title="题目:回文数"></a>题目:回文数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">示例1:</span></span><br><span class="line"><span class="section">输入: 121</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例2:</span></span><br><span class="line"><span class="section">输入: -121</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例3:</span></span><br><span class="line"><span class="section">输入: 10</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span></span><br><span class="line"></span><br><span class="line"><span class="section">进阶:</span></span><br><span class="line"></span><br><span class="line">你能不将整数转为字符串来解决这个问题吗？</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>很简单，不赘述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> _ = []()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">10</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">0</span>,flag=x;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            y=y*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y==flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">56</span>  ms</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回文数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（8）--字符串转整数 (atoi)（中等题）]]></title>
      <url>/2018/10/23/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%888%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-字符串转整数-atoi"><a href="#题目-字符串转整数-atoi" class="headerlink" title="题目:字符串转整数 (atoi)"></a>题目:字符串转整数 (atoi)</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实现 atoi，将字符串转为整数。</span><br><span class="line"></span><br><span class="line">该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line"></span><br><span class="line">字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。</span><br><span class="line"></span><br><span class="line">当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。</span><br><span class="line"></span><br><span class="line">若函数不能执行有效的转换，返回 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储 <span class="number">32</span> 位有符号整数，其数值范围是</span><br></pre></td></tr></table></figure>
<p> [$−2^{31}$,  $2^{31} − 1$]<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果数值超过可表示的范围，则返回  INT_MAX (<span class="number">231</span> − <span class="number">1</span>) 或 INT_MIN (−<span class="number">231</span>) 。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">示例1:</span></span><br><span class="line"><span class="section">输入: "42"</span></span><br><span class="line"><span class="section">输出: 42</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例2:</span></span><br><span class="line"><span class="section">输入: "   -42"</span></span><br><span class="line"><span class="section">输出: -42</span></span><br><span class="line"><span class="section">解释: 第一个非空白字符为 '-', 它是一个负号。</span></span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line"></span><br><span class="line"><span class="section">示例3:</span></span><br><span class="line"><span class="section">输入: "4193 with words"</span></span><br><span class="line"><span class="section">输出: 4193</span></span><br><span class="line"><span class="section">解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例4:</span></span><br><span class="line"><span class="section">输入: "words and 987"</span></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"><span class="section">解释: 第一个非空字符是 'w', 但它不是数字或正、负号。</span></span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">     </span><br><span class="line"><span class="section">示例5:</span></span><br><span class="line"><span class="section">输入: "-91283472332"</span></span><br><span class="line"><span class="section">输出: -2147483648</span></span><br><span class="line"><span class="section">解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>只要注意细节就可以了很简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> x=[]&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'+'</span>)flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'-'</span>)flag = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i]-<span class="string">'0'</span>&lt;<span class="number">10</span>&amp;&amp;str[i]-<span class="string">'0'</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        result=result*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                      </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">if</span>(str[i]-<span class="string">'0'</span>&lt;<span class="number">10</span>&amp;&amp;str[i]-<span class="string">'0'</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                    result=result*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">if</span>(flag*result&gt;INT_MAX)&#123;<span class="keyword">return</span> INT_MAX;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag*result&lt;INT_MIN)&#123;<span class="keyword">return</span> INT_MIN;&#125;</span><br><span class="line">                    </span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result!=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag*result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">20</span>  ms</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串转整数 </tag>
            
            <tag> atoi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（7）--反转整数（简单题）]]></title>
      <url>/2018/10/22/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%887%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-反转整数"><a href="#题目-反转整数" class="headerlink" title="题目:反转整数"></a>题目:反转整数</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个 <span class="number">32</span> 位有符号整数，将整数中的数字进行反转。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">示例1:</span></span><br><span class="line"><span class="section">输入: 123</span></span><br><span class="line"><span class="section">输出: 321</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例2:</span></span><br><span class="line"><span class="section">输入: -123</span></span><br><span class="line"><span class="section">输出: -321</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例3:</span></span><br><span class="line"><span class="section">输入: 120</span></span><br><span class="line"><span class="section">输出: 21</span></span><br><span class="line"></span><br><span class="line"><span class="section">注意:</span></span><br><span class="line"></span><br><span class="line">假设我们的环境只能存储 32 位有符号整数，其数值范围是</span><br></pre></td></tr></table></figure>
<p> [$−2^{31}$,  $2^{31} − 1$]。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据这个假设，如果反转后的整数溢出，则返回 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>注意使用res*=10就可以了，过于简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> x=[]&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            res=res*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>||res&lt;-<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">执行用时：<span class="number">4</span>  ms</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 反转整数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（6）--Z字形变换（中等题）]]></title>
      <url>/2018/10/22/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%886%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每天属于自己的时间，就是慢慢的刷题的时候，啥也不用想，沉浸在写出最佳程序的过程中，沉浸在自己阅读大牛代码，提升自我的过程中，那种满足感，真的很让人享受&lt;.&gt;</p>
<h2 id="题目-Z字形变换"><a href="#题目-Z字形变换" class="headerlink" title="题目:Z字形变换"></a>题目:Z字形变换</h2><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将字符串 <span class="string">"PAYPALISHIRING"</span>以<span class="keyword">Z</span>字形排列成给定的行数：</span><br><span class="line"><span class="keyword">P</span>   A   H   N</span><br><span class="line">A <span class="keyword">P</span> L S I I G</span><br><span class="line"><span class="keyword">Y</span>   I   <span class="keyword">R</span></span><br><span class="line"></span><br><span class="line">之后从左往右，逐行读取字符：<span class="string">"PAHNAPLSIIGYIR"</span>实现一个将字符串进行指定行数变换的函数:</span><br><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span>:</span><br><span class="line">输入: s = <span class="string">"PAYPALISHIRING"</span>, numRows = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"PAHNAPLSIIGYIR"</span></span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>:</span><br><span class="line">输入: s = <span class="string">"PAYPALISHIRING"</span>, numRows = <span class="number">4</span></span><br><span class="line">输出: <span class="string">"PINALSIGYAHRPI"</span></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">P     <span class="keyword">I</span>    <span class="keyword">N</span></span><br><span class="line">A   L S  <span class="keyword">I</span> G</span><br><span class="line">Y A   H R</span><br><span class="line">P     <span class="keyword">I</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>思路很简单，就是从左到右按照行数依次存入，就是按照题意的规律存。通过观察，可以发现，先存第一行，然后第二行只是第一行的每个数的左右两个字符依次存取，第三行是第一行每个数的左右间隔一个数的依次存取…..<br>而第一行的规矩就是2（numRows-2）+2为两个字符之间的距离。第一行第一个字符，可以看做是第零行第一个字符的右下第一个字符，所以要先s[j+1],然后再存第零行第二个字符左下的字符所以是s[j+row0-i]i为行数从0开始计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numRows&lt;=<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row0=<span class="number">2</span>*numRows<span class="number">-2</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j+i&lt;n;j=j+row0)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=s[j+i];</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows<span class="number">-1</span>&amp;&amp;j+row0-i&lt;n)</span><br><span class="line">                    res+=s[j+row0-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">28</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Z字形变换 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（5）--最长回文子串（中等题）]]></title>
      <url>/2018/10/15/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%885%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>方法一耗时很长但是思路容易理解，还要接着想其他更好的方法呀，加油。</p>
<h2 id="题目-最长回文子串"><a href="#题目-最长回文子串" class="headerlink" title="题目:最长回文子串"></a>题目:最长回文子串</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串s，找到s中最长的回文子串。你可以假设 s 的最大长度为<span class="number">1000</span>。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">示例1:</span></span><br><span class="line"><span class="section">输入: "babad"</span></span><br><span class="line"><span class="section">输出: "bab"</span></span><br><span class="line"><span class="section">注意: "aba"也是一个有效答案。</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例2:</span></span><br><span class="line"><span class="section">输入: "cbbd"</span></span><br><span class="line"><span class="section">输出: "bb"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>从头到尾遍历字符串s，当前后有字母相同时，证明有可能这两个字母间的串为最长回文串，所以，判断该串是否是回文串即可，若是则输出成新串new_s即可。<br>而判断是否是回文串也很简单，一样的思路，如果遍历字符串，如果一直头尾相等，那么该串就是回文串了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m,n,max_length=<span class="number">0</span>,m1,n1;</span><br><span class="line">        <span class="built_in">string</span> new_s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(m=<span class="number">0</span>,n=s.size()<span class="number">-1</span>;m&lt;s.size();n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[m]==s[n])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(is_huiwenstring(s,m+<span class="number">1</span>,n<span class="number">-1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(n-m+<span class="number">1</span>&gt;max_length)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max_length=n-m+<span class="number">1</span>;</span><br><span class="line">                        new_s=<span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">for</span>(m1=m,n1=n;m1&lt;=n1;m1++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            new_s=new_s+s[m1];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(m==n)</span><br><span class="line">           &#123;</span><br><span class="line">               m++;</span><br><span class="line">               n=s.size();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_huiwenstring</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> A,<span class="keyword">int</span> B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((B-A+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=A,j=B;i&lt;(B+A+<span class="number">1</span>)/<span class="number">2</span>;i++,j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=A,j=B;i&lt;(B+A)/<span class="number">2</span>;i++,j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]!=s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">执行用时：<span class="number">1328</span> ms</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>这个方法就是找到最长子串的中心，然后想外部扩展，使用了i、j的双游标。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> __ = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> center=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,max_length=<span class="number">0</span>,place=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(center&lt;s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            left=center;</span><br><span class="line">            right=center;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;s.size()&amp;&amp;s[right]==s[right+<span class="number">1</span>])<span class="comment">//右边的游标先从中心出发，这样就可以保证，无论回文子串是偶数长度还是奇数长度，left和right都可以分开。简单来说，因为在偶数的情况下，中心的两个字符必然相等，该操作等同于产生了左右两个中心，一个是原地不动的left_center，一个是r++了以后的right_center</span></span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            center=right+<span class="number">1</span>;<span class="comment">//更新中心的位置</span></span><br><span class="line">            <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.size()&amp;&amp;s[left]==s[right])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_length&lt;right-left+<span class="number">1</span><span class="number">-2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                max_length=right-left+<span class="number">1</span><span class="number">-2</span>;</span><br><span class="line">                place=left+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(place,max_length);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">执行用时：<span class="number">4</span> ms</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 最长回文子串 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（4）--两个排序数组的中位数（困难题）]]></title>
      <url>/2018/10/12/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%884%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>10分钟，一次AC并且超过了95%，还不错^.^</p>
<h2 id="题目-两个排序数组的中位数"><a href="#题目-两个排序数组的中位数" class="headerlink" title="题目:两个排序数组的中位数"></a>题目:两个排序数组的中位数</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定两个大小为 m 和 <span class="built_in">n</span> 的有序数组 nums1 和 nums2 。</span><br><span class="line">请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(<span class="built_in">log</span> (m+<span class="built_in">n</span>)) 。你可以假设 nums1 和 nums2 不同时为空。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">示例1:</span></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">中位数是 2.0</span><br><span class="line"></span><br><span class="line"><span class="section">示例2:</span></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>这题的思路很简单，当两个数组，有一个已经填充到arr完毕的时候，另外一组直接“贴”在最后即可，然后在取arr的中位数，这题过于简单了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizeall=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        sizeall=nums1.size()+nums2.size();</span><br><span class="line">        <span class="keyword">int</span> arr[sizeall]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">           &#123;</span><br><span class="line">               arr[k]=nums1[i];</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               arr[k]=nums2[j];</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;nums1.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;nums1.size())</span><br><span class="line">            &#123;</span><br><span class="line">              arr[k]=nums1[i];</span><br><span class="line">              i++;</span><br><span class="line">              k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;nums2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;nums2.size())</span><br><span class="line">            &#123;</span><br><span class="line">              arr[k]=nums2[j];</span><br><span class="line">              j++;</span><br><span class="line">              k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sizeall)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (arr[sizeall/<span class="number">2</span>]+arr[(sizeall<span class="number">-1</span>)/<span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)arr[sizeall/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> io_sync_off = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// turn off sync</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// untie in/out streams</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line">执行用时：<span class="number">28</span> ms</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双游标 </tag>
            
            <tag> 两个排序数组的中位数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（3）--无重复字符的最长子串（中等题）]]></title>
      <url>/2018/10/12/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>没有简单的题目，或者说，再简单的题目，只要追求极致，都会要花心思。好好加油吧&lt;-&gt;</p>
<h2 id="题目-无重复字符的最长子串"><a href="#题目-无重复字符的最长子串" class="headerlink" title="题目:无重复字符的最长子串"></a>题目:无重复字符的最长子串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，找出不含有重复字符的最长子串的长度。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">示例1:</span></span><br><span class="line"><span class="section">输入: "abcabcbb"</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 无重复字符的最长子串是 "abc"，其长度为 3。</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例2:</span></span><br><span class="line"><span class="section">输入: "bbbbb"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 无重复字符的最长子串是 "b"，其长度为 1。</span></span><br><span class="line"></span><br><span class="line"><span class="section">示例3:</span></span><br><span class="line"><span class="section">输入: "pwwkew"</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 无重复字符的最长子串是 "wke"，其长度为 3。</span></span><br><span class="line">     请注意，答案必须是一个子串，<span class="string">"pwke"</span> 是一个子序列 而不是子串。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>首先，因为键盘可输入字符为128个，所以先int一个128的数组并且初始化为0，用此数组来记录是否重复，然后在循环中判断，如果为0，那么就累加长度，并且记录最大长度。然后在不为0的时候，再初始化数组为0。很明显，这个初始化很耗时，所以又想了下面的方法。</p>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>双游标，i,j两者之差j-i+1就是子串的长度，然后数组记录的不再是字符是否重复了，而是记录最后一个字母在s串中的位置。细节在于，i在字母重复的时候，会变成字母所在的位置，判断的时候的细节在于，重复的字母的位置如果在i的左边，则表示不会在i到j的子串中重复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max_length=<span class="number">0</span>,i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;s.size();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[(<span class="keyword">int</span>)s[j]]==<span class="number">0</span>||arr[(<span class="keyword">int</span>)s[j]]<span class="number">-1</span>&lt;i)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[(<span class="keyword">int</span>)s[j]]=j+<span class="number">1</span>;<span class="comment">//保持字符 s[j] 在s中的位置+1 比如0位 ，最后保存的是1</span></span><br><span class="line">                <span class="comment">//length++;</span></span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;max_length)</span><br><span class="line">                &#123;</span><br><span class="line">                    max_length=j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[(<span class="keyword">int</span>)s[j]]<span class="number">-1</span>&lt;i)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i=arr[(<span class="keyword">int</span>)s[j]];</span><br><span class="line">                    arr[(<span class="keyword">int</span>)s[j]]=j+<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">/*if(j-i&gt;max_length)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        max_length=j-i+1;</span></span><br><span class="line"><span class="comment">                    &#125;*/</span></span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> _____ = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;();</span><br><span class="line">执行用时：<span class="number">12</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 无重复字符的最长子串 </tag>
            
            <tag> 双游标 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（2）--两数相加（中等题）]]></title>
      <url>/2018/10/11/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>没有简单的题目，或者说，再简单的题目，只要追求极致，都会要花心思。好好加油吧&lt;-&gt;</p>
<h2 id="题目-两数之和"><a href="#题目-两数之和" class="headerlink" title="题目:两数之和"></a>题目:两数之和</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</span><br><span class="line">你可以假设除了数字<span class="number">0</span>之外，这两个数字都不会以零开头。</span><br></pre></td></tr></table></figure>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><pre><code>1、判断了l1和l2是否存在，如果存在，就可以累加，然后将累加后产生的进位存起来
2、要考虑到两个表长度不一样，所以，在其中一个表已经空了以后，就要将进位的值消耗掉，如果两个表都为空了以后，进位还不为0，则最后一位必为1
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">     ListNode* result=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//初始化第一个至为0</span></span><br><span class="line">       </span><br><span class="line">     ListNode* tmp=result;<span class="comment">//使用tmp记录每次计算了以后的余数，比如6+5=11 tmp=1</span></span><br><span class="line">     <span class="keyword">int</span> sum_jinwei=<span class="number">0</span>;<span class="comment">//这个变量起到两个作用，一是用作l1与l2的相加的值sum，二是作为jinwei的值例如8+7=17，jinwei=1</span></span><br><span class="line">    <span class="keyword">while</span>(l1||l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            sum_jinwei=sum_jinwei+l1-&gt;val;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            sum_jinwei=sum_jinwei+l2-&gt;val;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;next=<span class="keyword">new</span> ListNode(sum_jinwei%<span class="number">10</span>);<span class="comment">//tmp-&gt;next就记录余数，也就是最后显示的值</span></span><br><span class="line">        sum_jinwei=sum_jinwei/<span class="number">10</span>;<span class="comment">//此时sum_jinwei就起到了携带进位的任务</span></span><br><span class="line">        tmp=tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum_jinwei==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);<span class="comment">//当sum_jinwei==1的时候就证明最高位必然为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">执行用时：<span class="number">24</span> ms</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 两数相加 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode刷题之旅（1）--两数之和（简单题）]]></title>
      <url>/2018/10/10/LeetCode%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>算法，永远是检验一个程序员的能力大小的重要指标，也是提升自身能力所必备的专业技能。所以现在就要动手练习，同时，可以对C++有更加深刻的认识和理解。而LeetCode上可以和各位算法爱好者一起学习，是一个很好的平台。好好加油吧&lt;-&gt;</p>
<h2 id="题目-两数之和"><a href="#题目-两数之和" class="headerlink" title="题目:两数之和"></a>题目:两数之和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</span><br><span class="line">你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br></pre></td></tr></table></figure>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = <span class="string">[2, 7, 11, 15]</span>, target = <span class="number">9</span></span><br><span class="line">因为 nums<span class="string">[0]</span> + nums<span class="string">[1]</span> = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 <span class="string">[0, 1]</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>使用两个for循环，从头到尾遍历nums，同时对比即可，这个方法很简单，但是时间复杂度为<script type="math/tex">O(n^2)</script>,实际的执行时间也到了180ms左右，显然不太好（代码在下面的注释里）。</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用以空间换时间的方法，那也就是哈希表了，这里的思路就是使用关联容器中的无序集合类型——unordered_map。<br>在C++11中关联容器支持高效的关键字查找和访问。在此题中，使用map的思路就是，首先看是否能够find到target-nums[i]的值，如果能找到，就说明在nums中存在两个数字满足题意，那么直接返回两者的对应下标即可，也就是i，和r[key]；如果找不到target-nums[i]，那么就初始化map的键值对，这里可能乍一看怎么没有初始化map，其实不然，每一次没有找到就会初始化一个值，这样效率最高。例如：实例中的例子，一开始的key=9-2=7,map此时为空，所以找不到，那么初始化r[2]=0,然后再循环key=9-7=2，刚好有2，然后就可以返回下标i=1,r[2]=0，完毕。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;r;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(r.find(key)!=r.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;i,r[key]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            r[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; result;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; nums.size(); i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		for (int j = i + 1; j &lt; nums.size(); j++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			if (nums[i] + nums[j] == target)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				result.push_back(i);</span></span><br><span class="line"><span class="comment">				result.push_back(j);</span></span><br><span class="line"><span class="comment">				return result;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">执行用时：<span class="number">8</span> ms</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
            <category> LeetCode刷题之旅 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 两数之和 </tag>
            
            <tag> unordered_map </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》尾声（9）]]></title>
      <url>/2018/03/15/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%B0%BE%E5%A3%B0%EF%BC%889%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="让mkfs-只执行一次"><a href="#让mkfs-只执行一次" class="headerlink" title="让mkfs()只执行一次"></a>让mkfs()只执行一次</h1><p>目前我们的操作系统每次启动都是“全新的”，因为每一次init_fs()都会调用mkfs()刷新硬盘，每次启动时可以保证文件系统是一样，但它也存在明细的坏处，那就是上次建立的文件到下一次启动时就不见了。下面就来改变现状：<br><a id="more"></a><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PRIVATE void init_fs()</span><br><span class="line">&#123;</span><br><span class="line">	int i<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* f_desc_table[] */</span></span><br><span class="line">	for (i = <span class="number">0</span><span class="comment">; i &lt; NR_FILE_DESC; i++)</span></span><br><span class="line">		memset(&amp;f_desc_table[i], <span class="number">0</span>, sizeof(struct file_desc))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* inode_table[] */</span></span><br><span class="line">	for (i = <span class="number">0</span><span class="comment">; i &lt; NR_INODE; i++)</span></span><br><span class="line">		memset(&amp;inode_table[i], <span class="number">0</span>, sizeof(struct inode))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* super_block[] */</span></span><br><span class="line">	struct super_block * <span class="keyword">sb </span>= super_block<span class="comment">;</span></span><br><span class="line">	for (<span class="comment">; sb &lt; &amp;super_block[NR_SUPER_BLOCK]; sb++)</span></span><br><span class="line">		<span class="keyword">sb-&gt;sb_dev </span>= NO_DEV<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* open the device: hard disk */</span></span><br><span class="line">	MESSAGE driver_msg<span class="comment">;</span></span><br><span class="line">	driver_msg.type = DEV_OPEN<span class="comment">;</span></span><br><span class="line">	driver_msg.DEVICE = MINOR(ROOT_DEV)<span class="comment">;</span></span><br><span class="line">	assert(dd_map[MAJOR(ROOT_DEV)].driver_nr != INVALID_DRIVER)<span class="comment">;</span></span><br><span class="line">	send_recv(<span class="keyword">BOTH, </span>dd_map[MAJOR(ROOT_DEV)].driver_nr, &amp;driver_msg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read the super block of ROOT DEVICE */</span></span><br><span class="line">	RD_SECT(ROOT_DEV, <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sb </span>= (struct super_block *)fsbuf<span class="comment">;</span></span><br><span class="line">	if (<span class="keyword">sb-&gt;magic </span>!= MAGIC_V1) &#123;</span><br><span class="line">		printl(<span class="string">"&#123;FS&#125; mkfs\n"</span>)<span class="comment">;</span></span><br><span class="line">		mkfs()<span class="comment">; /* make FS */</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要每次先读取超级块，如果发现魔数，则认为分区已经操作系统，否则调用mkfs()。<br>然后在untar()上留下记号，让它不再一股脑的解压了。<br>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/fBCFE49ffG.png?imageslim" alt="mark"></p>
<h1 id="从硬盘引导"><a href="#从硬盘引导" class="headerlink" title="从硬盘引导"></a>从硬盘引导</h1><p>前面都是从软盘引导的，现在我们从硬盘引导，先看看软盘引导的过程：</p>
<ol>
<li>BIOS将引导扇区读入内存0000：7c00处</li>
<li>跳转到0000:7c00处开始执行引导代码</li>
<li>引导代码从软盘中找到loader.bin，并将其读入内存</li>
<li>跳转到loader.bin开始执行</li>
<li>loader.bin从软盘中找到kernel.bin，并将其读入内存</li>
<li>跳转到kernel.bin开始执行，到此可认为启动过程结束</li>
<li>系统运行<br>硬盘启动和软盘的启动的区别在于第一步，BIOS到底是读谁，由CMOS设置决定，通常可以找到一个叫做Boot Sequence的选项，从中选择首选启动设备。在第3步和第5步中，对于软盘启动，代码将在软盘中寻找loader.bin和kernel.bin，对应硬盘启动，我们需要让引导扇区代码从硬盘中寻找loader.bin和kernel.bin。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/gA13hbGhjF.png?imageslim" alt="mark"><h1 id="grub"><a href="#grub" class="headerlink" title="grub"></a>grub</h1>将引导扇区安装到我们的操作系统分区的引导扇区，而不是整块硬盘的引导扇区，这样操作系统就可以和硬盘上其他操作系统和平共处了。只需要安装一个grub就可以了<h1 id="将OS安装到真实的计算机"><a href="#将OS安装到真实的计算机" class="headerlink" title="将OS安装到真实的计算机"></a>将OS安装到真实的计算机</h1></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 硬盘启动 </tag>
            
            <tag> grub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》内存管理（8）]]></title>
      <url>/2018/03/14/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%888%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><h2 id="认识fork"><a href="#认识fork" class="headerlink" title="认识fork"></a>认识fork</h2><p>生成一个子进程的系统调用被成为fork()，操作系统接到一个fork请求后，会将调用者复制一份，这时就会有两个一模一样的进程同时进行。其中子进程是从父进程得到数据、堆栈以及代码而来的。<br>我们最先要解决的问题是，谁作为最开始的父进程？参考Linux以及Minix可以知道是init进程，所以我们先写出Init进程：<br><a id="more"></a><br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd_stdin  = <span class="keyword">open</span>(<span class="string">"/dev_tty0"</span>, O_RDWR);</span><br><span class="line">	assert(fd_stdin  == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> fd_stdout = <span class="keyword">open</span>(<span class="string">"/dev_tty0"</span>, O_RDWR);</span><br><span class="line">	assert(fd_stdout == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">printf</span>(<span class="string">"Init() is running ...\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = <span class="keyword">fork</span>();</span><br><span class="line">	<span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="regexp">/* parent process */</span></span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"parent is running, child pid:%d\n"</span>, pid);</span><br><span class="line">		spin(<span class="string">"parent"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;	<span class="regexp">/* child process */</span></span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"child is running, pid:%d\n"</span>, getpid());</span><br><span class="line">		spin(<span class="string">"child"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到其中调用了即将实现的fork()，而且判定了返回值。如果返回0则表明自己是子进程，否则返回的是子进程的pid并表明自己是父进程。<br>然后我们要增加MM进程，它将负责从用户进程接受消息。<br>下图是一个进程涉及的所有数据结构以及相互联系：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180314/bBjE312HLI.png?imageslim" alt="mark"></p>
<h2 id="fork前要做好的工作"><a href="#fork前要做好的工作" class="headerlink" title="fork前要做好的工作"></a>fork前要做好的工作</h2><ul>
<li>在proc_table[]中预留出一些空白项，供新进程使用</li>
<li>在proc_table[]中的每一个进程表项中的idt_sel项都设定好</li>
<li>将进程所需的GDT表项都初始化好<h2 id="fork-库函数"><a href="#fork-库函数" class="headerlink" title="fork()库函数"></a>fork()库函数</h2><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUBLIC</span> <span class="built_in">int</span> fork()</span><br><span class="line">&#123;</span><br><span class="line">	MESSAGE msg;</span><br><span class="line">	msg.<span class="keyword">type</span> = FORK;</span><br><span class="line"></span><br><span class="line">	send_recv(BOTH, TASK_MM, &amp;msg);</span><br><span class="line">	<span class="keyword">assert</span>(msg.<span class="keyword">type</span> == SYSCALL_RET);</span><br><span class="line">	<span class="keyword">assert</span>(msg.RETVAL == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg.PID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="MM"><a href="#MM" class="headerlink" title="MM"></a>MM</h2><p>和文件管理进程一样，MM要有一个主消息循环，如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void task_mm()</span><br><span class="line">&#123;</span><br><span class="line">	init_mm()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	while (<span class="number">1</span>) &#123;</span><br><span class="line">		send_recv(RECEIVE, ANY, &amp;mm_msg)<span class="comment">;</span></span><br><span class="line">		int src = mm_msg.source<span class="comment">;</span></span><br><span class="line">		int reply = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">		int msgtype = mm_msg.type<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch </span>(msgtype) &#123;</span><br><span class="line">		case FORK:</span><br><span class="line">			mm_msg.RETVAL = do_fork()<span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	case EXIT:</span><br><span class="line">			do_exit(mm_msg.STATUS)<span class="comment">;</span></span><br><span class="line">			reply = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	<span class="comment">/* case EXEC: */</span></span><br><span class="line">		<span class="comment">/* 	mm_msg.RETVAL = do_exec(); */</span></span><br><span class="line">		<span class="comment">/* 	break; */</span></span><br><span class="line">		case <span class="keyword">WAIT:</span></span><br><span class="line"><span class="keyword">	</span>		do_wait()<span class="comment">;</span></span><br><span class="line">			reply = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	default:</span><br><span class="line">			dump_msg(<span class="string">"MM::unknown msg"</span>, &amp;mm_msg)<span class="comment">;</span></span><br><span class="line">			assert(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	&#125;</span><br><span class="line"></span><br><span class="line">		if (reply) &#123;</span><br><span class="line">			mm_msg.type = <span class="keyword">SYSCALL_RET;</span></span><br><span class="line"><span class="keyword">	</span>		send_recv(SEND, src, &amp;mm_msg)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当MM接到FORK消息后，调用do_fork()来处理。在内存的分配上，我们采用固定内存的方式，每个内存块大小为1MB。<br>fork()系统调用的结果余下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/55BCHelB6B.png?imageslim" alt="mark"></p>
<h1 id="exit和wait"><a href="#exit和wait" class="headerlink" title="exit和wait"></a>exit和wait</h1><p>生成子进程最重要的是fork()，而进程的消亡则是用到系统调用exit()。<br>而系统调用wait()是父进程得到返回值的方法，用该系统调用挂起，等子进程退出时，wait()调用方结束，并且父进程因此得带返回值。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = <span class="keyword">fork</span>();</span><br><span class="line">	<span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="regexp">/* parent process */</span></span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"parent is running, child pid:%d\n"</span>, pid);</span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">s</span>;</span><br><span class="line">		<span class="keyword">int</span> child = <span class="keyword">wait</span>(&amp;<span class="keyword">s</span>);</span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"child (%d) exited with status: %d.\n"</span>, child, <span class="keyword">s</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;	<span class="regexp">/* child process */</span></span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"child is running, pid:%d\n"</span>, getpid());</span><br><span class="line">		<span class="keyword">exit</span>(<span class="number">123</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>和fork()类似，上述两个系统调用同样是发送消息给MM，它们发送的消息分别是EXIT和WAIT。并由MMM中对应的消息函数进行处理。<br>do_exit/do_wait和msg_send/msg_receive这两对函数是类似的例如，假设进程P有子进程。而A调用exit()，那么MM会：</p>
<ol>
<li>告诉FS：A退出，请做出相应处理</li>
<li>释放A占用的内存</li>
<li>判断P是否正在WAITING</li>
<li>遍历proc_table[]<br>如果P调用wait()，那么MM将会：</li>
<li>遍历proc_table[]。</li>
<li>如果P的子进程没有一个在HANGING，则设P的WITING位</li>
<li>如果P没有子进程，则向P发送消息，消息携带一个表示出错的返回值。<br>完成了这以后，子进程的产生和消亡都有了，运行一下，结果如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/gdb7emi5ck.png?imageslim" alt="mark"><h1 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h1><h2 id="认识exec"><a href="#认识exec" class="headerlink" title="认识exec"></a>认识exec</h2>exec的语义很简单，它将当前的进程映像替换成另一个。也就是说我们可以从硬盘上读取另一个可执行的文件，用它替换掉刚刚被fork出来的子进程，于是被替换的子进程就成为了新进程。<br>下面的exec()的代码：<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = <span class="keyword">fork</span>();</span><br><span class="line">	<span class="keyword">if</span> (pid != <span class="number">0</span>) &#123; <span class="regexp">/* parent process */</span></span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"parent is running, child pid:%d\n"</span>, pid);</span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">s</span>;</span><br><span class="line">		<span class="keyword">int</span> child = <span class="keyword">wait</span>(&amp;<span class="keyword">s</span>);</span><br><span class="line">		<span class="keyword">printf</span>(<span class="string">"child (%d) exited with status: %d.\n"</span>, child, <span class="keyword">s</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;	<span class="regexp">/* child process */</span></span><br><span class="line">		execl(<span class="string">"/echo"</span>, <span class="string">"echo"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="为自己的操作系统编写应用程序"><a href="#为自己的操作系统编写应用程序" class="headerlink" title="为自己的操作系统编写应用程序"></a>为自己的操作系统编写应用程序</h2><p>例如Linux中的echo，它和操作系统的接口是系统调用。本质上，一个应用程序只能调用两种东西：属于自己的函数，以及中断。写一个echo最笨的方法就是将send_recv()、printf()、write()等所有用到的系统调用的代码都复制到源文件中，然后编译下。而更好的做法是制作一个类似C运行时库的东西，我们把之前已经写好的应用程序可以使用的库函数单独链接成一个文件，每次写应用程序时的时候直接链接起来就好了。<br>到目前位置，可以被用来链接成库的文件及其包含的主要函数有这些：</p>
<ul>
<li>真正的系统调用：sendrec和printx:lib/syscall.asm</li>
<li>字符串操作：memcpy、memset、strcpy、strlen：lib/string.asm</li>
<li>FS的接口：lib/open.c lib/read.c lib/write.c lib/close.c lib/unlink.c</li>
<li>MM的接口：lib/fork.c lib/exit.c lib/wait.c</li>
<li>SYS的接口：lib/getpid.c </li>
<li>其他：lib/misc.c lib/vsprintf.c lib/printf.c<br>把这些函数单独链接成一个库，起名为orangescrt.a表明这是我们的C运行时库.<br>现在先写一个最简单的echo：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s%s"</span>, i == <span class="number">1</span> ? <span class="string">""</span> : <span class="string">" "</span>, argv[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译链接：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -I ../<span class="keyword">include</span>/ -c -fno-builtin -Wall -o echo.o echo.c</span><br><span class="line">nasm -I ../<span class="keyword">include</span>/ -f elf -o start.o start.<span class="keyword">asm</span></span><br><span class="line">ld -Ttext <span class="number">0x1000</span> -o echo echo.o start.o ../<span class="class"><span class="keyword">lib</span>/<span class="title">orangescrt</span>.<span class="title">a</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="安装应用程序"><a href="#安装应用程序" class="headerlink" title="安装应用程序"></a>安装应用程序</h2><p>安装程序到我们的文件系统中，需要做以下工作：</p>
<ul>
<li>编程应用程序，并编译链接</li>
<li>将链接好的应用程序打成一个tar包：inst.tar</li>
<li>将inst.tar用工具dd写入磁盘的某段特定扇区</li>
<li>启动系统，这时mkfs()会在文件系统中建立一个新文件cmd.tar，它的inode中的i_start_sect成员会被设为X</li>
<li>在某个进程中将cmd.tar解包，将其中包含的文件存入文件系统。<br>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/b5I3HDgdef.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/C14lLf63fC.png?imageslim" alt="mark"><h1 id="简单的shell"><a href="#简单的shell" class="headerlink" title="简单的shell"></a>简单的shell</h1>shell可以很复杂，我们这里是实现读取命令并执行：<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">void shabby_shell(<span class="name">const</span> char * tty_name)</span><br><span class="line">&#123;</span><br><span class="line">	int fd_stdin  = open(tty_name, O_RDWR);</span><br><span class="line">	assert(fd_stdin  == 0);</span><br><span class="line">	int fd_stdout = open(tty_name, O_RDWR);</span><br><span class="line">	assert(fd_stdout == 1);</span><br><span class="line"></span><br><span class="line">	char rdbuf[128];</span><br><span class="line"></span><br><span class="line">	while (1) &#123;</span><br><span class="line">		write(1, "$ ", 2);</span><br><span class="line">		int r = read(0, rdbuf, 70);</span><br><span class="line">		rdbuf[r] = 0;</span><br><span class="line"></span><br><span class="line">		int argc = 0;</span><br><span class="line">		char * argv[PROC_ORIGIN_STACK]<span class="comment">;</span></span><br><span class="line">		char * p = rdbuf;</span><br><span class="line">		char * s<span class="comment">;</span></span><br><span class="line">		int word = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">		char ch<span class="comment">;</span></span><br><span class="line">		do &#123;</span><br><span class="line">			ch = *p;</span><br><span class="line">			if (*p != ' ' <span class="symbol">&amp;&amp;</span> *p != 0 &amp;&amp; !word) &#123;</span><br><span class="line">				s = p;</span><br><span class="line">				word = 1;</span><br><span class="line">			&#125;</span><br><span class="line">			if ((*p == ' ' || *p == 0) &amp;&amp; word) &#123;</span><br><span class="line">				word = 0;</span><br><span class="line">				argv[argc++] = s;</span><br><span class="line">				*p = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">			p++<span class="comment">;</span></span><br><span class="line">		&#125; while(<span class="name">ch</span>)<span class="comment">;</span></span><br><span class="line">		argv[argc] = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">		int fd = open(<span class="name">argv</span>[<span class="number">0</span>], O_RDWR)<span class="comment">;</span></span><br><span class="line">		if (<span class="name">fd</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">			if (<span class="name">rdbuf</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">				write(<span class="number">1</span>, <span class="string">"&#123;"</span>, <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">				write(<span class="number">1</span>, rdbuf, r)<span class="comment">;</span></span><br><span class="line">				write(<span class="number">1</span>, <span class="string">"&#125;\n"</span>, <span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			close(<span class="name">fd</span>)<span class="comment">;</span></span><br><span class="line">			int pid = fork()<span class="comment">;</span></span><br><span class="line">			if (<span class="name">pid</span> != <span class="number">0</span>) &#123; /* parent */</span><br><span class="line">				int s;</span><br><span class="line">				wait(&amp;s);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;	/* child */</span><br><span class="line">				execv(argv[0], argv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(1);</span><br><span class="line">	close(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************************************************************************</span><br><span class="line"> *                                Init</span><br><span class="line"> *****************************************************************************/</span><br><span class="line">/**</span><br><span class="line"> * The hen.</span><br><span class="line"> * </span><br><span class="line"> *****************************************************************************/</span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">	int fd_stdin  = open("/dev_tty0", O_RDWR);</span><br><span class="line">	assert(fd_stdin  == 0);</span><br><span class="line">	int fd_stdout = open("/dev_tty0", O_RDWR);</span><br><span class="line">	assert(fd_stdout == 1);</span><br><span class="line"></span><br><span class="line">	printf("Init() is running ...\n");</span><br><span class="line"></span><br><span class="line">	/* extract `cmd.tar' */</span><br><span class="line">	untar("/cmd.tar");</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">	char * tty_list[] = &#123;<span class="string">"/dev_tty1"</span>, <span class="string">"/dev_tty2"</span>&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	int i<span class="comment">;</span></span><br><span class="line">	for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt; sizeof(tty_list) / sizeof(tty_list[0]); i++) &#123;</span></span><br><span class="line">		int pid = fork()<span class="comment">;</span></span><br><span class="line">		if (<span class="name">pid</span> != <span class="number">0</span>) &#123; /* parent process */</span><br><span class="line">			printf("[parent is running, child pid:%d]\n", pid);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;	/* child process */</span><br><span class="line">			printf("[child is running, pid:%d]\n", getpid());</span><br><span class="line">			close(fd_stdin);</span><br><span class="line">			close(fd_stdout);</span><br><span class="line">			</span><br><span class="line">			shabby_shell(tty_list[i]);</span><br><span class="line">			assert(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (1) &#123;</span><br><span class="line">		int s;</span><br><span class="line">		int child = wait(&amp;s);</span><br><span class="line">		printf("child (%d) exited with status: %d.\n", child, s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assert(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果如下：</p>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180315/fecaCIBd21.png?imageslim" alt="mark"><br>PS:不知道为何在虚拟机下Ubuntu+Bochs就无法在Bochs里使用CTRL+Fn键！！！！</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shell </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》文件管理（7-2）]]></title>
      <url>/2018/03/10/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%887-2%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="在硬盘上制作一个文件系统"><a href="#在硬盘上制作一个文件系统" class="headerlink" title="在硬盘上制作一个文件系统"></a>在硬盘上制作一个文件系统</h1><a id="more"></a>
<p>文件系统通常有两个含义：</p>
<ul>
<li>用于存储和组织计算机文件数据的一套方法</li>
<li>存在于某介质上的具备某种格式的数据<br>我们所做的工作是第一种，所以我们需要考虑如何利用空间，如何对文件进行添加、删除以及修改，还要考虑不同类型的文件如何并存于一个文件系统。<br>当我们说某个硬盘分区是“某某文件系统”时，是说的第二种，其格式表名这个分区是由某种策略和机制来管理。<h2 id="文件系统设计的数据结构"><a href="#文件系统设计的数据结构" class="headerlink" title="文件系统设计的数据结构"></a>文件系统设计的数据结构</h2>主要有超级块、i-node和目录项。<br>超级块主要关注以下内容：</li>
<li>文件系统的标识。</li>
<li>文件系统最多允许有多少个i-node。</li>
<li>inode_array占用多少扇区。</li>
<li>文件系统总共扇区数是多少</li>
<li>inode-map占用多少扇区</li>
<li>sector-map占用多少扇区</li>
<li>第一个数据扇区的扇区号是多少</li>
<li>根目录区的i-node号是多少</li>
</ul>
<h2 id="编码建立文件系统"><a href="#编码建立文件系统" class="headerlink" title="编码建立文件系统"></a>编码建立文件系统</h2><p>建立文件系统的函数mkfs()分为如下几部分：</p>
<ul>
<li>向硬盘驱动程序索取ROOT_DEV的起始扇区和大小</li>
<li>建立超级块</li>
<li>建立inode-map</li>
<li>建立sector-map</li>
<li>写入inode-array</li>
<li>建立根目录文件<br>在函数mkfs()中，所有写入磁盘的内容都是先放进fsbuf这个缓冲区的，与通常的做法不同，没有定义一个数组，而是定义了一个指针，让它指向0x600000.<br>也就是说，指定内存地址6MB~7MB为系统文件的缓冲区。在建立FS的过程中，写扇区的函数都是WR_SECT这个宏来完成的。<br>下面来执行一下，结构如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180313/e6kBg7AIEa.png?imageslim" alt="mark"></li>
</ul>
<h1 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h1><p>对文件进行创建以及读写等操作，需要用到open()、write()、read()、close()等系统调用，而这些熊调用都用到了一个变量——fd，文件描述符（file descriptor）。如下是它的结构图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180313/K56bE5mAeG.png?imageslim" alt="mark"><br>其中fd_mode用来记录这个fd是用来做什么操作的。fd_pos用来记录读写到了文件的什么位置。fd_inode便是指向inode的指针。<br>每当一个进程打开一个文件——无论是打开一个已经存在的还是创建一个新的，该进程的进程变filp数组就会分配一个文职——假设是k，用于存放打开文件的fd指针，而这个k就是返回给用户进程open()函数的返回值了。</p>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p>现在用户进程中创建一个文件：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void TestA()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="keyword">open</span>(<span class="string">"/blah"</span>,O_CREAT);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"fd:%d\n"</span>,fd);</span><br><span class="line">    <span class="keyword">close</span>(fd);</span><br><span class="line">    spin(<span class="string">"TESTA"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是open()的系统调用：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC int open(const char *pathname, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	MESSAGE msg<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	msg.type	= OPEN<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	msg.PATHNAME	= (void*)pathname<span class="comment">;</span></span><br><span class="line">	msg.FLAGS	= flags<span class="comment">;</span></span><br><span class="line">	msg.NAME_LEN	= strlen(pathname)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	send_recv(<span class="keyword">BOTH, </span>TASK_FS, &amp;msg)<span class="comment">;</span></span><br><span class="line">	assert(msg.type == <span class="keyword">SYSCALL_RET);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">	</span>return msg.FD<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发了一个OPEN消息给文件系统，所以文件系统需要处理它：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void task_fs()</span><br><span class="line">&#123;</span><br><span class="line">	printl(<span class="string">"Task FS begins.\n"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	init_fs()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	while (<span class="number">1</span>) &#123;</span><br><span class="line">		send_recv(RECEIVE, ANY, &amp;fs_msg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">		int src = fs_msg.source<span class="comment">;</span></span><br><span class="line">		pcaller = &amp;proc_table[src]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch </span>(fs_msg.type) &#123;</span><br><span class="line">		case OPEN:</span><br><span class="line">			fs_msg.FD = do_open()<span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	case <span class="keyword">CLOSE:</span></span><br><span class="line"><span class="keyword">	</span>		fs_msg.RETVAL = do_close()<span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	.....</span><br><span class="line"><span class="symbol">		default:</span></span><br><span class="line">			dump_msg(<span class="string">"FS::unknown message:"</span>, &amp;fs_msg)<span class="comment">;</span></span><br><span class="line">			assert(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* reply */</span></span><br><span class="line">		fs_msg.type = <span class="keyword">SYSCALL_RET;</span></span><br><span class="line"><span class="keyword">	</span>	send_recv(SEND, src, &amp;fs_msg)<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中用do_open来专门处理OPEn消息，首先是从消息内对出各项参数，其中需要格外注意的是文件名的读取。</p>
<h1 id="创建文件所设计的其他函数"><a href="#创建文件所设计的其他函数" class="headerlink" title="创建文件所设计的其他函数"></a>创建文件所设计的其他函数</h1><h2 id="strip-path"><a href="#strip-path" class="headerlink" title="strip_path()"></a>strip_path()</h2><p>该函数用于把路径分为文件名和文件夹两个部分，定位直接包含文件的文件夹，并得到给定文件在此文件夹中的名称。</p>
<h2 id="search-file"><a href="#search-file" class="headerlink" title="search_file()"></a>search_file()</h2><p>用来得到文件所在目录的i-node，通过这个i-node来得到目录所在的扇区，然后读取这些扇区，查看里面是否有我们要找的文件，如果找到就返回文件的i-node，如果没有就返回0.</p>
<h2 id="do-clode"><a href="#do-clode" class="headerlink" title="do_clode()"></a>do_clode()</h2><p>关闭文件显得十分简单，CLOSE消息是由do_close()来处理。<br>完成了open()和close()两个系统调用，我们接着运行一下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180313/40eD8H7b3I.png?imageslim" alt="mark"><br>可以看到进程TestA打印出了新创建的文件的fd:0。</p>
<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>打开文件其实就是根据文件名找到i-node，并且建立进程表、f_desc_table[]和inode_table[]之间的关联。对于普通文件而言，打开操作有以下情况：</p>
<ul>
<li>文件存在。这时我们获得文件的i-node号，读出i-node，建立前面所述三表的关联，并返回fd。</li>
<li>文件不存在。直接返回-1。</li>
<li>文件不存在。创建文件，建立前面所述的关联，并返回fd。<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1>因为采取一次分配的原则，所以读写变得比较简单，但是这个方式并不好。在读写的过程中，我们任然是把它扔给相应的驱动程序——虽然驱动程序并未准备还处理，但发送一个消息只是举手之劳。下面是read()函数<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC int read(int fd, void *<span class="keyword">buf, </span>int <span class="built_in">count</span>)</span><br><span class="line">&#123;</span><br><span class="line">	MESSAGE msg<span class="comment">;</span></span><br><span class="line">	msg.type = READ<span class="comment">;</span></span><br><span class="line">	msg.FD   = fd<span class="comment">;</span></span><br><span class="line">	msg.<span class="keyword">BUF </span> = <span class="keyword">buf;</span></span><br><span class="line"><span class="keyword">	</span>msg.CNT  = <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	send_recv(<span class="keyword">BOTH, </span>TASK_FS, &amp;msg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	return msg.CNT<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面是write():<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC int write(int fd, const void *<span class="keyword">buf, </span>int <span class="built_in">count</span>)</span><br><span class="line">&#123;</span><br><span class="line">	MESSAGE msg<span class="comment">;</span></span><br><span class="line">	msg.type = WRITE<span class="comment">;</span></span><br><span class="line">	msg.FD   = fd<span class="comment">;</span></span><br><span class="line">	msg.<span class="keyword">BUF </span> = (void*)<span class="keyword">buf;</span></span><br><span class="line"><span class="keyword">	</span>msg.CNT  = <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	send_recv(<span class="keyword">BOTH, </span>TASK_FS, &amp;msg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	return msg.CNT<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="测试文件读写"><a href="#测试文件读写" class="headerlink" title="测试文件读写"></a>测试文件读写</h1><p>修改TestA代码如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void TestA()</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	int <span class="keyword">n</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> filename[] = <span class="string">"blah"</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> bufw[] = <span class="string">"abcde"</span>;</span><br><span class="line">	<span class="keyword">const</span> int rd_bytes = 3;</span><br><span class="line">	<span class="keyword">char</span> bufr[rd_bytes];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span>(rd_bytes &lt;= <span class="built_in">strlen</span>(bufw));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create */</span></span><br><span class="line">	fd = <span class="keyword">open</span>(filename, O_CREAT | O_RDWR);</span><br><span class="line">	<span class="keyword">assert</span>(fd != -1);</span><br><span class="line">	printf(<span class="string">"File created. fd: %d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* write */</span></span><br><span class="line">	<span class="keyword">n</span> = write(fd, bufw, <span class="built_in">strlen</span>(bufw));</span><br><span class="line">	<span class="keyword">assert</span>(<span class="keyword">n</span> == <span class="built_in">strlen</span>(bufw));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* close */</span></span><br><span class="line">	<span class="keyword">close</span>(fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* open */</span></span><br><span class="line">	fd = <span class="keyword">open</span>(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">assert</span>(fd != -1);</span><br><span class="line">	printf(<span class="string">"File opened. fd: %d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read */</span></span><br><span class="line">	<span class="keyword">n</span> = <span class="keyword">read</span>(fd, bufr, rd_bytes);</span><br><span class="line">	<span class="keyword">assert</span>(<span class="keyword">n</span> == rd_bytes);</span><br><span class="line">	bufr[<span class="keyword">n</span>] = 0;</span><br><span class="line">	printf(<span class="string">"%d bytes read: %s\n"</span>, <span class="keyword">n</span>, bufr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* close */</span></span><br><span class="line">	<span class="keyword">close</span>(fd);</span><br><span class="line"></span><br><span class="line">	spin(<span class="string">"TestA"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如图;<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180313/K2hdh8g0ED.png?imageslim" alt="mark"></p>
<h1 id="文件系统调试"><a href="#文件系统调试" class="headerlink" title="文件系统调试"></a>文件系统调试</h1><p>随着代码越来越多，我们需要其他调试手段，比如我们有了硬盘驱动和文件系统，我们可以直接开始写log。由于文件系统比较初级，所以Ilog可以直接通过硬盘驱动写入某个扇区。<br>下图是log。我们可以将log写出某种特定的格式，比如这个存成DOT源文件，然后用dd命令将磁盘映像中我们写入的log扇区抽取出来，存成本地文件，用bash脚本或线程的工具将log中的dot部分抽取出来，存成一个或多个文件，然后用graphviz包里面的工具将其装换成可视文件格式。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180313/8f0m3aG2c4.png?imageslim" alt="mark"></p>
<h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>删除是添加的反过程，以下是我们要做的工作：</p>
<ul>
<li>释放inode-map中的相应位</li>
<li>释放sector-map中的相应位。</li>
<li>将inode_array中的i-node清零</li>
<li>删除根目录中的目录项<br>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180313/0ggKCicGHh.png?imageslim" alt="mark"><br>我们创建了”foo”、”bar”、”baz”三个文件，然后删除，另外删除”/dev_tty0”，这时也被制止了。<h1 id="为文件系统添加系统调用的步骤"><a href="#为文件系统添加系统调用的步骤" class="headerlink" title="为文件系统添加系统调用的步骤"></a>为文件系统添加系统调用的步骤</h1></li>
</ul>
<ol>
<li>定义一种消息，比如MMM。</li>
<li>写一个函数来处理MMM消息。</li>
<li>修改task_fs()，增加对消息MMM的处理。</li>
<li>写一个用户接口函数XXX()<h1 id="将TTY纳入文件系统"><a href="#将TTY纳入文件系统" class="headerlink" title="将TTY纳入文件系统"></a>将TTY纳入文件系统</h1>假设进程P要求读取TTY，它会发送消息给文件系统，文件系统将消息传递给TTY，TTY记下发出请求的进程号等信息之后立即返回，而文件系统这时并不对P接触阻塞，因为结果还没有准备好，在接下来的过程中，文件系统像往常一样等待来自任何进程的请求。而TTY则会将键盘输入复制进P传入的内存地址，一直遇到回车，TTY就告诉文件系统，P的请求已被满足，文件系统会接触对P的阻塞，于是整个读取工作结束。<br>在写TTY时，P发消息给文件系统，文件 系统传递给TTY，TTY收到消息后立即将字符写入显存，完成后发消息给文件系统，文件系统再发消息给P，整个过程结束。<br>作为驱动程序，TTY接受并处理DEV_OPEN、DEV_READ、DEV_WRITE消息。<br>DEV_READ、DEV_WRITE分别有对应的函数tty_do_read()、tty_do_write()来处理。<br>tty_caller用来保存想TTY发送消息的进程的进程号。tty_procnr用来保存请求数据的进程的进程号。tty_req_buf保存进程P用来存放读入字符的缓冲区的线性地址。tty_left_cnt保存P想读入的字符数。tty_trans_cnt保存TTY已经向P传送了多少字符。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件读写 </tag>
            
            <tag> 文件描述符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》文件管理（7-1）]]></title>
      <url>/2018/03/10/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%887-1%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在本部分，将通过硬盘驱动程序直接操作硬盘。在编写这个文件系统的过程中，通过几个消息、用户进程、文件系统和驱动程序之间就可以方便的协同工作。<br><a id="more"></a></p>
<h1 id="硬盘操作的I-O端口"><a href="#硬盘操作的I-O端口" class="headerlink" title="硬盘操作的I/O端口"></a>硬盘操作的I/O端口</h1><p>和键盘控制器、VGA控制器等类似，对硬盘控制器的操作仍然是通过I/O端口来进行，这些端口分为两组，它们对应命令块寄存器和控制块寄存器，如下表：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/4h9jEJ5adf.png?imageslim" alt="mark"><br>对硬盘的操作并不复杂，只需要往命令块寄存器写入正确的值，再通过控制块寄存器发送命令就可以了。</p>
<h1 id="硬盘驱动程序"><a href="#硬盘驱动程序" class="headerlink" title="硬盘驱动程序"></a>硬盘驱动程序</h1><p>驱动程序的作用在于隐藏硬件细节，向上层提供统一的接口。由于进程通过收发消息来相互通信，那么驱动程序的接口自然也是消息了。所以只要定义了驱动程序可以接受的消息，也就定义了驱动程序的接口。首先想硬盘驱动器发送一个IDENTIFY命令，这个命令可用来获取硬盘参数。<br>下面是Device寄存器的格式：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/3Gl3C8IdHL.png?imageslim" alt="mark"><br>可以看到寄存器主要有LBA模式位、DRV位和低四位。DRV用于指定主盘或从盘，0表示主盘，1表示从盘。LBA模式位用于指定操作模式，当此位为0时，对磁盘的操作使用CHS模式；当为1时，对磁盘使用LBA模式。<br>我们使用函数hd_cmd_out()来进行实际的向硬件驱动器发送命令的工作，因为今后我们还会用到它。当发送命令之后，我们用interrupt_wait()来等待中断的发生。<br>驱动程序获知中断发生的情形如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/mB57am1f90.png?imageslim" alt="mark"><br>建立如下文件系统进程：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void task_fs()</span><br><span class="line">&#123;</span><br><span class="line">	printl(<span class="string">"Task FS begins.\n"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* open the device: hard disk */</span></span><br><span class="line">	MESSAGE driver_msg<span class="comment">;</span></span><br><span class="line">	driver_msg.type = DEV_OPEN<span class="comment">;</span></span><br><span class="line">	send_recv(<span class="keyword">BOTH, </span>TASK_HD, &amp;driver_msg)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	spin(<span class="string">"FS"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>make运行，结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/LGCiLGeLhh.png?imageslim" alt="mark"></p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>我们结合前面学习的FAT12来了解文件系统，从下图可知，文件系统有4个部分：</p>
<ul>
<li>引导扇区：存放Metadata—占用整整一个扇区的superblock</li>
<li>FAT表：记录扇区使用情况—sector map</li>
<li>根目录区：文件的索引—inode map</li>
<li>数据区：记录任一文件的信息—root数据区</li>
</ul>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/1HDAL7Ea9C.png?imageslim" alt="mark"><br>superblock通常也叫超级块，关于文件系统的Metadata都记录在这里。sector map是哟个位图，用来映射扇区的使用情况，用1表示扇区已经被使用。i-node是UNIX各种文件系统的核心数据结构之一。</p>
<h1 id="硬盘分区表"><a href="#硬盘分区表" class="headerlink" title="硬盘分区表"></a>硬盘分区表</h1><p>硬盘分区表是一个结构体数组，数组的每个成员是一个16字节的结构体，如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/HGIE6mjCie.png?imageslim" alt="mark"><br>我们将80MB的硬盘映像分成了一个主分区和一个扩展分区，扩展分区中又分成了5个逻辑分区。我们以后把写的操作系统放在第一个逻辑分区。先把它的分区类型（Systen ID）改成99h，又维他设定了“可启动”标志。</p>
<h1 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h1><p>下图是所有分区：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/kH04b78Kg7.png?imageslim" alt="mark"><br>其中数字1~4为主引导扇区中的分区表项所示，从5开始依次表示逻辑分区。<br>这些数字其实就是设备号，其作用是给每个设备起一个名字，这样驱动程序就能方便地管理他们。<br>对硬盘而言，采用如下的编号规则：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/imghLd462H.png?imageslim" alt="mark"><br>下面是遍历所有分区的情况：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180310/6Fj161594D.png?imageslim" alt="mark"></p>
<h1 id="完善硬盘驱动程序"><a href="#完善硬盘驱动程序" class="headerlink" title="完善硬盘驱动程序"></a>完善硬盘驱动程序</h1><p>目前的驱动程序只能处理DEV_OPEN消息，这显然是不够的，起码也要有DEV_READ和DEV_WRITE。下面先添加读写硬盘的功能：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                task_hd</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * Main loop of HD driver.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PUBLIC <span class="keyword">void</span> task_hd()</span><br><span class="line">&#123;</span><br><span class="line">	MESSAGE msg;</span><br><span class="line"></span><br><span class="line">	init_hd();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		send_recv(RECEIVE, ANY, &amp;msg);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">int</span> src = msg.source;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (msg.type) &#123;</span><br><span class="line">		<span class="keyword">case</span> DEV_OPEN:</span><br><span class="line">			hd_open(msg.DEVICE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> DEV_CLOSE:</span><br><span class="line">			hd_close(msg.DEVICE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> DEV_READ:</span><br><span class="line">		<span class="keyword">case</span> DEV_WRITE:</span><br><span class="line">			hd_rdwt(&amp;msg);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> DEV_IOCTL:</span><br><span class="line">			hd_ioctl(&amp;msg);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			dump_msg(<span class="string">"HD driver::unknown msg"</span>, &amp;msg);</span><br><span class="line">			spin(<span class="string">"FS::main_loop (invalid msg.type)"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		send_recv(SEND, src, &amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                init_hd</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">1</span>&gt;</span></span> Check hard drive, set IRQ handler, enable IRQ and initialize data</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *          structures.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> init_hd()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the number of drives from the BIOS data area */</span></span><br><span class="line">	u8 * pNrDrives = (u8*)(<span class="number">0x475</span>);</span><br><span class="line">	printl(<span class="string">"NrDrives:%d.\n"</span>, *pNrDrives);</span><br><span class="line">	<span class="keyword">assert</span>(*pNrDrives);</span><br><span class="line"></span><br><span class="line">	put_irq_handler(AT_WINI_IRQ, hd_handler);</span><br><span class="line">	enable_irq(CASCADE_IRQ);</span><br><span class="line">	enable_irq(AT_WINI_IRQ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (sizeof(hd_info) / sizeof(hd_info[<span class="number">0</span>])); i++)</span><br><span class="line">		memset(&amp;hd_info[i], <span class="number">0</span>, sizeof(hd_info[<span class="number">0</span>]));</span><br><span class="line">	hd_info[<span class="number">0</span>].open_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                hd_open</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">1</span>&gt;</span></span> This routine handles DEV_OPEN message. It identify </span>the<span class="markdown"> drive</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * of </span>the<span class="markdown"> given device and read </span>the<span class="markdown"> partition table of </span>the<span class="markdown"> drive if it</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * has not been read.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param device The device to be opened.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> hd_open(<span class="built_in">int</span> device)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> drive = DRV_OF_DEV(device);</span><br><span class="line">	<span class="keyword">assert</span>(drive == <span class="number">0</span>);	<span class="comment">/* only one drive */</span></span><br><span class="line"></span><br><span class="line">	hd_identify(drive);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hd_info[drive].open_cnt++ == <span class="number">0</span>) &#123;</span><br><span class="line">		partition(drive * (NR_PART_PER_DRIVE + <span class="number">1</span>), P_PRIMARY);</span><br><span class="line">		print_hdinfo(&amp;hd_info[drive]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                hd_close</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">1</span>&gt;</span></span> This routine handles DEV_CLOSE message. </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param device The device to be opened.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> hd_close(<span class="built_in">int</span> device)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> drive = DRV_OF_DEV(device);</span><br><span class="line">	<span class="keyword">assert</span>(drive == <span class="number">0</span>);	<span class="comment">/* only one drive */</span></span><br><span class="line"></span><br><span class="line">	hd_info[drive].open_cnt--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                hd_rdwt</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">1</span>&gt;</span></span> This routine handles DEV<span class="emphasis">_READ and DEV_</span>WRITE message.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param p Message ptr.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> hd_rdwt(MESSAGE * p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> drive = DRV_OF_DEV(p-&gt;DEVICE);</span><br><span class="line"></span><br><span class="line">	u64 pos = p-&gt;POSITION;</span><br><span class="line">	<span class="keyword">assert</span>((pos &gt;&gt; SECTOR_SIZE_SHIFT) &lt; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	 * We only allow to R/W from </span></span>a<span class="markdown"> SECTOR boundary:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">	 */</span></span></span></span><br><span class="line">	<span class="keyword">assert</span>((pos &amp; <span class="number">0x1FF</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	u32 sect_nr = (u32)(pos &gt;&gt; SECTOR_SIZE_SHIFT); <span class="comment">/* pos / SECTOR_SIZE */</span></span><br><span class="line">	<span class="built_in">int</span> logidx = (p-&gt;DEVICE - MINOR_hd1a) % NR_SUB_PER_DRIVE;</span><br><span class="line">	sect_nr += p-&gt;DEVICE &lt; MAX_PRIM ?</span><br><span class="line">		hd_info[drive].primary[p-&gt;DEVICE].base :</span><br><span class="line">		hd_info[drive].logical[logidx].base;</span><br><span class="line"></span><br><span class="line">	struct hd_cmd cmd;</span><br><span class="line">	cmd.features	= <span class="number">0</span>;</span><br><span class="line">	cmd.count	= (p-&gt;CNT + SECTOR_SIZE - <span class="number">1</span>) / SECTOR_SIZE;</span><br><span class="line">	cmd.lba_low	= sect_nr &amp; <span class="number">0xFF</span>;</span><br><span class="line">	cmd.lba_mid	= (sect_nr &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">	cmd.lba_high	= (sect_nr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">	cmd.device	= MAKE_DEVICE_REG(<span class="number">1</span>, drive, (sect_nr &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>);</span><br><span class="line">	cmd.command	= (p-&gt;type == DEV_READ) ? ATA_READ : ATA_WRITE;</span><br><span class="line">	hd_cmd_out(&amp;cmd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span> bytes_left = p-&gt;CNT;</span><br><span class="line">	<span class="keyword">void</span> * la = (<span class="keyword">void</span>*)va2la(p-&gt;PROC_NR, p-&gt;BUF);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (bytes_left) &#123;</span><br><span class="line">		<span class="built_in">int</span> bytes = min(SECTOR_SIZE, bytes_left);</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;type == DEV_READ) &#123;</span><br><span class="line">			interrupt_wait();</span><br><span class="line">			port_read(REG_DATA, hdbuf, SECTOR_SIZE);</span><br><span class="line">			phys_copy(la, (<span class="keyword">void</span>*)va2la(TASK_HD, hdbuf), bytes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!waitfor(STATUS_DRQ, STATUS_DRQ, HD_TIMEOUT))</span><br><span class="line">				panic(<span class="string">"hd writing error."</span>);</span><br><span class="line"></span><br><span class="line">			port_write(REG_DATA, la, bytes);</span><br><span class="line">			interrupt_wait();</span><br><span class="line">		&#125;</span><br><span class="line">		bytes_left -= SECTOR_SIZE;</span><br><span class="line">		la += SECTOR_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;															</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                hd_ioctl</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">1</span>&gt;</span></span> This routine handles </span>the<span class="markdown"> DEV_IOCTL message.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param p  Ptr to </span>the<span class="markdown"> MESSAGE.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> hd_ioctl(MESSAGE * p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> device = p-&gt;DEVICE;</span><br><span class="line">	<span class="built_in">int</span> drive = DRV_OF_DEV(device);</span><br><span class="line"></span><br><span class="line">	struct hd_info * hdi = &amp;hd_info[drive];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;REQUEST == DIOCTL_GET_GEO) &#123;</span><br><span class="line">		<span class="keyword">void</span> * dst = va2la(p-&gt;PROC_NR, p-&gt;BUF);</span><br><span class="line">		<span class="keyword">void</span> * src = va2la(TASK_HD,</span><br><span class="line">				   device &lt; MAX_PRIM ?</span><br><span class="line">				   &amp;hdi-&gt;primary[device] :</span><br><span class="line">				   &amp;hdi-&gt;logical[(device - MINOR_hd1a) %</span><br><span class="line">						NR_SUB_PER_DRIVE]);</span><br><span class="line"></span><br><span class="line">		phys_copy(dst, src, sizeof(struct part_info));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">assert</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件管理 </tag>
            
            <tag> 设备号 </tag>
            
            <tag> 硬盘驱动程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》进程间通信（6-1）]]></title>
      <url>/2018/03/07/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%886%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="微内核与宏内核"><a href="#微内核与宏内核" class="headerlink" title="微内核与宏内核"></a>微内核与宏内核</h1><ul>
<li>微内核：让内核只负责它必须负责的工作，比如进程调度，将内核工作简单化的思想，便是微内核的基本思想。</li>
<li>宏内核：所有工作通过系统调用扔给内核态的做法，完成具体任务时，用户进程通过系统调用让内核来做事。<a id="more"></a>
宏内核的优势在于其逻辑简单，直接了当，实现起来容易些，而且也因为它的直接，避免了像微内核那样在消息传递时占用资源。而微内核的优势在于，它的逻辑虽然相对复杂但是非常严谨，结构上显得非常优雅精致，而且程序更容易模块化，从而更容易移植。<br>所以我们首要的任务就是实现一个进程间的通信机制（IPC）。<h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1>IPC是Inter—Process Communication的缩写，是进程间通信的意思，就是进程间发消息。IPC有同步和异步之分，同步是消息发送发和消息接收方都会一直等待消息，它的好处是：</li>
<li>操作系统不需要另外维护缓冲区来存放正在传递的消息</li>
<li>操作系统不需要保留一份消息副本</li>
<li>操作系统不需要维护接受队列</li>
<li>发送者和接受者都可以在任何时刻清晰且容易的知道消息是否送达</li>
<li>从实现系统调用的角度看，同步IPC更加合理，当使用系统调用时，我们的确需要等待内核返回结果之后再继续<h1 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h1>IPC的机制已经清楚了，它的核心在int SYSVEC这个软中断以及与之对应的sys_call()这个函数。<br>下面是新的系统调用sendrec:<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sendrec:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, _NR_sendrec</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ebx</span>, [<span class="built_in">esp</span> + <span class="number">4</span>]	<span class="comment">; function</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ecx</span>, [<span class="built_in">esp</span> + <span class="number">8</span>]	<span class="comment">; src_dest</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">edx</span>, [<span class="built_in">esp</span> + <span class="number">12</span>]	<span class="comment">; p_msg</span></span><br><span class="line">	<span class="keyword">int</span>	INT_VECTOR_SYS_CALL</span><br><span class="line">	<span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>sys_sendrec（）这个函数被设计得很简单，就是send消息交给msg_send（）处理，把RECEIVE消息交给msg_receive()处理。</p>
<h2 id="msg-send-和msg-receive"><a href="#msg-send-和msg-receive" class="headerlink" title="msg_send()和msg_receive()"></a>msg_send()和msg_receive()</h2><p>核心代码如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *				  ldt<span class="emphasis">_seg_</span>linear</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>~<span class="attr">1</span>&gt;</span></span> Calculate </span>the<span class="markdown"> linear address of </span>a<span class="markdown"> certain segment of </span>a<span class="markdown"> given</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * proc.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param p   Whose (</span>the<span class="markdown"> proc ptr).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param idx Which (one proc has </span>more<span class="markdown"> than one segments).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @return  The required linear address.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PUBLIC <span class="built_in">int</span> ldt_seg_linear(struct proc* p, <span class="built_in">int</span> idx)</span><br><span class="line">&#123;</span><br><span class="line">	struct descriptor * d = &amp;p-&gt;ldts[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> d-&gt;base_high &lt;&lt; <span class="number">24</span> | d-&gt;base_mid &lt;&lt; <span class="number">16</span> | d-&gt;base_low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *				  va2la</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>~<span class="attr">1</span>&gt;</span></span> Virtual addr --&gt; Linear addr.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param pid  PID of </span>the<span class="markdown"> proc whose address is to be calculated.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param va   Virtual address.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @return The linear address for </span>the<span class="markdown"> given virtual address.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PUBLIC <span class="keyword">void</span>* va2la(<span class="built_in">int</span> pid, <span class="keyword">void</span>* va)</span><br><span class="line">&#123;</span><br><span class="line">	struct proc* p = &amp;proc_table[pid];</span><br><span class="line"></span><br><span class="line">	u32 seg_base = ldt_seg_linear(p, INDEX_LDT_RW);</span><br><span class="line">	u32 la = seg_base + (u32)va;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; NR_TASKS + NR_PROCS) &#123;</span><br><span class="line">		<span class="keyword">assert</span>(la == (u32)va);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)la;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                reset_msg</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>~<span class="attr">3</span>&gt;</span></span> Clear up </span>a<span class="markdown"> MESSAGE by setting each byte to 0.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param p  The message to be cleared.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PUBLIC <span class="keyword">void</span> reset_msg(MESSAGE* p)</span><br><span class="line">&#123;</span><br><span class="line">	memset(p, <span class="number">0</span>, sizeof(MESSAGE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                block</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>&gt;</span></span> This routine is called after `p_flags' has been set (!= 0), it</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * calls `schedule()' to choose another proc as </span>the<span class="markdown"> `proc_ready'.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @attention This routine does not change `p_flags'. Make sure </span>the<span class="markdown"> `p_flags'</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * of </span>the<span class="markdown"> proc to be blocked has been set properly.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param p The proc to be blocked.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> block(struct proc* p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">assert</span>(p-&gt;p_flags);</span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                unblock</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>&gt;</span></span> This is </span>a<span class="markdown"> dummy routine. It does nothing actually. When it is</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * called, </span>the<span class="markdown"> `p_flags' </span>should<span class="markdown"> have been cleared (== 0).</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param p The unblocked proc.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="keyword">void</span> unblock(struct proc* p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">assert</span>(p-&gt;p_flags == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                deadlock</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>&gt;</span></span> Check whether it is safe to send </span>a<span class="markdown"> message from src to dest.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * The routine </span>will<span class="markdown"> detect if </span>the<span class="markdown"> messaging graph contains </span>a<span class="markdown"> cycle. For</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * instance, if we have procs trying to send messages </span>like<span class="markdown"> this:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * A -&gt; B -&gt; C -&gt; A, then </span>a<span class="markdown"> deadlock occurs, because all of them </span>will<span class="markdown"></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * wait forever. If no cycles detected, it is considered as safe.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param src   Who wants to send message.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param dest  To whom </span>the<span class="markdown"> message is sent.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @return Zero if success.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="built_in">int</span> deadlock(<span class="built_in">int</span> src, <span class="built_in">int</span> dest)</span><br><span class="line">&#123;</span><br><span class="line">	struct proc* p = proc_table + dest;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;p_flags &amp; SENDING) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;p_sendto == src) &#123;</span><br><span class="line">				<span class="comment">/* print the chain */</span></span><br><span class="line">				p = proc_table + dest;</span><br><span class="line">				printl(<span class="string">"=_=%s"</span>, p-&gt;name);</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">assert</span>(p-&gt;p_msg);</span><br><span class="line">					p = proc_table + p-&gt;p_sendto;</span><br><span class="line">					printl(<span class="string">"-&gt;%s"</span>, p-&gt;name);</span><br><span class="line">				&#125; <span class="keyword">while</span> (p != proc_table + src);</span><br><span class="line">				printl(<span class="string">"=_="</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p = proc_table + p-&gt;p_sendto;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                msg_send</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>&gt;</span></span> Send </span>a<span class="markdown"> message to </span>the<span class="markdown"> dest proc. If dest is blocked waiting for</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span>the<span class="markdown"> message, copy </span>the<span class="markdown"> message to it and unblock dest. Otherwise </span>the<span class="markdown"> caller</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span>will<span class="markdown"> be blocked and appended to </span>the<span class="markdown"> dest's sending queue.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param current  The caller, </span>the<span class="markdown"> sender.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param dest     To whom </span>the<span class="markdown"> message is sent.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param m        The message.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @return Zero if success.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="built_in">int</span> msg_send(struct proc* current, <span class="built_in">int</span> dest, MESSAGE* m)</span><br><span class="line">&#123;</span><br><span class="line">	struct proc* sender = current;</span><br><span class="line">	struct proc* p_dest = proc_table + dest; <span class="comment">/* proc dest */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span>(proc2pid(sender) != dest);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for deadlock here */</span></span><br><span class="line">	<span class="keyword">if</span> (deadlock(proc2pid(sender), dest)) &#123;</span><br><span class="line">		panic(<span class="string">"&gt;&gt;DEADLOCK&lt;&lt; %s-&gt;%s"</span>, sender-&gt;name, p_dest-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((p_dest-&gt;p_flags &amp; RECEIVING) &amp;&amp; <span class="comment">/* dest is waiting for the msg */</span></span><br><span class="line">	    (p_dest-&gt;p_recvfrom == proc2pid(sender) ||</span><br><span class="line">	     p_dest-&gt;p_recvfrom == ANY)) &#123;</span><br><span class="line">		<span class="keyword">assert</span>(p_dest-&gt;p_msg);</span><br><span class="line">		<span class="keyword">assert</span>(m);</span><br><span class="line"></span><br><span class="line">		phys_copy(va2la(dest, p_dest-&gt;p_msg),</span><br><span class="line">			  va2la(proc2pid(sender), m),</span><br><span class="line">			  sizeof(MESSAGE));</span><br><span class="line">		p_dest-&gt;p_msg = <span class="number">0</span>;</span><br><span class="line">		p_dest-&gt;p_flags &amp;= ~RECEIVING; <span class="comment">/* dest has received the msg */</span></span><br><span class="line">		p_dest-&gt;p_recvfrom = NO_TASK;</span><br><span class="line">		unblock(p_dest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span>(p_dest-&gt;p_flags == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(p_dest-&gt;p_msg == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(p_dest-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(p_dest-&gt;p_sendto == NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_flags == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_msg == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_sendto == NO_TASK);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">/* dest is not waiting for the msg */</span></span><br><span class="line">		sender-&gt;p_flags |= SENDING;</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_flags == SENDING);</span><br><span class="line">		sender-&gt;p_sendto = dest;</span><br><span class="line">		sender-&gt;p_msg = m;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* append to the sending queue */</span></span><br><span class="line">		struct proc * p;</span><br><span class="line">		<span class="keyword">if</span> (p_dest-&gt;q_sending) &#123;</span><br><span class="line">			p = p_dest-&gt;q_sending;</span><br><span class="line">			<span class="keyword">while</span> (p-&gt;next_sending)</span><br><span class="line">				p = p-&gt;next_sending;</span><br><span class="line">			p-&gt;next_sending = sender;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p_dest-&gt;q_sending = sender;</span><br><span class="line">		&#125;</span><br><span class="line">		sender-&gt;next_sending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		block(sender);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_flags == SENDING);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_msg != <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(sender-&gt;p_sendto == dest);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *                                msg_receive</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * <span class="xml"><span class="tag">&lt;<span class="name">Ring</span> <span class="attr">0</span>&gt;</span></span> Try to get </span>a<span class="markdown"> message from </span>the<span class="markdown"> src proc. If src is blocked sending</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span>the<span class="markdown"> message, copy </span>the<span class="markdown"> message from it and unblock src. Otherwise </span>the<span class="markdown"> caller</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span>will<span class="markdown"> be blocked.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param current The caller, </span>the<span class="markdown"> proc who wanna receive.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param src     From whom </span>the<span class="markdown"> message </span>will<span class="markdown"> be received.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @param m       The message ptr to accept </span>the<span class="markdown"> message.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * @return  Zero if success.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line">PRIVATE <span class="built_in">int</span> msg_receive(struct proc* current, <span class="built_in">int</span> src, MESSAGE* m)</span><br><span class="line">&#123;</span><br><span class="line">	struct proc* p_who_wanna_recv = current; <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">						  * This name is </span></span>a<span class="markdown"> little bit</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">						  * wierd, </span></span>but<span class="markdown"> it makes me</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">						  * think clearly, </span></span>so<span class="markdown"> I keep</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">						  * it.</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">						  */</span></span></span></span><br><span class="line">	struct proc* p_from = <span class="number">0</span>; <span class="comment">/* from which the message will be fetched */</span></span><br><span class="line">	struct proc* prev = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> copyok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span>(proc2pid(p_who_wanna_recv) != src);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((p_who_wanna_recv-&gt;has_int_msg) &amp;&amp;</span><br><span class="line">	    ((src == ANY) || (src == INTERRUPT))) &#123;</span><br><span class="line">		<span class="comment">/* There is an interrupt needs p_who_wanna_recv's handling and</span></span><br><span class="line"><span class="comment">		 * p_who_wanna_recv is ready to handle it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		MESSAGE msg;</span><br><span class="line">		reset_msg(&amp;msg);</span><br><span class="line">		msg.source = INTERRUPT;</span><br><span class="line">		msg.type = HARD_INT;</span><br><span class="line">		<span class="keyword">assert</span>(m);</span><br><span class="line">		phys_copy(va2la(proc2pid(p_who_wanna_recv), m), &amp;msg,</span><br><span class="line">			  sizeof(MESSAGE));</span><br><span class="line"></span><br><span class="line">		p_who_wanna_recv-&gt;has_int_msg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_flags == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_msg == <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_sendto == NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;has_int_msg == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Arrives here if no interrupt for p_who_wanna_recv. */</span></span><br><span class="line">	<span class="keyword">if</span> (src == ANY) &#123;</span><br><span class="line">		<span class="comment">/* p_who_wanna_recv is ready to receive messages from</span></span><br><span class="line"><span class="comment">		 * ANY proc, we'll check the sending queue and pick the</span></span><br><span class="line"><span class="comment">		 * first proc in it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p_who_wanna_recv-&gt;q_sending) &#123;</span><br><span class="line">			p_from = p_who_wanna_recv-&gt;q_sending;</span><br><span class="line">			copyok = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_flags == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_msg == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_sendto == NO_TASK);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;q_sending != <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_flags == SENDING);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_msg != <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_sendto == proc2pid(p_who_wanna_recv));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* p_who_wanna_recv wants to receive a message from</span></span><br><span class="line"><span class="comment">		 * a certain proc: src.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p_from = &amp;proc_table[src];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((p_from-&gt;p_flags &amp; SENDING) &amp;&amp;</span><br><span class="line">		    (p_from-&gt;p_sendto == proc2pid(p_who_wanna_recv))) &#123;</span><br><span class="line">			<span class="comment">/* Perfect, src is sending a message to</span></span><br><span class="line"><span class="comment">			 * p_who_wanna_recv.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			copyok = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			struct proc* p = p_who_wanna_recv-&gt;q_sending;</span><br><span class="line">			<span class="keyword">assert</span>(p); <span class="comment">/* p_from must have been appended to the</span></span><br><span class="line"><span class="comment">				    * queue, so the queue must not be NULL</span></span><br><span class="line"><span class="comment">				    */</span></span><br><span class="line">			<span class="keyword">while</span> (p) &#123;</span><br><span class="line">				<span class="keyword">assert</span>(p_from-&gt;p_flags &amp; SENDING);</span><br><span class="line">				<span class="keyword">if</span> (proc2pid(p) == src) &#123; <span class="comment">/* if p is the one */</span></span><br><span class="line">					p_from = p;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				prev = p;</span><br><span class="line">				p = p-&gt;next_sending;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_flags == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_msg == <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_sendto == NO_TASK);</span><br><span class="line">			<span class="keyword">assert</span>(p_who_wanna_recv-&gt;q_sending != <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_flags == SENDING);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_msg != <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_recvfrom == NO_TASK);</span><br><span class="line">			<span class="keyword">assert</span>(p_from-&gt;p_sendto == proc2pid(p_who_wanna_recv));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copyok) &#123;</span><br><span class="line">		<span class="comment">/* It's determined from which proc the message will</span></span><br><span class="line"><span class="comment">		 * be copied. Note that this proc must have been</span></span><br><span class="line"><span class="comment">		 * waiting for this moment in the queue, so we should</span></span><br><span class="line"><span class="comment">		 * remove it from the queue.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p_from == p_who_wanna_recv-&gt;q_sending) &#123; <span class="comment">/* the 1st one */</span></span><br><span class="line">			<span class="keyword">assert</span>(prev == <span class="number">0</span>);</span><br><span class="line">			p_who_wanna_recv-&gt;q_sending = p_from-&gt;next_sending;</span><br><span class="line">			p_from-&gt;next_sending = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">assert</span>(prev);</span><br><span class="line">			prev-&gt;next_sending = p_from-&gt;next_sending;</span><br><span class="line">			p_from-&gt;next_sending = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span>(m);</span><br><span class="line">		<span class="keyword">assert</span>(p_from-&gt;p_msg);</span><br><span class="line">		<span class="comment">/* copy the message */</span></span><br><span class="line">		phys_copy(va2la(proc2pid(p_who_wanna_recv), m),</span><br><span class="line">			  va2la(proc2pid(p_from), p_from-&gt;p_msg),</span><br><span class="line">			  sizeof(MESSAGE));</span><br><span class="line"></span><br><span class="line">		p_from-&gt;p_msg = <span class="number">0</span>;</span><br><span class="line">		p_from-&gt;p_sendto = NO_TASK;</span><br><span class="line">		p_from-&gt;p_flags &amp;= ~SENDING;</span><br><span class="line">		unblock(p_from);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;  <span class="comment">/* nobody's sending any msg */</span></span><br><span class="line">		<span class="comment">/* Set p_flags so that p_who_wanna_recv will not</span></span><br><span class="line"><span class="comment">		 * be scheduled until it is unblocked.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p_who_wanna_recv-&gt;p_flags |= RECEIVING;</span><br><span class="line"></span><br><span class="line">		p_who_wanna_recv-&gt;p_msg = m;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (src == ANY)</span><br><span class="line">			p_who_wanna_recv-&gt;p_recvfrom = ANY;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p_who_wanna_recv-&gt;p_recvfrom = proc2pid(p_from);</span><br><span class="line"></span><br><span class="line">		block(p_who_wanna_recv);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_flags == RECEIVING);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_msg != <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_recvfrom != NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;p_sendto == NO_TASK);</span><br><span class="line">		<span class="keyword">assert</span>(p_who_wanna_recv-&gt;has_int_msg == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>block():阻塞一个进程</li>
<li>unblock()：解除一个进程阻塞</li>
<li>deadloch():简单的判断是否发生死锁。方法是判断消息的发送是否构成一个环，如果构成环则意味着发生死锁。<br>假设有进程A想要想进程B发送M，那么过程将会是这样的：</li>
</ul>
<ol>
<li>A首先准备好M</li>
<li>A通过系统调用sendrec，最终调用msg_send</li>
<li>简单判断是否发生锁死</li>
<li>判断目标进程B是否等待来自A的消息：</li>
</ol>
<ul>
<li>如果是：消息被复制给B，B被解除阻塞，继续运行；</li>
<li>如果不是：A被阻塞，并被加入到B的发送队列中<br>假设有进程B想要接送消息，那么过程将会是：</li>
</ul>
<ol>
<li>B准备一个空的消息结构体M，用于接受消息。</li>
<li>B通过系统调用sendrec，最终调用msg_receive</li>
<li>判断B是否有个来自硬件的消息，如果是，并且B准备接送户来自中断的消息或者准备接受任意消息，则马上准备一个消息给B，并返回。</li>
<li>如果B想接受来自任意进程的消息，则从自己的发送队列中选取第一个，将其消息复制给M。</li>
<li>如果B是想接受来自特定进程A的消息，则先判断A是否正在等待B发送消息，若是的话，将消息复给M</li>
<li>如果此时没有任何进程发消息给B，B会被阻塞。</li>
</ol>
<h2 id="增加消息机制之后的进程调度"><a href="#增加消息机制之后的进程调度" class="headerlink" title="增加消息机制之后的进程调度"></a>增加消息机制之后的进程调度</h2><p>现在每个进程增加了两种可能的状态：SENDING和RECEIVING。相应的，我们需要在进程调度的时候区别对待了。凡是处在SENDING和RECEIVING状态的进程，我们不再让它们获得CPU了，也就是说，将它们阻塞了。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》输入输出系统（5-2）]]></title>
      <url>/2018/03/06/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%EF%BC%885-2%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h1><h2 id="初识TTY"><a href="#初识TTY" class="headerlink" title="初识TTY"></a>初识TTY</h2><p>TTY在Linux中就是终端。当按下ALT+F1、ALT+F2、ALT+F3等组合键时，会切换到不同的屏幕。对于不同的TTY可以理解成下面：<br><a id="more"></a><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/G5jE67714i.png?imageslim" alt="mark"><br>虽然不同的TTY对应的输入设备是同一个键盘，但是输出却好比是在不同的显示器上，因为不同的TTY对应的屏幕画面可能不同。实际上，画面的不同，仅仅是显示了显存的不同位置罢了。<br>既然3个CONSOLE公用一块显存，那就有一种方式在切换CONSOLE的瞬间，让屏幕显示显存中某个位置的内容。<br>屏幕上每一个字符对应的2字节的定义如下所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/hLcie7G3B1.png?imageslim" alt="mark"><br>可以看到，第字节表示的是字符本身，高字节用来定义字符的颜色。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/5dE3e6j1eh.png?imageslim" alt="mark"></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>VGA视频子系统的寄存器如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/3CbB2AdK3d.png?imageslim" alt="mark"><br>这么多的寄存器，只有一个端口0X3D5，然后配合Address Register。下图中每一个寄存器都对应一个索引值，当想要访问其中一个的时候，只需要先向Adress Register写对应的索引值，然后在通过端口0x3D5进程的操作就是针对索引值对应的寄存器了。<br>![mark](<a href="http://p29pmm8g4.bkt.clouddn.com/blog/180306/6aKGfjHmCk" target="_blank" rel="noopener">http://p29pmm8g4.bkt.clouddn.com/blog/180306/6aKGfjHmCk</a><br>下面我们让光标跟随我们敲入的字符，设置光标位置：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">disable_int()<span class="comment">;</span></span><br><span class="line">		out_byte(<span class="name">CRTC_ADDR_REG</span>, CURSOR_H)<span class="comment">;</span></span><br><span class="line">		out_byte(<span class="name">CRTC_DATA_REG</span>, ((<span class="name">disp_pos/2</span>)&gt;&gt;8)&amp;0xFF)<span class="comment">;</span></span><br><span class="line">		out_byte(<span class="name">CRTC_ADDR_REG</span>, CURSOR_L)<span class="comment">;</span></span><br><span class="line">		out_byte(<span class="name">CRTC_DATA_REG</span>, (<span class="name">disp_pos/2</span>)&amp;0xFF)<span class="comment">;</span></span><br><span class="line">		enable_int()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>make运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/CIjLKdgCL4.png?imageslim" alt="mark"><br>接着，我们通过设置Start Adressb High Register和Start Adress Low Register来重新设置显示开始地址，从而实现滚屏的功能。当我们按下shift+上箭头时，则卷动屏幕向上15行<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/BA0mclK9Af.png?imageslim" alt="mark"></p>
<h1 id="TTY任务"><a href="#TTY任务" class="headerlink" title="TTY任务"></a>TTY任务</h1><p>在TTY任务中执行一个循环，这个循环将轮询每一个TTY，处理它的事件，包括从键盘缓冲区读取数据、显示字符等。它的运行方式如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/eA02LFamg7.png?imageslim" alt="mark"><br>其实轮询到每一个TTY时，不外乎做两件事：</p>
<ul>
<li>处理输入：查看是不是当前TTY，如果是则从键盘缓冲区读取数据。</li>
<li>处理输出：如果有要显示的内容则显示它。<br>下面要做的TTY任务不再简单，主要表现为：</li>
<li>每一个TTY都应该有自己的读和写的动作。所以在keyboard_read（）内部，函数需要了解自己是被哪一个TTY调用。我们通过为函数传入一个参数来做到这一点，这个参数是指向当前TTY的指针。</li>
<li>为了让输入输出分离，被keyboard_read（）调用的in_process()不应该再直接回显示符，而应该将回显的任务交给TTY来完成，这样我们就需要为每个TTY建立一块缓冲区，用以放置将被回显的字符。</li>
<li>每个TTY回显字符时操作的console是不同的，所以每个TTY都应该有个成员来记载其对应的console信息。<h2 id="TTY任务框架的搭建"><a href="#TTY任务框架的搭建" class="headerlink" title="TTY任务框架的搭建"></a>TTY任务框架的搭建</h2>TTY结构如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTY_IN_BYTES	256	<span class="comment">/* tty input queue size */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_console</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TTY */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_tty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u32	in_buf[TTY_IN_BYTES];	<span class="comment">/* TTY 输入缓冲区 */</span></span><br><span class="line">	u32*	p_inbuf_head;		<span class="comment">/* 指向缓冲区中下一个空闲位置 */</span></span><br><span class="line">	u32*	p_inbuf_tail;		<span class="comment">/* 指向键盘任务应处理的键值 */</span></span><br><span class="line">	<span class="keyword">int</span>	inbuf_count;		<span class="comment">/* 缓冲区中已经填充了多少 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_console</span> *	<span class="title">p_console</span>;</span></span><br><span class="line">&#125;TTY;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>CONSOLE结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_console</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	current_start_addr;	<span class="comment">/* 当前显示到了什么位置	  */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	original_addr;		<span class="comment">/* 当前控制台对应显存位置 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	v_mem_limit;		<span class="comment">/* 当前控制台占的显存大小 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	cursor;			<span class="comment">/* 当前光标位置 */</span></span><br><span class="line">&#125;CONSOLE;</span><br></pre></td></tr></table></figure></p>
<p>整个程序的流程如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/IgF8dC2JKI.png?imageslim" alt="mark"><br>在task_tty()中，通过循环来处理每一个TTY的读和写操作，读写操作都放在了tty_do_read()和tty_do_write()两个函数中，这样就让taske_tty()很简洁，而且逻辑清晰。读操作会调用keyboard_read()，当然此时已经多了一个参数；写操作会调用out_char()，它会将字符写入指定的CONSOLE。，当TTY任务开始运行时，所有TTY都将被初始化，并且全局变量nr_current_console会被赋值为0.然后循环开始并一直进行下去。对于每一个TTY，首先执行tty_do_read（），它将调用kerboard_read()并将读入的字符交给函数in_process（）来处理，如果是需要输出的字符，会被in_process（）放入当前接受处理的TTY的缓冲区中。然后tty_do_write()会接着执行，如果缓冲区中有数据，就被送入out_char显示出来。</p>
<h2 id="多控制台"><a href="#多控制台" class="headerlink" title="多控制台"></a>多控制台</h2><p>下面是多控制台示意图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/AJm32hJgLF.png?imageslim" alt="mark"><br>表示了某时刻显存的使用情况。其中灰色框表示当前屏幕，黑色小方格显示显存已经写入的字符。<br>运行结果如下:<br>在控制台0按下数次shift+箭头上<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/b1mfg6HcfA.png?imageslim" alt="mark"></p>
<h2 id="完善键盘处理"><a href="#完善键盘处理" class="headerlink" title="完善键盘处理"></a>完善键盘处理</h2><h3 id="回车键和退格键"><a href="#回车键和退格键" class="headerlink" title="回车键和退格键"></a>回车键和退格键</h3><p>当敲击回车键和退格键时，我们王TTY缓冲区中写入“\n”和“\b”，然后在out_char中做出相应的处理，如下：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUBLIC</span> void in_process(TTY* p_tty, u32 key)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">char</span> output[<span class="number">2</span>] = &#123;<span class="string">'\0'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(key &amp; FLAG_EXT)) &#123;</span><br><span class="line">		put_key(p_tty, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> raw_code = key &amp; MASK_RAW;</span><br><span class="line">                <span class="keyword">switch</span>(raw_code) &#123;</span><br><span class="line">                <span class="keyword">case</span> ENTER:</span><br><span class="line">			put_key(p_tty, <span class="string">'\n'</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BACKSPACE:</span><br><span class="line">			put_key(p_tty, <span class="string">'\b'</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">。。。。。。</span><br><span class="line"><span class="keyword">PRIVATE</span> void put_key(TTY* p_tty, u32 key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p_tty-&gt;inbuf_count &lt; TTY_IN_BYTES) &#123;</span><br><span class="line">		*(p_tty-&gt;p_inbuf_head) = key;</span><br><span class="line">		p_tty-&gt;p_inbuf_head++;</span><br><span class="line">		<span class="keyword">if</span> (p_tty-&gt;p_inbuf_head == p_tty-&gt;in_buf + TTY_IN_BYTES) &#123;</span><br><span class="line">			p_tty-&gt;p_inbuf_head = p_tty-&gt;in_buf;</span><br><span class="line">		&#125;</span><br><span class="line">		p_tty-&gt;inbuf_count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后修改out_char：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void out_char(CONSOLE* p_con, char ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">u8</span>* p_vmem = (u8*)(V_MEM_BASE + p_con-&gt;</span>cursor * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	switch(ch) &#123;</span><br><span class="line">	case <span class="string">'\n'</span>:</span><br><span class="line">		<span class="function"><span class="title">if</span> (p_con-&gt;</span><span class="function"><span class="title">cursor</span> &lt; p_con-&gt;</span>original_addr +</span><br><span class="line">		    <span class="function"><span class="title">p_con</span>-&gt;</span>v_mem_limit - SCREEN_WIDTH) &#123;</span><br><span class="line">			<span class="function"><span class="title">p_con</span>-&gt;</span><span class="function"><span class="title">cursor</span> = p_con-&gt;</span>original_addr + SCREEN_WIDTH * </span><br><span class="line">				((<span class="function"><span class="title">p_con</span>-&gt;</span><span class="function"><span class="title">cursor</span> - p_con-&gt;</span>original_addr) /</span><br><span class="line">				 SCREEN_WIDTH + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	case <span class="string">'\b'</span>:</span><br><span class="line">		<span class="function"><span class="title">if</span> (p_con-&gt;</span><span class="function"><span class="title">cursor</span> &gt; p_con-&gt;</span>original_addr) &#123;</span><br><span class="line">			<span class="function"><span class="title">p_con</span>-&gt;</span>cursor--;</span><br><span class="line">			*(p_vmem-<span class="number">2</span>) = <span class="string">' '</span>;</span><br><span class="line">			*(p_vmem-<span class="number">1</span>) = DEFAULT_CHAR_COLOR;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		<span class="function"><span class="title">if</span> (p_con-&gt;</span>cursor &lt;</span><br><span class="line">		    <span class="function"><span class="title">p_con</span>-&gt;</span><span class="function"><span class="title">original_addr</span> + p_con-&gt;</span>v_mem_limit - <span class="number">1</span>) &#123;</span><br><span class="line">			*p_vmem++ = ch;</span><br><span class="line">			*p_vmem++ = DEFAULT_CHAR_COLOR;</span><br><span class="line">			<span class="function"><span class="title">p_con</span>-&gt;</span>cursor++;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">while</span> (p_con-&gt;</span><span class="function"><span class="title">cursor</span> &gt;= p_con-&gt;</span>current_start_addr + SCREEN_SIZE) &#123;</span><br><span class="line">		scroll_screen(p_con, SCR_DN);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flush(p_con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================================================================*</span></span><br><span class="line"><span class="comment">                           flush</span></span><br><span class="line"><span class="comment">*======================================================================*/</span></span><br><span class="line">PRIVATE void flush(CONSOLE* p_con)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="title">set_cursor</span>(p_con-&gt;</span>cursor);</span><br><span class="line">        <span class="function"><span class="title">set_video_start_addr</span>(p_con-&gt;</span>current_start_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到回车键直接把光标挪到了下一行的开头，而退格键则把光标挪到上一个字符的位置，并在那里写一个空格，以便清除原来的字符。<br>由于不断的回车会让光标快速的移动到屏幕的底端。所以在这里还要判断光标是否已经移出了屏幕，如果是的话将会触发屏幕滚动。<br>另外，输出的任何类型的字符时，都做了边界检验，以防止影响到别的控制台，甚至试图写到显存之外的内存。<br>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/FkeaLFCf41.png?imageslim" alt="mark"></p>
<h1 id="区分任务和用户进程"><a href="#区分任务和用户进程" class="headerlink" title="区分任务和用户进程"></a>区分任务和用户进程</h1><p>前面的TTY我们称之为任务，A、B、C则为用户进程。在具体的实现上，让用户进程运行在ring3，任务继续留在ring1。如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/jfAk5EdG4E.png?imageslim" alt="mark"></p>
<h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><h2 id="为进程指定TTY"><a href="#为进程指定TTY" class="headerlink" title="为进程指定TTY"></a>为进程指定TTY</h2><p>当某个进程调用printf时，操作系统必须知道往哪个控制台输出才行。而当系统调用发生,ring3跳入ring0时，系统只能知道当前系统调用是由哪个进程触发的。所以我们必须为每个进程指定一个与之相对应的TTY，这可以通过在进程表中增加一个成员来实现。</p>
<h2 id="printf（）的实现"><a href="#printf（）的实现" class="headerlink" title="printf（）的实现"></a>printf（）的实现</h2><p>printf()的实现并不简单，首先是它的参数个数和类型都可变，而且其表示格式的参数形式多样，在printf()中。都要加以识别。<br>下面我们先实现printf（）只支持%X一种格式。如下：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> printf(const <span class="built_in">char</span> *<span class="keyword">fmt</span>,...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="built_in">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    va_list arg=(va_list)((<span class="built_in">char</span>*)(&amp;<span class="keyword">fmt</span>)+<span class="number">4</span>);</span><br><span class="line">    i=vsprintf(buf,<span class="keyword">fmt</span>,arg);</span><br><span class="line">    <span class="built_in">write</span>(buf,i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>增加一个系统调用的过程如下所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/K034Hb39cd.png?imageslim" alt="mark"></p>
<h2 id="使用print分（）"><a href="#使用print分（）" class="headerlink" title="使用print分（）"></a>使用print分（）</h2><p>make运行结果如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/GgE795K4E4.png?imageslim" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 于渊 </tag>
            
            <tag> 系统调用 </tag>
            
            <tag> 显示器 </tag>
            
            <tag> TTY </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》输入输出系统（5-1）]]></title>
      <url>/2018/03/06/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%EF%BC%885-1%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h1><p>操作系统需要交互，首先就是键盘</p>
<h2 id="从中断开始：键盘的初体验"><a href="#从中断开始：键盘的初体验" class="headerlink" title="从中断开始：键盘的初体验"></a>从中断开始：键盘的初体验</h2><a id="more"></a>
<p>因为8259A的IRQ1就是键盘，现在我们写一个键盘的处理程序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">keyboard_handler</span><span class="params">(<span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    disp_str(<span class="string">"*"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个结果就是每按一次键盘，就会打印一个星号。<br>然后添加中断处理程序，并打开键盘中断：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">PUBLIC</span> <span class="selector-tag">void</span> <span class="selector-tag">init_keyboard</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">put_irq_handler</span>(KEYBOARD_IRD,keyboard_handler);<span class="comment">/*设定键盘中断程序*/</span></span><br><span class="line">    <span class="selector-tag">enable_irq</span>(KEYBOARD_IRQ);<span class="comment">/*开键盘中断*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在proto.h中声明init_keyboard()并调用它。<br>make之后，运行结果如下。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/gChGbh378K.png?imageslim" alt="mark"><br>然后问题出现了，按了一次以后就没法再按出星号了。</p>
<h2 id="AT、PS-2键盘"><a href="#AT、PS-2键盘" class="headerlink" title="AT、PS/2键盘"></a>AT、PS/2键盘</h2><p>下图左边是PS/2键盘的接口，右边是AT键盘的接口，现在主流的都是USB的了。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/gIeCdjfFDb.png?imageslim" alt="mark"></p>
<h2 id="键盘敲击的过程"><a href="#键盘敲击的过程" class="headerlink" title="键盘敲击的过程"></a>键盘敲击的过程</h2><p>在键盘中存在一个叫做键盘编码器的芯片，它通常是Intel 8048以及兼容芯片，作用是监视键盘的输入，并把适当的数据传送给计算机。另外在计算机主板上还有一个键盘控制器，用来接受和解码来自键盘的数据，并与8259A以及软件等进行通信。如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/971LKKd47A.png?imageslim" alt="mark"><br>敲击键盘有两个方面的含义：动作和内容。动作有三类:按下、保持按下以及放开；内容则是键盘上的不同的键.8048既要反应“哪个”安检产生动作，还要反映产生了什么内容。<br>敲击键盘产生的编码被称为扫描码，当一个键被按下或者保持按下时，将会产生Make Code，当弹起时，产生Break Code。当8048检测到一个键的动作，会把相应的扫描码发送给8042，8042会把它转换成相应的扫描码，并将其放置在缓冲区，然后8042告诉8259A产生中断（IRQ1）。如果此时键盘又有新的键被按下，8042将不再接受，一直到缓冲区被清空。<br>所以我们只能按下一次就没有反应了，因为缓冲区的内容没有被取走。<br>为了了解如何从缓冲区中读取扫描码，我们要学习8042：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/cGCLhfbcFe.png?imageslim" alt="mark"><br>对于输入和输出缓冲区，可以用in和out指令来进行相应的读取操作。如下，在keyboard_handler中添加：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_byte(<span class="number">0</span>x60)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/bE4IHjKLEE.png?imageslim" alt="mark"><br>我们发现结果是16进制数，所以我们用如下表格建立对应关系，即可看到想要的结果了：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/DHI5dH5C4c.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/aCG2dIBbCC.png?imageslim" alt="mark"></p>
<h2 id="用数组表示扫描码"><a href="#用数组表示扫描码" class="headerlink" title="用数组表示扫描码"></a>用数组表示扫描码</h2><p>扫描码是一些数字，我们建立一个数组，以扫描码为下标，对应的元素就是相应的字符。数组是3个值一组，三个值是单独按某键、Shift+某键和有0xE0前缀扫描码对应的字符。Esc、Enter被定义成不冲突的宏即可：<br><figure class="highlight ruleslanguage"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">u32 keymap[NR_SCAN_CODES * MAP_COLS] = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* scan-code			!Shift		Shift		E0 XX	*/</span></span><br><span class="line"><span class="comment">/* ==================================================================== */</span></span><br><span class="line"><span class="comment">/* 0x00 - none		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x01 - ESC		*/</span>	ESC,		ESC,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x02 - '1'		*/</span>	<span class="string">'1'</span>,		<span class="string">'!'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x03 - '2'		*/</span>	<span class="string">'2'</span>,		<span class="string">'@'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x04 - '3'		*/</span>	<span class="string">'3'</span>,		<span class="string">'#'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x05 - '4'		*/</span>	<span class="string">'4'</span>,		<span class="string">'$'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x06 - '5'		*/</span>	<span class="string">'5'</span>,		<span class="string">'%'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x07 - '6'		*/</span>	<span class="string">'6'</span>,		<span class="string">'^'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x08 - '7'		*/</span>	<span class="string">'7'</span>,		<span class="string">'&amp;'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x09 - '8'		*/</span>	<span class="string">'8'</span>,		<span class="string">'*'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x0A - '9'		*/</span>	<span class="string">'9'</span>,		<span class="string">'('</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x0B - '0'		*/</span>	<span class="string">'0'</span>,		<span class="string">')'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x0C - '-'		*/</span>	<span class="string">'-'</span>,		<span class="string">'_'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x0D - '='		*/</span>	<span class="string">'='</span>,		<span class="string">'+'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x0E - BS		*/</span>	BACKSPACE,	BACKSPACE,	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x0F - TAB		*/</span>	TAB,		TAB,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x10 - 'q'		*/</span>	<span class="string">'q'</span>,		<span class="string">'Q'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x11 - 'w'		*/</span>	<span class="string">'w'</span>,		<span class="string">'W'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x12 - 'e'		*/</span>	<span class="string">'e'</span>,		<span class="string">'E'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x13 - 'r'		*/</span>	<span class="string">'r'</span>,		<span class="string">'R'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x14 - 't'		*/</span>	<span class="string">'t'</span>,		<span class="string">'T'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x15 - 'y'		*/</span>	<span class="string">'y'</span>,		<span class="string">'Y'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x16 - 'u'		*/</span>	<span class="string">'u'</span>,		<span class="string">'U'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x17 - 'i'		*/</span>	<span class="string">'i'</span>,		<span class="string">'I'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x18 - 'o'		*/</span>	<span class="string">'o'</span>,		<span class="string">'O'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x19 - 'p'		*/</span>	<span class="string">'p'</span>,		<span class="string">'P'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x1A - '['		*/</span>	<span class="string">'['</span>,		<span class="string">'&#123;'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x1B - ']'		*/</span>	<span class="string">']'</span>,		<span class="string">'&#125;'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x1C - CR/LF		*/</span>	ENTER,		ENTER,		PAD_ENTER,</span><br><span class="line"><span class="comment">/* 0x1D - l. Ctrl	*/</span>	CTRL_L,		CTRL_L,		CTRL_R,</span><br><span class="line"><span class="comment">/* 0x1E - 'a'		*/</span>	<span class="string">'a'</span>,		<span class="string">'A'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x1F - 's'		*/</span>	<span class="string">'s'</span>,		<span class="string">'S'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x20 - 'd'		*/</span>	<span class="string">'d'</span>,		<span class="string">'D'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x21 - 'f'		*/</span>	<span class="string">'f'</span>,		<span class="string">'F'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x22 - 'g'		*/</span>	<span class="string">'g'</span>,		<span class="string">'G'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x23 - 'h'		*/</span>	<span class="string">'h'</span>,		<span class="string">'H'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x24 - 'j'		*/</span>	<span class="string">'j'</span>,		<span class="string">'J'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x25 - 'k'		*/</span>	<span class="string">'k'</span>,		<span class="string">'K'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x26 - 'l'		*/</span>	<span class="string">'l'</span>,		<span class="string">'L'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x27 - ';'		*/</span>	<span class="string">';'</span>,		<span class="string">':'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x28 - '\''		*/</span>	<span class="string">'\''</span>,		<span class="string">'"'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x29 - '`'		*/</span>	<span class="string">'`'</span>,		<span class="string">'~'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x2A - l. SHIFT	*/</span>	SHIFT_L,	SHIFT_L,	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x2B - '\'		*/</span>	<span class="string">'\\'</span>,		<span class="string">'|'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x2C - 'z'		*/</span>	<span class="string">'z'</span>,		<span class="string">'Z'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x2D - 'x'		*/</span>	<span class="string">'x'</span>,		<span class="string">'X'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x2E - 'c'		*/</span>	<span class="string">'c'</span>,		<span class="string">'C'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x2F - 'v'		*/</span>	<span class="string">'v'</span>,		<span class="string">'V'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x30 - 'b'		*/</span>	<span class="string">'b'</span>,		<span class="string">'B'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x31 - 'n'		*/</span>	<span class="string">'n'</span>,		<span class="string">'N'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x32 - 'm'		*/</span>	<span class="string">'m'</span>,		<span class="string">'M'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x33 - ','		*/</span>	<span class="string">','</span>,		<span class="string">'&lt;'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x34 - '.'		*/</span>	<span class="string">'.'</span>,		<span class="string">'&gt;'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x35 - '/'		*/</span>	<span class="string">'/'</span>,		<span class="string">'?'</span>,		PAD_SLASH,</span><br><span class="line"><span class="comment">/* 0x36 - r. SHIFT	*/</span>	SHIFT_R,	SHIFT_R,	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x37 - '*'		*/</span>	<span class="string">'*'</span>,		<span class="string">'*'</span>,    	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x38 - ALT		*/</span>	ALT_L,		ALT_L,  	ALT_R,</span><br><span class="line"><span class="comment">/* 0x39 - ' '		*/</span>	<span class="string">' '</span>,		<span class="string">' '</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x3A - CapsLock	*/</span>	CAPS_LOCK,	CAPS_LOCK,	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x3B - F1		*/</span>	F1,		F1,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x3C - F2		*/</span>	F2,		F2,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x3D - F3		*/</span>	F3,		F3,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x3E - F4		*/</span>	F4,		F4,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x3F - F5		*/</span>	F5,		F5,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x40 - F6		*/</span>	F6,		F6,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x41 - F7		*/</span>	F7,		F7,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x42 - F8		*/</span>	F8,		F8,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x43 - F9		*/</span>	F9,		F9,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x44 - F10		*/</span>	F10,		F10,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x45 - NumLock	*/</span>	NUM_LOCK,	NUM_LOCK,	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x46 - ScrLock	*/</span>	SCROLL_LOCK,	SCROLL_LOCK,	<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x47 - Home		*/</span>	PAD_HOME,	<span class="string">'7'</span>,		HOME,</span><br><span class="line"><span class="comment">/* 0x48 - CurUp		*/</span>	PAD_UP,		<span class="string">'8'</span>,		UP,</span><br><span class="line"><span class="comment">/* 0x49 - PgUp		*/</span>	PAD_PAGEUP,	<span class="string">'9'</span>,		PAGEUP,</span><br><span class="line"><span class="comment">/* 0x4A - '-'		*/</span>	PAD_MINUS,	<span class="string">'-'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x4B - Left		*/</span>	PAD_LEFT,	<span class="string">'4'</span>,		<span class="keyword">LEFT</span>,</span><br><span class="line"><span class="comment">/* 0x4C - MID		*/</span>	PAD_MID,	<span class="string">'5'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x4D - Right		*/</span>	PAD_RIGHT,	<span class="string">'6'</span>,		<span class="keyword">RIGHT</span>,</span><br><span class="line"><span class="comment">/* 0x4E - '+'		*/</span>	PAD_PLUS,	<span class="string">'+'</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x4F - End		*/</span>	PAD_END,	<span class="string">'1'</span>,		<span class="keyword">END</span>,</span><br><span class="line"><span class="comment">/* 0x50 - Down		*/</span>	PAD_DOWN,	<span class="string">'2'</span>,		DOWN,</span><br><span class="line"><span class="comment">/* 0x51 - PgDown	*/</span>	PAD_PAGEDOWN,	<span class="string">'3'</span>,		PAGEDOWN,</span><br><span class="line"><span class="comment">/* 0x52 - Insert	*/</span>	PAD_INS,	<span class="string">'0'</span>,		INSERT,</span><br><span class="line"><span class="comment">/* 0x53 - Delete	*/</span>	PAD_DOT,	<span class="string">'.'</span>,		<span class="keyword">DELETE</span>,</span><br><span class="line"><span class="comment">/* 0x54 - Enter		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x55 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x56 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x57 - F11		*/</span>	F11,		F11,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x58 - F12		*/</span>	F12,		F12,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x59 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x5A - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x5B - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		GUI_L,	</span><br><span class="line"><span class="comment">/* 0x5C - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		GUI_R,	</span><br><span class="line"><span class="comment">/* 0x5D - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		APPS,	</span><br><span class="line"><span class="comment">/* 0x5E - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x5F - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x60 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x61 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x62 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x63 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x64 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x65 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x66 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x67 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x68 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x69 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x6A - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x6B - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x6C - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x6D - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x6E - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x6F - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x70 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x71 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x72 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x73 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x74 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x75 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x76 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x77 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x78 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x78 - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x7A - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x7B - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x7C - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x7D - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,	</span><br><span class="line"><span class="comment">/* 0x7E - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span>,</span><br><span class="line"><span class="comment">/* 0x7F - ???		*/</span>	<span class="number">0</span>,		<span class="number">0</span>,		<span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="键盘输入缓冲区"><a href="#键盘输入缓冲区" class="headerlink" title="键盘输入缓冲区"></a>键盘输入缓冲区</h2><p>这个是用来放置中断例程接受到的扫描码。为了解决当扫描码不止一个字符时的问题。<br>它的用法如图所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/I04cE2C65A.png?imageslim" alt="mark"><br>白色框表示空闲字节，灰色框表示已用字节。</p>
<h2 id="用新加的任务处理键盘操作"><a href="#用新加的任务处理键盘操作" class="headerlink" title="用新加的任务处理键盘操作"></a>用新加的任务处理键盘操作</h2><p>终端任务是要处理屏幕输出等内容的，为了简化我们现在只是不停的调用keyboard_read()：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void task_tty<span class="comment">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span><span class="comment">(1)</span>&#123;</span><br><span class="line">        keyboard_read<span class="comment">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>keyboard_read()首先判断kb_in.count是否为0，如果不为0表明缓冲区中有扫描码，就开始读取。</p>
<h2 id="解析扫描码"><a href="#解析扫描码" class="headerlink" title="解析扫描码"></a>解析扫描码</h2><h3 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h3><p>因为键盘的键的功能是不一样的，有的是一种功能不是一个ASCII。我们先处理可以打印的<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void keyboard_read()</span><br><span class="line">&#123;</span><br><span class="line">	u8	<span class="keyword">scan_code;</span></span><br><span class="line"><span class="keyword">	</span>char	output[<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">	int	make<span class="comment">;	/* TRUE: make;  FALSE: break. */</span></span><br><span class="line"></span><br><span class="line">	memset(output, <span class="number">0</span>, <span class="number">2</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	if(kb_in.count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">disable_int();</span></span><br><span class="line"><span class="keyword">	</span>	<span class="keyword">scan_code </span>= *(kb_in.p_tail)<span class="comment">;</span></span><br><span class="line">		kb_in.p_tail++<span class="comment">;</span></span><br><span class="line">		if (kb_in.p_tail == kb_in.<span class="keyword">buf </span>+ KB_IN_BYTES) &#123;</span><br><span class="line">			kb_in.p_tail = kb_in.<span class="keyword">buf;</span></span><br><span class="line"><span class="keyword">	</span>	&#125;</span><br><span class="line">		kb_in.count--<span class="comment">;</span></span><br><span class="line">		enable_int()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 下面开始解析扫描码 */</span></span><br><span class="line">		if (<span class="keyword">scan_code </span>== <span class="number">0xE1</span>) &#123;</span><br><span class="line">			<span class="comment">/* 暂时不做任何操作 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		else if (<span class="keyword">scan_code </span>== <span class="number">0xE0</span>) &#123;</span><br><span class="line">			<span class="comment">/* 暂时不做任何操作 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;	<span class="comment">/* 下面处理可打印字符 */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 首先判断Make Code 还是 Break Code */</span></span><br><span class="line">			make = (<span class="keyword">scan_code </span>&amp; FLAG_BREAK ? FALSE : TRUE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 如果是Make Code 就打印，是 Break Code 则不做处理 */</span></span><br><span class="line">			if(make) &#123;</span><br><span class="line">				output[<span class="number">0</span>] = keymap[(<span class="keyword">scan_code&amp;0x7F)*MAP_COLS];</span></span><br><span class="line"><span class="keyword">	</span>			<span class="keyword">disp_str(output);</span></span><br><span class="line"><span class="keyword">	</span>		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* disp_int(scan_code); */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的总体思想是0xE0和0xE1单独处理，其余都是单字节的，运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/Fj85fFJBLC.png?imageslim" alt="mark"></p>
<h3 id="处理shift、alt、ctrl"><a href="#处理shift、alt、ctrl" class="headerlink" title="处理shift、alt、ctrl"></a>处理shift、alt、ctrl</h3><p>先对这三个按键的状态进行判断，因为有左右之分，所以有6个键，当按下shift_l时，相应的变量就变为TRUE,如果立即释放则变为FALSE。如果if(shift_l||shift_r)成立，则表示左shift被按下且未被释放，此时colum值变为1。<br>运行一下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/AKF3268ahI.png?imageslim" alt="mark"><br>对于其他功能键，我们统一放在in_process()中，并在不可打印的字符的定义中，都加一个FLAG_EXT。运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180306/mfigfdIkE7.png?imageslim" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 键盘交互 </tag>
            
            <tag> AT、PS/2键盘 </tag>
            
            <tag> 键盘扫描码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》进程（4-2）]]></title>
      <url>/2018/03/04/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%9B%E7%A8%8B%EF%BC%884-2%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>前面我们完成了ring0到ring1的跳转，它可以随时被中断，可以在中断处理程序完成之后被恢复。进程此时已经有了两种状态：运行和睡眠。接着我们只需要让其中一个进程处在运行状态，其余进程处在睡眠状态即可。</p>
<h2 id="添加一个进程体"><a href="#添加一个进程体" class="headerlink" title="添加一个进程体"></a>添加一个进程体</h2><a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        disp_str(<span class="string">"B"</span>);</span><br><span class="line">        disp_int(i++);</span><br><span class="line">        disp_str(<span class="string">"."</span>);</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程表初始化代码扩充"><a href="#进程表初始化代码扩充" class="headerlink" title="进程表初始化代码扩充"></a>进程表初始化代码扩充</h2><p>进程之间的区别真的不大。每一次循环的不同在于，从TASK结构中读取不同的任务入口地址\堆栈栈顶和进程名，然后赋给相应的进程表项。需要注意以下两点：</p>
<ul>
<li>由于堆栈是从高地址到低地址生长的，所以在给每一个进程分配堆栈空间的时候，也是从高地址往低地址进行。</li>
<li>每一个进程都在GDT中分配一个描述符用来对应进程的LDT。<h2 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h2>因为每一个进程都会在GDT中对应一个LDT描述符。于是在for循环中，我们将每个进程表项中的成员p_proc-&gt;ldt_sel赋值。下面是初始化LDT：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i<span class="comment">;</span></span><br><span class="line">	PROCESS* p_proc	= proc_table<span class="comment">;</span></span><br><span class="line">	u16 selector_ldt = INDEX_LDT_FIRST &lt;&lt; <span class="number">3</span><span class="comment">;</span></span><br><span class="line">	for(i=<span class="number">0</span><span class="comment">;i&lt;NR_TASKS;i++)&#123;</span></span><br><span class="line">		init_descriptor(&amp;gdt[selector_ldt&gt;&gt;<span class="number">3</span>],</span><br><span class="line">				vir2phys(seg2phys(SELECTOR_KERNEL_DS),</span><br><span class="line">					proc_table[i].ldts),</span><br><span class="line">				LDT_SIZE * sizeof(DESCRIPTOR) - <span class="number">1</span>,</span><br><span class="line">				DA_LDT)<span class="comment">;</span></span><br><span class="line">		p_proc++<span class="comment">;</span></span><br><span class="line">		selector_ldt += <span class="number">1</span> &lt;&lt; <span class="number">3</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改中断程序"><a href="#修改中断程序" class="headerlink" title="修改中断程序"></a>修改中断程序</h2><p>一个进程由sleep状态变为run状态，无非是将esp指向进程表项的开始处，然后在执行lldt之后精力一系列pop指令恢复各个寄存器的值。一切信息都包含在进程表中，所以，要想恢复不同的进程，只需要将esp指向不同的进程表就可以了。<br>在离开内核栈的时候，执行如下语句：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">esp</span>,[p_proc_ready]</span><br></pre></td></tr></table></figure></p>
<p>全局变量p_proc_ready是指向进程表结构的指针，我们只需要在这一句执行之前把它赋予不同的值就可以了。<br>因为这部分即关于时钟中断，又关与进程调度。所以我们可以创建一个clock.c，也可以创建一个proc.c。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">clock_handler</span><span class="params">(<span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    disp_str(<span class="string">"#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>make之后，结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/H51aAdE348.png?imageslim" alt="mark"><br>接着进行进程切换：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC <span class="keyword">void</span> <span class="title">clock_handler</span><span class="params">(<span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	disp_str(<span class="string">"#"</span>);</span><br><span class="line">	p_proc_ready++;</span><br><span class="line">	<span class="keyword">if</span> (p_proc_ready &gt;= proc_table + NR_TASKS)</span><br><span class="line">		p_proc_ready = proc_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一次我们让p_proc_ready指向进程表中的下一个表项，如果切换前已经到达进程表结尾则回到第一个表项。然后再make：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/gLFAfE6Cji.png?imageslim" alt="mark"><br>可以看到A和B交替出现。这说明第二个进程运行成。</p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>系统调用和API类似，当应用程序很多事做不了的时候，只能交给操作系统来做。所以一个事情，可能应用程序做了一部分，操作系统做一部分，这就涉及到特权级的问题了。<br>下面是本操作系统的运行过程：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/hl0CfKkie2.png?imageslim" alt="mark"></p>
<h2 id="实现一个简单的系统调用"><a href="#实现一个简单的系统调用" class="headerlink" title="实现一个简单的系统调用"></a>实现一个简单的系统调用</h2><p>我们通过实现get_tick()得到当前总共发生多少次时钟中断。设置一个全局变量ticks，每次发生一次时钟中断，它就加1.进程可以随时通过get_tick()这个系统调用来得到这个值。代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%include</span> <span class="string">"sconst.inc"</span></span><br><span class="line"></span><br><span class="line">_NR_get_ticks       <span class="built_in">equ</span> <span class="number">0</span> <span class="comment">; 要跟 global.c 中 sys_call_table 的定义相对应！</span></span><br><span class="line">INT_VECTOR_SYS_CALL <span class="built_in">equ</span> <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line"><span class="meta">global</span>	get_ticks <span class="comment">; 导出符号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">bits</span> <span class="number">32</span></span><br><span class="line">[<span class="meta">section</span> .text]</span><br><span class="line"></span><br><span class="line"><span class="symbol">get_ticks:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, _NR_get_ticks</span><br><span class="line">	<span class="keyword">int</span>	INT_VECTOR_SYS_CALL</span><br><span class="line">	<span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<h2 id="get-ticks的应用"><a href="#get-ticks的应用" class="headerlink" title="get_ticks的应用"></a>get_ticks的应用</h2><p>因为时钟中断发生的时间间隔是一定的，如果我们知道这个实践间隔，就可以用get_ticks函数来写一个判断时间的函数，进而代替delay()</p>
<h3 id="8253-8254-PIT"><a href="#8253-8254-PIT" class="headerlink" title="8253/8254 PIT"></a>8253/8254 PIT</h3><p>中断的发生实际上是由一个被称为PIT（Programmable Interval Timer）的芯片来触发的。在AT以及以后又Intel 8253换为Intel 8254。<br>8253有三个计数器：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/Kl8lbk2jEg.png?imageslim" alt="mark"><br>从上可知，中断实际是由8253的Counter0产生的。<br>计数器有一个输入频率，在PC上是1193180Hz，在每一个时钟周期，计数器值会减1，当减到0就会触发一个输出。由于计数器是16位的，所以最大值是65535，因此，默认的时钟中断的发生频率是1193180/65536~18.2Hz。<br>我们可以通过编程来控制8253.比如，想让系统每10ms产生一次中断，也就是让输出频率为100Hz，那么需要为计数器赋值为1193180/100~11932.<br>因为控制8253是通过端口的写操作完成的。如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/a83d7E9Dki.png?imageslim" alt="mark"><br>以下是8253模式控制寄存器<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/7I9a6el9KE.png?imageslim" alt="mark"><br>也就是端口43h写入寄存器的格式。下面是计数器模式位：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/k1EG6k1AfE.png?imageslim" alt="mark"><br>下面是读/写/锁位:<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/4l3l5Jl7kk.png?imageslim" alt="mark"><br>下面是计数器选择位：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/1IBI0KlEgI.png?imageslim" alt="mark"><br>make一下，运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/66klAkE9cA.png?imageslim" alt="mark"></p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="避免对称—进程的节奏感"><a href="#避免对称—进程的节奏感" class="headerlink" title="避免对称—进程的节奏感"></a>避免对称—进程的节奏感</h2><p>前面的进程延迟相同，现在将其改变下A、B、C三个的延迟分别为300、900、1500ms，运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/6L3b4dhc45.png?imageslim" alt="mark"><br>从这个我们可以想到，通过延迟的不同设置不同的优先级。<br>通过“轻重缓急”反应在时间上，来表达优先级调度，最重要的事情应该被赋予更高的优先级，应该给予更多的时间。<br>我们给每一个进程都添加一个变量，在一段时间 的开头，这个变量的值又大又下，进程获得一个运行周期，这个变量就减1，当减到0，此进程就不再获得执行的机会，指导所有进程都为0。<br>由于每一次进程调度的时候只有某一个进程的ticks会减少1，所以总共调度的次数应该是3个进程的ticks之和（150+50+30）=230。所以:</p>
<ul>
<li>进程A执行循环的次数为：（100+20x2+30x3）/20=230/20=11.5次</li>
<li>进程B执行循环的次数为：（0+20x2+30x3）/20=230/20=6.5次</li>
<li>进程C执行循环的次数为：（0+0x2+30x3）/20=230/20=4.5次<br>将各个进程的延迟时间改为10m后，make一下，运行如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180305/GiBeb7Lcef.png?imageslim" alt="mark"></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进程调度 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 8253/8254 </tag>
            
            <tag> PIT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》进程（4-1）]]></title>
      <url>/2018/03/04/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%BF%9B%E7%A8%8B%EF%BC%884-1%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h2><p>系统中运行的若干进程可以类比成一个人在一天内要做的若干样工作：总体看来，每样工作相对独立，并可产生某种结果；从细节上看，每样工作都具有自己的办法、工具和需要的资源；从时间上看，每一个时刻只能有一项工作正在处理中，各项工作可以轮换来做，这对于最终结果没有影响。<br>进程类似，从宏观上看，它有自己的目标，或者说功能，同时又能受控于进程调度模块，从微观来看，她可以利用系统的资源，有自己的代码和数据，同时拥有自己的堆栈；进程需要被调度，就好比一个人轮换做不同的工作。<br><a id="more"></a><br>示意图如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/bh7mml4L4m.png?imageslim" alt="mark"></p>
<h2 id="形成进程的必要考虑"><a href="#形成进程的必要考虑" class="headerlink" title="形成进程的必要考虑"></a>形成进程的必要考虑</h2><p>因为进程数是多余CPU数的，于是在同一时刻，总是有“正在运行的”和“正在休息的”进程。所以，对于“正在休息的”进程，我们需要让它在重新醒来的时候记住自己挂起之前的状态，以便让原来的任务继续执行下去。<br>所以，我们要一个数据结构记录一个进程的状态，在进程要被挂起的时候，进程信息就被写入这个数据结构，等到进程重新启动的时候，这个信息重新被读出来。如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/aID0CgLFCF.png?imageslim" alt="mark"></p>
<h2 id="最简单的进程"><a href="#最简单的进程" class="headerlink" title="最简单的进程"></a>最简单的进程</h2><p>我们设想，当一个进程运行的时候，突然发生了时钟中断，特权级从ring1跳到ring0，开始执行时钟中断处理程序，中断处理程序这时调用进程调度模块，指定下一个应该运行的程序，当中断处理程序结束时，下一个进程准备就绪并开始运行，特权级又从ring0跳回ring1。我们把这个过程按照时间顺序整理如下：</p>
<ol>
<li>进程A运行中</li>
<li>时钟中断发生，ring1-&gt;ring0，时钟中断处理程序启动。</li>
<li>进程调度，下一个应该运行的进程B被指定</li>
<li>进程B被恢复，ring0-&gt;ring1</li>
<li>进程B运行中。<br>而要想实现这些功能，我们必须完成的应该有以下几项：</li>
<li>时钟中断处理程序</li>
<li>进程调度模块</li>
<li>两个进程<br>进程切换图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/6eI6DB9GfB.png?imageslim" alt="mark"><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="进程控制块PCB（也叫做进程表）"><a href="#进程控制块PCB（也叫做进程表）" class="headerlink" title="进程控制块PCB（也叫做进程表）"></a>进程控制块PCB（也叫做进程表）</h3>它相当于进程的提纲，通过PCB我们可以很方便的进行进程管理。<br>因为我们会有跟多个PCB所以会形成如图所示的进程表：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/97im0kF4lK.png?imageslim" alt="mark"><h3 id="进程栈和内核栈"><a href="#进程栈和内核栈" class="headerlink" title="进程栈和内核栈"></a>进程栈和内核栈</h3>当寄存器的值已经被保存到进程表内，进程调度模块就开始执行了，寄存器被压到进程表之后，esp汁指向进程表某个位置的。为了避免错误的出现，一定要将esp指向专门的内核栈区域。这样在短短的进程切换过程中，esp的位置出现在3个不同的区域：</li>
</ol>
<ul>
<li>进程栈：进程运行时自身的堆栈</li>
<li>进程表：存储进程状态信息的数据结构</li>
<li>内核栈：进程调度模块运行时使用的堆栈<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/ibf2DLm9H4.png?imageslim" alt="mark"><h3 id="第一步-ring0-gt-ring1"><a href="#第一步-ring0-gt-ring1" class="headerlink" title="第一步:ring0-&gt;ring1"></a>第一步:ring0-&gt;ring1</h3></li>
</ul>
<p>在开始第一个进程时，我们用iretd来实现由ring0-&gt;ring1的转移，一旦转移成功，便可以认为已经在一个进程中运行了。如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">restart:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">esp</span>, [p_proc_ready]</span><br><span class="line">	<span class="keyword">lldt</span>	[<span class="built_in">esp</span> + P_LDT_SEL]</span><br><span class="line">	<span class="keyword">lea</span>	<span class="built_in">eax</span>, [<span class="built_in">esp</span> + P_STACKTOP]</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dword</span> [tss + TSS3_S_SP0], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">restart_reenter:</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">dword</span> [k_reenter]</span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">gs</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">fs</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">es</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">ds</span></span><br><span class="line">	<span class="keyword">popad</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">esp</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">iretd</span></span><br></pre></td></tr></table></figure></p>
<p>其中，指针p_proc_ready是指向PCB的指针，PCB的信息被结构体s_proc存储。当要恢复一个进程时，便将esp指向这个结构体的开始处，然后运行一系列的pop命令，将寄存器值弹出。进程表的开始位置结构图如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/b8Lfe9ELli.png?imageslim" alt="mark"></p>
<h3 id="时钟中断处理程序"><a href="#时钟中断处理程序" class="headerlink" title="时钟中断处理程序"></a>时钟中断处理程序</h3><p>我们只完成最简单的ring0到ring1的转移，做到这一点用一个iretd指令就够了</p>
<h3 id="PCB、进程体、GDT、TSS"><a href="#PCB、进程体、GDT、TSS" class="headerlink" title="PCB、进程体、GDT、TSS"></a>PCB、进程体、GDT、TSS</h3><p>既然在进程开始之前要用到进程表中各项的值，我们应该先将这些值进行初始化，只要制定好各段寄存器、eip、esp以及eflags，它就可以正常运行，至于其他寄存器是用不到的，所以我们得出这样的必须初始化的寄存器列表：cs、ds、es、fs、gs、ss、esp、eip、eflags。<br>在Loader中，gs对应的描述符DPL为3，所以进程中的代码是有访问权限访问显存的；其他段寄存器对应的描述符基地址和段界限与先前的段寄存器对应的秒速恢复基地址金和段界限相同，只是改变它们的RPL和TI，以表示它们运行的特权级。<br>进程表和与之相关的TSS的对应关系如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/GbKcmjGH0d.png?imageslim" alt="mark"><br>主要分为三个部分：</p>
<ol>
<li>进程表和GDT。进程表内的LDTSelector对应的GDT中的一个描述符，而这个描述符所指向的内存空间就存在进程表内。</li>
<li>进程表和进程。进程表就是进程的描述，进程运行过程中如果被中断，各个寄存器的值都会被保存进进程表中。但是，在我们的第一个进程开始之前，并不需要初始化太多内容，只需要知道进程的入口地址就足够了。</li>
<li>GDT和TSS。GDT中需要有一个描述符来对应TSS，需要事先初始化这个描述符。<br>接着开始具体初始化，<br>第一步，首先准备一个小的进程体：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		disp_str(<span class="string">"A"</span>);</span><br><span class="line">		disp_int(i++);</span><br><span class="line">		disp_str(<span class="string">"."</span>);</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个进程体（函数）的功能就是打印一个字符并显示数字，并稍微停顿。<br>接着我们要注视掉hlt，并让程序跳转到kernel_main()中。<br>delay()函数也就是一个循环嵌套。<br>第二步，初始化进程表。<br>首先收进程表的结构定义：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">s_stackframe</span></span> &#123;</span><br><span class="line">	<span class="built_in">u32</span>	gs;		<span class="comment">/* \                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	fs;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	es;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	ds;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	edi;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	esi;		<span class="comment">/* | pushed by save()                   */</span></span><br><span class="line">	<span class="built_in">u32</span>	ebp;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	kernel_esp;	<span class="comment">/* &lt;- 'popad' will ignore it            */</span></span><br><span class="line">	<span class="built_in">u32</span>	ebx;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	edx;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	ecx;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	eax;		<span class="comment">/* /                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	retaddr;	<span class="comment">/* return addr for kernel.asm::save()   */</span></span><br><span class="line">	<span class="built_in">u32</span>	eip;		<span class="comment">/* \                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	cs;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	eflags;		<span class="comment">/* | pushed by CPU during interrupt     */</span></span><br><span class="line">	<span class="built_in">u32</span>	esp;		<span class="comment">/* |                                    */</span></span><br><span class="line">	<span class="built_in">u32</span>	ss;		<span class="comment">/* /                                    */</span></span><br><span class="line">&#125;STACK_FRAME;</span><br></pre></td></tr></table></figure></p>
<p>然后在global.c中声明一个进程表：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC PROCESS proc_table[NR_TASKS]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其中NR_TASKS定义了最大允许进程，我们将其设为1。为了以后扩展，我们将其还是声明成一个数组。<br>接着就初始化进程表：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PROCESS* p_proc	= proc_table;</span><br><span class="line"></span><br><span class="line">	p_proc-&gt;ldt_sel	= SELECTOR_LDT_FIRST;</span><br><span class="line">	memcpy(&amp;p_proc-&gt;ldts[<span class="number">0</span>], &amp;gdt[SELECTOR_KERNEL_CS&gt;&gt;<span class="number">3</span>], sizeof(DESCRIPTOR));</span><br><span class="line">	p_proc-&gt;ldts[<span class="number">0</span>].attr1 = DA_C | <span class="type">PRIVILEGE_TASK</span> &lt;&lt; <span class="number">5</span>;	// <span class="built_in">change</span> the DPL</span><br><span class="line">	memcpy(&amp;p_proc-&gt;ldts[<span class="number">1</span>], &amp;gdt[SELECTOR_KERNEL_DS&gt;&gt;<span class="number">3</span>], sizeof(DESCRIPTOR));</span><br><span class="line">	p_proc-&gt;ldts[<span class="number">1</span>].attr1 = DA_DRW | <span class="type">PRIVILEGE_TASK</span> &lt;&lt; <span class="number">5</span>;	// <span class="built_in">change</span> the DPL</span><br><span class="line"></span><br><span class="line">	p_proc-&gt;regs.cs	= (<span class="number">0</span> &amp; SA_RPL_MASK &amp; SA_TI_MASK) | <span class="type">SA_TIL</span> | <span class="type">RPL_TASK</span>;</span><br><span class="line">	p_proc-&gt;regs.ds	= (<span class="number">8</span> &amp; SA_RPL_MASK &amp; SA_TI_MASK) | <span class="type">SA_TIL</span> | <span class="type">RPL_TASK</span>;</span><br><span class="line">	p_proc-&gt;regs.es	= (<span class="number">8</span> &amp; SA_RPL_MASK &amp; SA_TI_MASK) | <span class="type">SA_TIL</span> | <span class="type">RPL_TASK</span>;</span><br><span class="line">	p_proc-&gt;regs.fs	= (<span class="number">8</span> &amp; SA_RPL_MASK &amp; SA_TI_MASK) | <span class="type">SA_TIL</span> | <span class="type">RPL_TASK</span>;</span><br><span class="line">	p_proc-&gt;regs.ss	= (<span class="number">8</span> &amp; SA_RPL_MASK &amp; SA_TI_MASK) | <span class="type">SA_TIL</span> | <span class="type">RPL_TASK</span>;</span><br><span class="line">	p_proc-&gt;regs.gs	= (SELECTOR_KERNEL_GS &amp; SA_RPL_MASK) | <span class="type">RPL_TASK</span>;</span><br><span class="line">	p_proc-&gt;regs.eip= (u32)TestA;</span><br><span class="line">	p_proc-&gt;regs.esp= (u32) task_stack + STACK_SIZE_TOTAL;</span><br><span class="line">	p_proc-&gt;regs.eflags = <span class="number">0x1202</span>;	// <span class="keyword">IF</span>=<span class="number">1</span>, IOPL=<span class="number">1</span>, bit <span class="number">2</span> is always <span class="number">1.</span></span><br></pre></td></tr></table></figure></p>
<p>进程表的初始化主要有寄存器、LDTSelector和LDT。<br>LDTSelector被赋值为SELECTOR_LDT_FIRST。LDT中共有两个描述符，分别被初始化成内核代码段和内核数据段，只是改变一下DPL以让其运行在低的特权级下。<br>要初始化的寄存器比较多，其中eip指向TestA，这表名进程将从TestA的入口开始运行。<br>另外，esp指向了单独的栈，栈的大小为STACK_SIZE_TOTAL。<br>最后一行是设置eflags,0x1202恰好设置了IF位，并把IOPL设为1.这样进程就可以使用I/O指令，并且中断会在iretd执行时被打开。<br>第三步，准备GDT和TSS。<br>到此，只有TSS和它对应的描述符没有初始化了。在init_prot（），填充TSS以及对应的描述符。</p>
<h3 id="启动进程"><a href="#启动进程" class="headerlink" title="启动进程"></a>启动进程</h3><p>make以后，就运行成功了：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/97fg5aCG34.png?imageslim" alt="mark"></p>
<h3 id="第一个进程回顾"><a href="#第一个进程回顾" class="headerlink" title="第一个进程回顾"></a>第一个进程回顾</h3><p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180304/2gei9B2Gfa.png?imageslim" alt="mark"><br>从上面的进程启动的示意图可以看出，进程体TestA()在内核被LOADER放置到内存中之后就准备好了。</p>
<h2 id="第二步，丰富中断处理程序"><a href="#第二步，丰富中断处理程序" class="headerlink" title="第二步，丰富中断处理程序"></a>第二步，丰富中断处理程序</h2><h3 id="让时钟中断开始起作用"><a href="#让时钟中断开始起作用" class="headerlink" title="让时钟中断开始起作用"></a>让时钟中断开始起作用</h3><p>现在打开i8259.c的init_8259A(),同时设置EOI。为了让中断显示出来，我们将通过改变屏幕第0行、第0列字符的方式来说明中断例程正在运行。</p>
<h3 id="现场的保护和恢复"><a href="#现场的保护和恢复" class="headerlink" title="现场的保护和恢复"></a>现场的保护和恢复</h3><p>使用进程表是为了保存进程的状态，以便中断处理程序完成之后需要被恢复的进程能够被顺利地恢复。在进程表中，我们为每一个寄存器预留了位置，以便将其保存下来，这样就可以在进程调度模块中尽情的使用这些寄存器，而不必担心会对进程产生不良影响。</p>
<h3 id="赋值tss-esp0"><a href="#赋值tss-esp0" class="headerlink" title="赋值tss.esp0"></a>赋值tss.esp0</h3><p>中断的打开意味着ring0和ring1之间频繁的切换，两个层级之间的切换包含两方面，一是代码的跳转，还有一个不容忽视的地方，就是堆栈也在切换。TSS的用处知识保存ring0堆栈信息，而堆栈的信息就是ss和esp两个寄存器。由于要为先一次ring1-&gt;ring0做准备，所以用iretd返回之前要保证tss.esp0是正确的。<br>当进程被中断切换到内核态时，当前的各个寄存器应该被立即保存（压栈）。也就是tss.esp0应该是当前进程的进程表中保存寄存器值的地方，即struct s_proc中struct中s_stackframe的最高地址处。这样进程被挂起后才恰好保存寄存到正确的位置。<br>现在的中断程序变成了：在中断发生的开始，esp的值是刚刚从TSS里面取到的进程表A中regs的最高地址，然后各个寄存器值被压栈入进程表，最后esp指向regs的最低地址处，然后设置tss.esp0的值，准备下一次进程被中断时使用。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 中断重入 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》内核雏形（3-2）]]></title>
      <url>/2018/02/28/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%86%85%E6%A0%B8%E9%9B%8F%E5%BD%A2%EF%BC%883-2%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="跳入保护模式"><a href="#跳入保护模式" class="headerlink" title="跳入保护模式"></a>跳入保护模式</h2><p>首先是GDT以及对应的选择子，我们只定义三个描述符，分别是0~4GB的可执行段、0~4GB可读写段和一个指向显存开始地址的段。<br><a id="more"></a><br>因为段地址已经被确定为BaseOfLoader,所以Loader中出现的标号的物理地址可以用下面的公式表示：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = <span class="keyword">BaseOfLoader </span>x <span class="number">10</span>h + 变量的偏移</span><br></pre></td></tr></table></figure></p>
<p>然后运行后，如果看到字母“p”则代表我们进入了保护模式，如图所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/D0HELa024G.png?imageslim" alt="mark"></p>
<h2 id="重新放置内核以及控制器的转让"><a href="#重新放置内核以及控制器的转让" class="headerlink" title="重新放置内核以及控制器的转让"></a>重新放置内核以及控制器的转让</h2><p>下图是一个内存的使用分布图。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/a5liccl973.png?imageslim" alt="mark"><br>虽然引导扇区将剩余的内存空间分割成了两块，但实际上引导扇区在完成了它的使命之后就没有用了，可以视为空闲内存。<br>运行之后，可以看到K字母，即代表成功由内核在控制了。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/i1HDh6BLje.png?imageslim" alt="mark"></p>
<h1 id="扩充内核"><a href="#扩充内核" class="headerlink" title="扩充内核"></a>扩充内核</h1><h2 id="切换堆栈和GDT"><a href="#切换堆栈和GDT" class="headerlink" title="切换堆栈和GDT"></a>切换堆栈和GDT</h2><p>代码如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SELECTOR_KERNEL_CS	equ	<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 导入函数</span></span><br><span class="line"><span class="keyword">extern	</span>cstart</span><br><span class="line"></span><br><span class="line"><span class="comment">; 导入全局变量</span></span><br><span class="line"><span class="keyword">extern	</span>gdt_ptr</span><br><span class="line"></span><br><span class="line">[SECTION .<span class="keyword">bss]</span></span><br><span class="line"><span class="keyword">StackSpace	</span>	resb	<span class="number">2</span> * <span class="number">1024</span></span><br><span class="line"><span class="symbol">StackTop:</span>		<span class="comment">; 栈顶</span></span><br><span class="line"></span><br><span class="line">[section <span class="meta">.text</span>]	<span class="comment">; 代码在此</span></span><br><span class="line"></span><br><span class="line">global _start	<span class="comment">; 导出 _start</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">mov	esp, StackTop	<span class="comment">; 堆栈在 bss 段中</span></span><br><span class="line"></span><br><span class="line">	sgdt	[gdt_ptr]	<span class="comment">; cstart() 中将会用到 gdt_ptr</span></span><br><span class="line">	call	cstart		<span class="comment">; 在此函数中改变了gdt_ptr，让它指向新的GDT</span></span><br><span class="line">	lgdt	[gdt_ptr]	<span class="comment">; 使用新的GDT</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">;lidt	[idt_ptr]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">jmp	</span>SELECTOR_KERNEL_CS:csinit</span><br><span class="line"><span class="symbol">csinit:</span>		<span class="comment">; “这个跳转指令强制使用刚刚初始化的结构”——&lt;&lt;OS:D&amp;I 2nd&gt;&gt; P90.</span></span><br><span class="line"></span><br><span class="line">	push	<span class="number">0</span></span><br><span class="line">	popfd	<span class="comment">; Pop top of stack into EFLAGS</span></span><br><span class="line"></span><br><span class="line">	hlt</span><br></pre></td></tr></table></figure></p>
<p>从上可知，用简单的4个语句就完成了切换堆栈和更换GDT的任务。其中，StackTop定义在.bass段中，堆栈大小为2KB。操做GDT时用到的gdt_ptr和cstart分别是一个全局变量和全局函数，他们定义在start.c中，如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"type.h"</span></span><br><span class="line">#include <span class="string">"const.h"</span></span><br><span class="line">#include <span class="string">"protect.h"</span></span><br><span class="line"></span><br><span class="line">PUBLIC	void*	memcpy(void* pDst, void* pSrc, int iSize);</span><br><span class="line"></span><br><span class="line">PUBLIC	void	disp_str(char * pszInfo);</span><br><span class="line"></span><br><span class="line">PUBLIC	u8		gdt_ptr[<span class="number">6</span>];	<span class="comment">/* 0~15:Limit  16~47:Base */</span></span><br><span class="line">PUBLIC	DESCRIPTOR	gdt[GDT_SIZE];</span><br><span class="line"></span><br><span class="line">PUBLIC void cstart()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	disp_str(<span class="string">"<span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span>"</span></span><br><span class="line">		 <span class="string">"-----<span class="subst">\"</span>cstart<span class="subst">\"</span> begins-----<span class="subst">\n</span>"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将 LOADER 中的 GDT 复制到新的 GDT 中 */</span></span><br><span class="line">	memcpy(&amp;gdt,				   <span class="comment">/* New GDT */</span></span><br><span class="line">	       (void*)(*((u32*)(&amp;gdt_ptr[<span class="number">2</span>]))),    <span class="comment">/* Base  of Old GDT */</span></span><br><span class="line">	       *((u16*)(&amp;gdt_ptr[<span class="number">0</span>])) + <span class="number">1</span>	   <span class="comment">/* Limit of Old GDT */</span></span><br><span class="line">		);</span><br><span class="line">	<span class="comment">/* gdt_ptr[6] 共 6 个字节：0~15:Limit  16~47:Base。用作 sgdt/lgdt 的参数。*/</span></span><br><span class="line">	u16* p_gdt_limit = (u16*)(&amp;gdt_ptr[<span class="number">0</span>]);</span><br><span class="line">	u32* p_gdt_base  = (u32*)(&amp;gdt_ptr[<span class="number">2</span>]);</span><br><span class="line">	*p_gdt_limit = GDT_SIZE * sizeof(DESCRIPTOR) - <span class="number">1</span>;</span><br><span class="line">	*p_gdt_base  = (u32)&amp;gdt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cstart()首先把位于Loader中的原GDT全部复制给心得GDT，然后把gdt_ptr中的内容换成新的GDT的基地址和界限。复制GDT使用的是函数memcpy。<br>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/4cCmIF11FC.png?imageslim" alt="mark"></p>
<h2 id="整理文件"><a href="#整理文件" class="headerlink" title="整理文件"></a>整理文件</h2><ul>
<li>boot.asm和loader.asm放在单独的目录/boot中，相应的头文件也放在里面；</li>
<li>klib.asm和string.asm放在/lib中，作为库；</li>
<li>kernel.asm和start.c放在/kernel里面<br>目录树如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/4l4k0mll3K.png?imageslim" alt="mark"><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2>当我们把文件放在不同的文件夹了以后，编译的命令会更加的复杂，所以，我们将使用Makefile，从而输入一行命令就可以完成整个编译过程，相关的文件放在/boot中，具体代码如下：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile for boot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Programs, flags, etc.</span></span><br><span class="line">ASM		= nasm</span><br><span class="line">ASMFLAGS	= -I <span class="keyword">include</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment"># This Program</span></span><br><span class="line">TARGET		= boot.bin loader.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># All Phony Targets</span></span><br><span class="line">.PHONY : everything clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default starting position</span></span><br><span class="line">everything : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line">all : clean everything</span><br><span class="line"></span><br><span class="line">boot.bin : boot.asm <span class="keyword">include</span>/load.inc <span class="keyword">include</span>/fat12hdr.inc</span><br><span class="line">	<span class="variable">$(ASM)</span> <span class="variable">$(ASMFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">loader.bin : loader.asm <span class="keyword">include</span>/load.inc <span class="keyword">include</span>/fat12hdr.inc <span class="keyword">include</span>/pm.inc</span><br><span class="line">	<span class="variable">$(ASM)</span> <span class="variable">$(ASMFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以字符#开头的行是注释、=用来定义变量，ASM和ASMFLAGS就是两个变量，使用他们的时候要用$(ASM)和$(ASMFLAGS)。Makefile的最重要的语法如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: prerequisites</span><br><span class="line">        <span class="keyword">command</span></span><br></pre></td></tr></table></figure></p>
<p>上面这样的形式表示：</p>
<ol>
<li>要想得到target，需要执行命令command.</li>
<li>target依赖prerequisites，当prerequisites中至少有一个文件比target文件新时，command才被执行。<br>比如这个Makefile的最后两行，翻译出来就是：</li>
<li>要想得到loader.bin，需要执行“$(ASM) $(ASMFLAGS) -o $@ $&lt;”。</li>
<li>loader.bin依赖一下文件：</li>
</ol>
<ul>
<li>loader.asm</li>
<li>include/load.inc</li>
<li>include/pm.inc</li>
<li>include/fat12hdr.inc<br>当他们中至少有一个比loader.bin新的时候，command被执行。<br>其中 $@代表target $&lt;代表prerequisites的第一个名字。<br>所以执行“make clean”，将会执行“rm -f $(TARGET)”也就是“rm -f boot.bin loader.bin”<br>以下是执行make all和make的结果图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/EC2GK4cgcm.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/h782J4BeGK.png?imageslim" alt="mark"><br>接着对makefile扩展之后，我们可以通过make building 和make image很方便的把引导扇区、load.bin和kernel。bin写入虚拟软盘。如下所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/8FDma1Bam7.png?imageslim" alt="mark"><br>然后再启动bochs，同时在start.c加上显示cstart end，来表示我们的make正常的进行了编译连接了，结果如图所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/Ga4ccAcHb8.png?imageslim" alt="mark"><h2 id="添加中断处理"><a href="#添加中断处理" class="headerlink" title="添加中断处理"></a>添加中断处理</h2>中断要做的工作为：设置8259A和建立IDT。先写函数设置8259A:<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC void i<span class="symbol">nit_8259</span>A<span class="comment">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Master 8259, ICW1. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_M_CTL,	0x11)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slave  8259, ICW1. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_S_CTL,	0x11)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Master 8259, ICW2. 设置 '主8259' 的中断入口地址为 0x20. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_M_CTLMASK,	INT_VECTOR_IRQ0)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slave  8259, ICW2. 设置 '从8259' 的中断入口地址为 0x28 */</span></span><br><span class="line">	out_byte<span class="comment">(INT_S_CTLMASK,	INT_VECTOR_IRQ8)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Master 8259, ICW3. IR2 对应 '从8259'. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_M_CTLMASK,	0x4)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slave  8259, ICW3. 对应 '主8259' 的 IR2. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_S_CTLMASK,	0x2)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Master 8259, ICW4. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_M_CTLMASK,	0x1)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slave  8259, ICW4. */</span></span><br><span class="line">	out_byte<span class="comment">(INT_S_CTLMASK,	0x1)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Master 8259, OCW1.  */</span></span><br><span class="line">	out_byte<span class="comment">(INT_M_CTLMASK,	0xFF)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slave  8259, OCW1.  */</span></span><br><span class="line">	out_byte<span class="comment">(INT_S_CTLMASK,	0xFF)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>相应端口的宏如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8259A interrupt controller ports. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_M_CTL     0x20 <span class="comment">/* I/O port for interrupt controller       &lt;Master&gt; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_M_CTLMASK 0x21 <span class="comment">/* setting bits in this port disables ints &lt;Master&gt; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_S_CTL     0xA0 <span class="comment">/* I/O port for second interrupt controller&lt;Slave&gt;  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_S_CTLMASK 0xA1 <span class="comment">/* setting bits in this port disables ints &lt;Slave&gt;  */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 中断向量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	INT_VECTOR_IRQ0			0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	INT_VECTOR_IRQ8			0x28</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数只用到了一个函数，就是用来写端口的out_byte，该函数体位于kliba.asm。其中不仅有out_byte对端口进行写操作还有in_byte对端口进行读操作，由于端口操作可能需要时间，所以两个函数中加了点空操作表，以便有微笑的延迟。代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ========================================================================</span></span><br><span class="line"><span class="comment">;                  void out_byte(u16 port, u8 value);</span></span><br><span class="line"><span class="comment">; ========================================================================</span></span><br><span class="line"><span class="symbol">out_byte:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">edx</span>, [<span class="built_in">esp</span> + <span class="number">4</span>]		<span class="comment">; port</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, [<span class="built_in">esp</span> + <span class="number">4</span> + <span class="number">4</span>]	<span class="comment">; value</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line">	<span class="keyword">nop</span>	<span class="comment">; 一点延迟</span></span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ========================================================================</span></span><br><span class="line"><span class="comment">;                  u8 in_byte(u16 port);</span></span><br><span class="line"><span class="comment">; ========================================================================</span></span><br><span class="line"><span class="symbol">in_byte:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">edx</span>, [<span class="built_in">esp</span> + <span class="number">4</span>]		<span class="comment">; port</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">in</span>	<span class="built_in">al</span>, <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">nop</span>	<span class="comment">; 一点延迟</span></span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line">	<span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>这两个函数放在include/proto.h中，这是一个新建立的头文件，用来存放函数声明。<br>然后，还要修改Makefile，不但要添加新的目标kernel/i8259.o，而且由于头文件的变化，kernel/start.o的依赖关系也稍微有变化：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OBJS		= kernel/kernel<span class="selector-class">.o</span> kernel/start<span class="selector-class">.o</span> kernel/i8259<span class="selector-class">.o</span> kernel/global<span class="selector-class">.o</span> kernel/protect<span class="selector-class">.o</span> lib/klib<span class="selector-class">.o</span> lib/kliba<span class="selector-class">.o</span> lib/string.o</span><br><span class="line">DASMOUTPUT	= kernel<span class="selector-class">.bin</span><span class="selector-class">.asm</span></span><br><span class="line">......</span><br><span class="line">kernel/start<span class="selector-class">.o</span>: kernel/start<span class="selector-class">.c</span> include/type<span class="selector-class">.h</span> include/const<span class="selector-class">.h</span> include/protect<span class="selector-class">.h</span> \</span><br><span class="line">		include/proto<span class="selector-class">.h</span> include/string.h</span><br><span class="line">	$(CC) $(CFLAGS) -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">kernel/i8259<span class="selector-class">.o</span> : kernel/i8259<span class="selector-class">.c</span> include/type<span class="selector-class">.h</span> include/const<span class="selector-class">.h</span> include/protect<span class="selector-class">.h</span> \</span><br><span class="line">			include/proto.h</span><br><span class="line">	$(CC) $(CFLAGS) -o $@ $&lt;</span><br></pre></td></tr></table></figure></p>
<p>我们使用gcc -M自动生成依赖关系如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/g0h8FDbgFJ.png?imageslim" alt="mark">。<br>下面初始化IDT，它和初始化GDT类似，所以初始化GDT的方法可以拿着用，先前的gdt[]等变量都在头文件global.h中了，这样增加了代码的美感和可读性。<br>GATE定义在protect.h中，如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 门描述符 */</span></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">s_gate</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">u16</span>	offset_low;	<span class="comment">/* Offset Low */</span></span><br><span class="line">	<span class="built_in">u16</span>	selector;	<span class="comment">/* Selector */</span></span><br><span class="line">	<span class="built_in">u8</span>	dcount;		<span class="comment">/* 该字段只在调用门描述符中有效。如果在利用</span></span><br><span class="line"><span class="comment">				   调用门调用子程序时引起特权级的转换和堆栈</span></span><br><span class="line"><span class="comment">				   的改变，需要将外层堆栈中的参数复制到内层</span></span><br><span class="line"><span class="comment">				   堆栈。该双字计数字段就是用于说明这种情况</span></span><br><span class="line"><span class="comment">				   发生时，要复制的双字参数的数量。*/</span></span><br><span class="line">	<span class="built_in">u8</span>	attr;		<span class="comment">/* P(1) DPL(2) DT(1) TYPE(4) */</span></span><br><span class="line">	<span class="built_in">u16</span>	offset_high;	<span class="comment">/* Offset High */</span></span><br><span class="line">&#125;GATE;</span><br></pre></td></tr></table></figure></p>
<p>接着，在kernel.asm中添加两句，导入idt_ptr这个符号，并加载IDT。<br>我们对异常的处理总体是，如果有错误码，则直接把向量号压栈，然后执行一个函数exception_handler；如果没有错误码，则现在栈中压入一个0xfffffff,再把向量号压栈并随后执行exception_handler。<br>下面是该函数：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC <span class="literal">void</span> exception_handler(int vec_no,int err_code,int eip,int cs,int eflags)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int text_color = <span class="number">0x74</span>; <span class="comment">/* 灰底红字 */</span></span><br><span class="line"></span><br><span class="line">	char * err_msg[] = &#123;<span class="string">"<span class="subst">#DE</span> Divide Error"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#DB</span> RESERVED"</span>,</span><br><span class="line">			    <span class="string">"--  NMI Interrupt"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#BP</span> Breakpoint"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#OF</span> Overflow"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#BR</span> BOUND Range Exceeded"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#UD</span> Invalid Opcode (Undefined Opcode)"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#NM</span> Device Not Available (No Math Coprocessor)"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#DF</span> Double Fault"</span>,</span><br><span class="line">			    <span class="string">"    Coprocessor Segment Overrun (reserved)"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#TS</span> Invalid TSS"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#NP</span> Segment Not Present"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#SS</span> Stack-Segment Fault"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#GP</span> General Protection"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#PF</span> Page Fault"</span>,</span><br><span class="line">			    <span class="string">"--  (Intel reserved. Do not use.)"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#MF</span> x87 FPU Floating-Point Error (Math Fault)"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#AC</span> Alignment Check"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#MC</span> Machine Check"</span>,</span><br><span class="line">			    <span class="string">"<span class="subst">#XF</span> SIMD Floating-Point Exception"</span></span><br><span class="line">	&#125;;</span><br><span class="line">		<span class="comment">/* 通过打印空格的方式清空屏幕的前五行，并把 disp_pos 清零 */</span></span><br><span class="line">	disp_pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">80</span>*<span class="number">5</span>;i++)&#123;</span><br><span class="line">		disp_str(<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	disp_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	disp_color_str(<span class="string">"Exception! --&gt; "</span>, text_color);</span><br><span class="line">	disp_color_str(err_msg[vec_no], text_color);</span><br><span class="line">	disp_color_str(<span class="string">"\n\n"</span>, text_color);</span><br><span class="line">	disp_color_str(<span class="string">"EFLAGS:"</span>, text_color);</span><br><span class="line">	disp_int(eflags);</span><br><span class="line">	disp_color_str(<span class="string">"CS:"</span>, text_color);</span><br><span class="line">	disp_int(cs);</span><br><span class="line">	disp_color_str(<span class="string">"EIP:"</span>, text_color);</span><br><span class="line">	disp_int(eip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(err_code != <span class="number">0xFFFFFFFF</span>)&#123;</span><br><span class="line">		disp_color_str(<span class="string">"Error code:"</span>, text_color);</span><br><span class="line">		disp_int(err_code);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下就是中断异常的情况：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/64jFAiG2JH.png?imageslim" alt="mark"><br>所有的中断都会触发一个函数spurious_irq()，这个仅仅是把IRQ号打印出来。<br>接着，我们向主8259A相应端口写入了0xFD，由于0XFD对应的二进制是11111101，于是键盘中断被打开，而其他中断任然处于屏蔽状态，最后在kernel.asm中添加sti指令设置IF位，然后make后，当我们敲击键盘任意键就如出现如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180301/GE94l7gm3I.png?imageslim" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NASM </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> 内核 </tag>
            
            <tag> ELF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》内核雏形（3-1）]]></title>
      <url>/2018/02/28/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%86%85%E6%A0%B8%E9%9B%8F%E5%BD%A2%EF%BC%883-1%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="在Linux下红汇编写Hello-World"><a href="#在Linux下红汇编写Hello-World" class="headerlink" title="在Linux下红汇编写Hello World"></a>在Linux下红汇编写Hello World</h1><p>因为在后面的很多工作中，都要用到汇编编程，所以我们先试试用汇编在Linux下编写Hello World，具体代码如下：<br><a id="more"></a><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 编译链接方法</span></span><br><span class="line"><span class="comment">; (ld 的‘-s’选项意为“strip all”)</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; $ nasm -f elf hello.asm -o hello.o</span></span><br><span class="line"><span class="comment">; $ ld -s hello.o -o hello</span></span><br><span class="line"><span class="comment">; $ ./hello</span></span><br><span class="line"><span class="comment">; Hello, world!</span></span><br><span class="line"><span class="comment">; $</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">section</span> .data]	<span class="comment">; 数据在此</span></span><br><span class="line"></span><br><span class="line">strHello	<span class="built_in">db</span>	<span class="string">"Hello, world!"</span>, <span class="number">0Ah</span></span><br><span class="line">STRLEN		<span class="built_in">equ</span>	$ - strHello</span><br><span class="line"></span><br><span class="line">[<span class="meta">section</span> .text]	<span class="comment">; 代码在此</span></span><br><span class="line"></span><br><span class="line"><span class="meta">global</span> _start	<span class="comment">; 我们必须导出 _start 这个入口，以便让链接器识别</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">edx</span>, STRLEN</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ecx</span>, strHello</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ebx</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, <span class="number">4</span>		<span class="comment">; sys_write</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">0x80</span>		<span class="comment">; 系统调用</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ebx</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, <span class="number">1</span>		<span class="comment">; sys_exit</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">0x80</span>		<span class="comment">; 系统调用</span></span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/7EDm7lcAK7.png?imageslim" alt="mark"><br>以上代码我们只要明白一点，链接程序只能通过global关键字将默认入口点“_start”导出即可。</p>
<h1 id="汇编和C同步使用"><a href="#汇编和C同步使用" class="headerlink" title="汇编和C同步使用"></a>汇编和C同步使用</h1><p>这部分是今后会经常用到的，两者的调用方法如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/d6mE64AkAK.png?imageslim" alt="mark"><br>foo.asm的具体代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 编译链接方法</span></span><br><span class="line"><span class="comment">; (ld 的‘-s’选项意为“strip all”)</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; $ nasm -f elf foo.asm -o foo.o</span></span><br><span class="line"><span class="comment">; $ gcc -c bar.c -o bar.o</span></span><br><span class="line"><span class="comment">; $ ld -s hello.o bar.o -o foobar</span></span><br><span class="line"><span class="comment">; $ ./foobar</span></span><br><span class="line"><span class="comment">; the 2nd one</span></span><br><span class="line"><span class="comment">; $</span></span><br><span class="line"></span><br><span class="line"><span class="meta">extern</span> choose	<span class="comment">; int choose(int a, int b);</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">section</span> .data]	<span class="comment">; 数据在此</span></span><br><span class="line"></span><br><span class="line">num1st		<span class="built_in">dd</span>	<span class="number">3</span></span><br><span class="line">num2nd		<span class="built_in">dd</span>	<span class="number">4</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">section</span> .text]	<span class="comment">; 代码在此</span></span><br><span class="line"></span><br><span class="line"><span class="meta">global</span> _start	<span class="comment">; 我们必须导出 _start 这个入口，以便让链接器识别。</span></span><br><span class="line"><span class="meta">global</span> myprint	<span class="comment">; 导出这个函数为了让 bar.c 使用</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">dword</span> [num2nd]	<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">dword</span> [num1st]	<span class="comment">;  |</span></span><br><span class="line">	<span class="keyword">call</span>	choose		<span class="comment">;  | choose(num1st, num2nd);</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">esp</span>, <span class="number">8</span>		<span class="comment">; /</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ebx</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, <span class="number">1</span>		<span class="comment">; sys_exit</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">0x80</span>		<span class="comment">; 系统调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; void myprint(char* msg, int len)</span></span><br><span class="line"><span class="symbol">myprint:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">edx</span>, [<span class="built_in">esp</span> + <span class="number">8</span>]	<span class="comment">; len</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ecx</span>, [<span class="built_in">esp</span> + <span class="number">4</span>]	<span class="comment">; msg</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ebx</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, <span class="number">4</span>		<span class="comment">; sys_write</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">0x80</span>		<span class="comment">; 系统调用</span></span><br><span class="line">	<span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>bar.c的具体代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span>* msg, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a &gt;= b)&#123;</span><br><span class="line">		myprint(<span class="string">"the 1st one\n"</span>, <span class="number">13</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		myprint(<span class="string">"the 2nd one\n"</span>, <span class="number">13</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/D6jI3Edeam.png?imageslim" alt="mark"><br>从代码中可以看出，其实global和extern两个关键字才是最关键的，可以方便地在汇编和C之间自由变换。</p>
<h1 id="ELF（Executable-and-Linkable-format）"><a href="#ELF（Executable-and-Linkable-format）" class="headerlink" title="ELF（Executable and Linkable format）"></a>ELF（Executable and Linkable format）</h1><p>下图为ELF文件的结构由ELF头、程序头表、节和节头表（实际上一个文件不一定包含全部这些内容，而且它们的位置也不一定如下，只有ELF头的位置是固定的，其余部分都是由ELF头中的各项值来决定的）<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/jdkd8E23Ee.png?imageslim" alt="mark"><br>下面是ELFheader的数据类型：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/b939LHC44G.png?imageslim" alt="mark"><br>在终端输入<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="keyword">include</span>/elf.<span class="built_in">h</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/AFfgKAFkBD.png?imageslim" alt="ELF header的格式"><br>其中各项额意义为：</p>
<ul>
<li>e_ident：其中包含用来表示ELF文件的字符，以及其他一些与机器无关的信息。<br>从下图可以很清楚的看出foobar文件的该信息：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/47Jk6EBK1f.png?imageslim" alt="mark"></li>
<li>e_type:标识文件的类型，其中2代表可执行文件</li>
<li>e_machine:表示改程序需要的体系结构，3为Intel80386</li>
<li>e_version:文件版本</li>
<li>e_entry:程序的入口，这里为0x80480A0</li>
<li>e_phoff:文件中的偏移量这里为0x34</li>
<li>e_ehsize:大小</li>
<li>e_phentsize:每一个条目的大小</li>
<li>e_phnum:条目数</li>
<li>e_shstrndx:包含节名称的字符串是第几个节。<br>从上面的Program header可以看出，foobar在内存中的加载为如下图所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/ELfBmA1k27.png?imageslim" alt="mark"><h1 id="从Loader到内核"><a href="#从Loader到内核" class="headerlink" title="从Loader到内核"></a>从Loader到内核</h1>研究完了ELF之后，我们接着就该完成Loader要做的两件事了</li>
<li>加载内存到内核</li>
<li>跳入保护模式<h2 id="用Loader加载ELF"><a href="#用Loader加载ELF" class="headerlink" title="用Loader加载ELF"></a>用Loader加载ELF</h2>首先，我们把FAT12文件有关的东西放进fat12hdr.inc中，供boot.asm和loader.asm共享，所以boot.asm开头部分的代码就如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/Jbjdd53016.png?imageslim" alt="mark"><br>下面我们修改loader.asm，让它把内核放进内存，其代码如下：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line">org  <span class="number">0100h</span></span><br><span class="line"></span><br><span class="line">BaseOfStack		<span class="built_in">equ</span>	<span class="number">0100h</span></span><br><span class="line"></span><br><span class="line">BaseOfKernelFile	<span class="built_in">equ</span>	 <span class="number">08000h</span>	<span class="comment">; KERNEL.BIN 被加载到的位置 ----  段地址</span></span><br><span class="line">OffsetOfKernelFile	<span class="built_in">equ</span>	     <span class="number">0h</span>	<span class="comment">; KERNEL.BIN 被加载到的位置 ---- 偏移地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_START		<span class="comment">; Start</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 下面是 FAT12 磁盘的头, 之所以包含它是因为下面用到了磁盘的一些信息</span></span><br><span class="line"><span class="meta">%include</span>	<span class="string">"fat12hdr.inc"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_START:</span>			<span class="comment">; &lt;--- 从这里开始 *************</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">sp</span>, BaseOfStack</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">dh</span>, <span class="number">0</span>			<span class="comment">; "Loading  "</span></span><br><span class="line">	<span class="keyword">call</span>	DispStr			<span class="comment">; 显示字符串</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">; 下面在 A 盘的根目录寻找 KERNEL.BIN</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">word</span> [wSectorNo], SectorNoOfRootDirectory	</span><br><span class="line">	<span class="keyword">xor</span>	<span class="number">ah</span>, <span class="number">ah</span>	<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">dl</span>, <span class="built_in">dl</span>	<span class="comment">;  | 软驱复位</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">13h</span>	<span class="comment">; /</span></span><br><span class="line"><span class="symbol">LABEL_SEARCH_IN_ROOT_DIR_BEGIN:</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">word</span> [wRootDirSizeForLoop], <span class="number">0</span>	<span class="comment">; `.</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_NO_KERNELBIN		<span class="comment">;  | 判断根目录区是不是已经读完,</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">word</span> [wRootDirSizeForLoop]	<span class="comment">; /  读完表示没有找到 KERNEL.BIN</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, BaseOfKernelFile</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span>			<span class="comment">; es &lt;- BaseOfKernelFile</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, OffsetOfKernelFile	<span class="comment">; bx &lt;- OffsetOfKernelFile</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, [wSectorNo]		<span class="comment">; ax &lt;- Root Directory 中的某 Sector 号</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cl</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">call</span>	ReadSector</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">si</span>, KernelFileName	<span class="comment">; ds:si -&gt; "KERNEL  BIN"</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">di</span>, OffsetOfKernelFile</span><br><span class="line">	<span class="keyword">cld</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dx</span>, <span class="number">10h</span></span><br><span class="line"><span class="symbol">LABEL_SEARCH_FOR_KERNELBIN:</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">dx</span>, <span class="number">0</span>				  <span class="comment">; `.</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_GOTO_NEXT_SECTOR_IN_ROOT_DIR<span class="comment">;  | 循环次数控制, 如果已经读完</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">dx</span>				  <span class="comment">; /  了一个 Sector, 就跳到下一个</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cx</span>, <span class="number">11</span></span><br><span class="line"><span class="symbol">LABEL_CMP_FILENAME:</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">cx</span>, <span class="number">0</span>			<span class="comment">; `.</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_FILENAME_FOUND	<span class="comment">;  | 循环次数控制, 如果比较了 11 个字符都</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">cx</span>			<span class="comment">; /  相等, 表示找到</span></span><br><span class="line">	<span class="keyword">lodsb</span>				<span class="comment">; ds:si -&gt; al</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">al</span>, <span class="built_in">byte</span> [<span class="built_in">es</span>:<span class="built_in">di</span>]	<span class="comment">; if al == es:di</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_GO_ON</span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_DIFFERENT</span><br><span class="line"><span class="symbol">LABEL_GO_ON:</span></span><br><span class="line">	<span class="keyword">inc</span>	<span class="built_in">di</span></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_CMP_FILENAME	<span class="comment">;	继续循环</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_DIFFERENT:</span></span><br><span class="line">	<span class="keyword">and</span>	<span class="built_in">di</span>, <span class="number">0FFE0h</span>		<span class="comment">; else`. 让 di 是 20h 的倍数</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">di</span>, <span class="number">20h</span>			<span class="comment">;      |</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">si</span>, KernelFileName	<span class="comment">;      | di += 20h  下一个目录条目</span></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_SEARCH_FOR_KERNELBIN<span class="comment">;   /</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">word</span> [wSectorNo], <span class="number">1</span></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_SEARCH_IN_ROOT_DIR_BEGIN</span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_NO_KERNELBIN:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">dh</span>, <span class="number">2</span>			<span class="comment">; "No KERNEL."</span></span><br><span class="line">	<span class="keyword">call</span>	DispStr			<span class="comment">; 显示字符串</span></span><br><span class="line">%ifdef	_LOADER_DEBUG_</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="number">4c00h</span>		<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">21h</span>			<span class="comment">; / 没有找到 KERNEL.BIN, 回到 DOS</span></span><br><span class="line"><span class="meta">%else</span></span><br><span class="line">	<span class="keyword">jmp</span>	$			<span class="comment">; 没有找到 KERNEL.BIN, 死循环在这里</span></span><br><span class="line"><span class="meta">%endif</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_FILENAME_FOUND:</span>			<span class="comment">; 找到 KERNEL.BIN 后便来到这里继续</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, RootDirSectors</span><br><span class="line">	<span class="keyword">and</span>	<span class="built_in">di</span>, <span class="number">0FFF0h</span>		<span class="comment">; di -&gt; 当前条目的开始</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, [<span class="built_in">es</span> : <span class="built_in">di</span> + <span class="number">01Ch</span>]		<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dword</span> [dwKernelSize], <span class="built_in">eax</span>	<span class="comment">; / 保存 KERNEL.BIN 文件大小</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">di</span>, <span class="number">01Ah</span>		<span class="comment">; di -&gt; 首 Sector</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cx</span>, <span class="built_in">word</span> [<span class="built_in">es</span>:<span class="built_in">di</span>]</span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">cx</span>			<span class="comment">; 保存此 Sector 在 FAT 中的序号</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">cx</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">cx</span>, DeltaSectorNo	<span class="comment">; cl &lt;- LOADER.BIN 的起始扇区号(0-based)</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, BaseOfKernelFile</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span>			<span class="comment">; es &lt;- BaseOfKernelFile</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, OffsetOfKernelFile	<span class="comment">; bx &lt;- OffsetOfKernelFile</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="built_in">cx</span>			<span class="comment">; ax &lt;- Sector 号</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_GOON_LOADING_FILE:</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">ax</span>			<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">bx</span>			<span class="comment">;  |</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ah</span>, <span class="number">0Eh</span>			<span class="comment">;  | 每读一个扇区就在 "Loading  " 后面</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="string">'.'</span>			<span class="comment">;  | 打一个点, 形成这样的效果:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bl</span>, <span class="number">0Fh</span>			<span class="comment">;  | Loading ......</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">10h</span>			<span class="comment">;  |</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">bx</span>			<span class="comment">;  |</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">ax</span>			<span class="comment">; /</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cl</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">call</span>	ReadSector</span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">ax</span>			<span class="comment">; 取出此 Sector 在 FAT 中的序号</span></span><br><span class="line">	<span class="keyword">call</span>	GetFATEntry</span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">ax</span>, <span class="number">0FFFh</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_FILE_LOADED</span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">ax</span>			<span class="comment">; 保存 Sector 在 FAT 中的序号</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dx</span>, RootDirSectors</span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">ax</span>, <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">ax</span>, DeltaSectorNo</span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">bx</span>, [BPB_BytsPerSec]</span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_GOON_LOADING_FILE</span><br><span class="line"><span class="symbol">LABEL_FILE_LOADED:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">call</span>	KillMotor		<span class="comment">; 关闭软驱马达</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">dh</span>, <span class="number">1</span>			<span class="comment">; "Ready."</span></span><br><span class="line">	<span class="keyword">call</span>	DispStr			<span class="comment">; 显示字符串</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">jmp</span>	$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;============================================================================</span></span><br><span class="line"><span class="comment">;变量</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line">wRootDirSizeForLoop	<span class="built_in">dw</span>	RootDirSectors	<span class="comment">; Root Directory 占用的扇区数</span></span><br><span class="line">wSectorNo		<span class="built_in">dw</span>	<span class="number">0</span>		<span class="comment">; 要读取的扇区号</span></span><br><span class="line">bOdd			<span class="built_in">db</span>	<span class="number">0</span>		<span class="comment">; 奇数还是偶数</span></span><br><span class="line">dwKernelSize		<span class="built_in">dd</span>	<span class="number">0</span>		<span class="comment">; KERNEL.BIN 文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;============================================================================</span></span><br><span class="line"><span class="comment">;字符串</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line">KernelFileName		<span class="built_in">db</span>	<span class="string">"KERNEL  BIN"</span>, <span class="number">0</span>	<span class="comment">; KERNEL.BIN 之文件名</span></span><br><span class="line"><span class="comment">; 为简化代码, 下面每个字符串的长度均为 MessageLength</span></span><br><span class="line">MessageLength		<span class="built_in">equ</span>	<span class="number">9</span></span><br><span class="line"><span class="symbol">LoadMessage:</span>		<span class="built_in">db</span>	<span class="string">"Loading  "</span></span><br><span class="line">Message1		<span class="built_in">db</span>	<span class="string">"Ready.   "</span></span><br><span class="line">Message2		<span class="built_in">db</span>	<span class="string">"No KERNEL"</span></span><br><span class="line"><span class="comment">;============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 函数名: DispStr</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 作用:</span></span><br><span class="line"><span class="comment">;	显示一个字符串, 函数开始时 dh 中应该是字符串序号(0-based)</span></span><br><span class="line"><span class="symbol">DispStr:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, MessageLength</span><br><span class="line">	<span class="keyword">mul</span>	<span class="number">dh</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">ax</span>, LoadMessage</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bp</span>, <span class="built_in">ax</span>			<span class="comment">; ┓</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="built_in">ds</span>			<span class="comment">; ┣ ES:BP = 串地址</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span>			<span class="comment">; ┛</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cx</span>, MessageLength	<span class="comment">; CX = 串长度</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="number">01301h</span>		<span class="comment">; AH = 13,  AL = 01h</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, <span class="number">0007h</span>		<span class="comment">; 页号为0(BH = 0) 黑底白字(BL = 07h)</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dl</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="number">dh</span>, <span class="number">3</span>			<span class="comment">; 从第 3 行往下显示</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">10h</span>			<span class="comment">; int 10h</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 函数名: ReadSector</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 作用:</span></span><br><span class="line"><span class="comment">;	从序号(Directory Entry 中的 Sector 号)为 ax 的的 Sector 开始, 将 cl 个 Sector 读入 es:bx 中</span></span><br><span class="line"><span class="symbol">ReadSector:</span></span><br><span class="line">	<span class="comment">; -----------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">; 怎样由扇区号求扇区在磁盘中的位置 (扇区号 -&gt; 柱面号, 起始扇区, 磁头号)</span></span><br><span class="line">	<span class="comment">; -----------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">; 设扇区号为 x</span></span><br><span class="line">	<span class="comment">;                           ┌ 柱面号 = y &gt;&gt; 1</span></span><br><span class="line">	<span class="comment">;       x           ┌ 商 y ┤</span></span><br><span class="line">	<span class="comment">; -------------- =&gt; ┤      └ 磁头号 = y &amp; 1</span></span><br><span class="line">	<span class="comment">;  每磁道扇区数     │</span></span><br><span class="line">	<span class="comment">;                   └ 余 z =&gt; 起始扇区号 = z + 1</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">bp</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">	<span class="keyword">sub</span>	<span class="built_in">esp</span>, <span class="number">2</span>			<span class="comment">; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">byte</span> [<span class="built_in">bp</span>-<span class="number">2</span>], <span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">bx</span>			<span class="comment">; 保存 bx</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bl</span>, [BPB_SecPerTrk]	<span class="comment">; bl: 除数</span></span><br><span class="line">	<span class="keyword">div</span>	<span class="built_in">bl</span>			<span class="comment">; y 在 al 中, z 在 ah 中</span></span><br><span class="line">	<span class="keyword">inc</span>	<span class="number">ah</span>			<span class="comment">; z ++</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cl</span>, <span class="number">ah</span>			<span class="comment">; cl &lt;- 起始扇区号</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">dh</span>, <span class="built_in">al</span>			<span class="comment">; dh &lt;- y</span></span><br><span class="line">	<span class="keyword">shr</span>	<span class="built_in">al</span>, <span class="number">1</span>			<span class="comment">; y &gt;&gt; 1 (其实是 y/BPB_NumHeads, 这里BPB_NumHeads=2)</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ch</span>, <span class="built_in">al</span>			<span class="comment">; ch &lt;- 柱面号</span></span><br><span class="line">	<span class="keyword">and</span>	<span class="number">dh</span>, <span class="number">1</span>			<span class="comment">; dh &amp; 1 = 磁头号</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">bx</span>			<span class="comment">; 恢复 bx</span></span><br><span class="line">	<span class="comment">; 至此, "柱面号, 起始扇区, 磁头号" 全部得到 ^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dl</span>, [BS_DrvNum]		<span class="comment">; 驱动器号 (0 表示 A 盘)</span></span><br><span class="line"><span class="symbol">.GoOnReading:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ah</span>, <span class="number">2</span>			<span class="comment">; 读</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="built_in">byte</span> [<span class="built_in">bp</span>-<span class="number">2</span>]		<span class="comment">; 读 al 个扇区</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">13h</span></span><br><span class="line">	<span class="keyword">jc</span>	.GoOnReading		<span class="comment">; 如果读取错误 CF 会被置为 1, 这时就不停地读, 直到正确为止</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">esp</span>, <span class="number">2</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">bp</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 函数名: GetFATEntry</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 作用:</span></span><br><span class="line"><span class="comment">;	找到序号为 ax 的 Sector 在 FAT 中的条目, 结果放在 ax 中</span></span><br><span class="line"><span class="comment">;	需要注意的是, 中间需要读 FAT 的扇区到 es:bx 处, 所以函数一开始保存了 es 和 bx</span></span><br><span class="line"><span class="symbol">GetFATEntry:</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">es</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, BaseOfKernelFile	<span class="comment">; ┓</span></span><br><span class="line">	<span class="keyword">sub</span>	<span class="built_in">ax</span>, <span class="number">0100h</span>		<span class="comment">; ┣ 在 BaseOfKernelFile 后面留出 4K 空间用于存放 FAT</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span>			<span class="comment">; ┛</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">byte</span> [bOdd], <span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, <span class="number">3</span></span><br><span class="line">	<span class="keyword">mul</span>	<span class="built_in">bx</span>			<span class="comment">; dx:ax = ax * 3</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">	<span class="keyword">div</span>	<span class="built_in">bx</span>			<span class="comment">; dx:ax / 2  ==&gt;  ax &lt;- 商, dx &lt;- 余数</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_EVEN</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">byte</span> [bOdd], <span class="number">1</span></span><br><span class="line"><span class="symbol">LABEL_EVEN:</span><span class="comment">;偶数</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">dx</span>, <span class="built_in">dx</span>			<span class="comment">; 现在 ax 中是 FATEntry 在 FAT 中的偏移量. 下面来计算 FATEntry 在哪个扇区中(FAT占用不止一个扇区)</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, [BPB_BytsPerSec]</span><br><span class="line">	<span class="keyword">div</span>	<span class="built_in">bx</span>			<span class="comment">; dx:ax / BPB_BytsPerSec  ==&gt;	ax &lt;- 商   (FATEntry 所在的扇区相对于 FAT 来说的扇区号)</span></span><br><span class="line">					<span class="comment">;				dx &lt;- 余数 (FATEntry 在扇区内的偏移)。</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, <span class="number">0</span>			<span class="comment">; bx &lt;- 0	于是, es:bx = (BaseOfKernelFile - 100):00 = (BaseOfKernelFile - 100) * 10h</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">ax</span>, SectorNoOfFAT1	<span class="comment">; 此句执行之后的 ax 就是 FATEntry 所在的扇区号</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cl</span>, <span class="number">2</span></span><br><span class="line">	<span class="keyword">call</span>	ReadSector		<span class="comment">; 读取 FATEntry 所在的扇区, 一次读两个, 避免在边界发生错误, 因为一个 FATEntry 可能跨越两个扇区</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">bx</span>, <span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, [<span class="built_in">es</span>:<span class="built_in">bx</span>]</span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">byte</span> [bOdd], <span class="number">1</span></span><br><span class="line"><span class="symbol">	jnz	LABEL</span>_EVEN_2</span><br><span class="line">	<span class="keyword">shr</span>	<span class="built_in">ax</span>, <span class="number">4</span></span><br><span class="line"><span class="symbol">LABEL_EVEN_2:</span></span><br><span class="line">	<span class="keyword">and</span>	<span class="built_in">ax</span>, <span class="number">0FFFh</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_GET_FAT_ENRY_OK:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">bx</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">es</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 函数名: KillMotor</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">; 作用:</span></span><br><span class="line"><span class="comment">;	关闭软驱马达</span></span><br><span class="line"><span class="symbol">KillMotor:</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dx</span>, <span class="number">03F2h</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">dx</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="comment">;----------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面接着就是写一个内核出来，文件名为kernel.asm<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 编译链接方法</span></span><br><span class="line"><span class="comment">; $ nasm -f elf kernel.asm -o kernel.o</span></span><br><span class="line"><span class="comment">; $ ld -s kernel.o -o kernel.bin    #‘-s’选项意为“strip all”</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">section</span> .text]	<span class="comment">; 代码在此</span></span><br><span class="line"></span><br><span class="line"><span class="meta">global</span> _start	<span class="comment">; 导出 _start</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_start:</span>	<span class="comment">; 跳到这里来的时候，我们假设 gs 指向显存</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ah</span>, <span class="number">0Fh</span>				<span class="comment">; 0000: 黑底    1111: 白字</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="string">'K'</span></span><br><span class="line">	<span class="keyword">mov</span>	[<span class="built_in">gs</span>:((<span class="number">80</span> * <span class="number">1</span> + <span class="number">39</span>) * <span class="number">2</span>)], <span class="built_in">ax</span>	<span class="comment">; 屏幕第 1 行, 第 39 列。</span></span><br><span class="line">	<span class="keyword">jmp</span>	$</span><br></pre></td></tr></table></figure></p>
<p>显示字符时涉及内存操作，所以用到GDT，我们假设在Loader中段寄存器gs已经指向显存的开始。<br>运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180228/lg3dK8hff6.png?imageslim" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NASM </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> 内核 </tag>
            
            <tag> ELF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-4）]]></title>
      <url>/2018/02/27/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-4%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="突破512字节的限制"><a href="#突破512字节的限制" class="headerlink" title="突破512字节的限制"></a>突破512字节的限制</h1><p>前面我们的工作是完成了一个简陋的引导扇区，虽然感觉没做啥，但是我们实际上积累了很多代码，熟悉了保护模式。并且对存储管理、特权级控制等有了一个整体的认识<br>。下面，我们要想办法将自己的OS进入到保护模式，虽然进入保护模式不难，但是总会收到引导扇区512字节的限制，所以下面，我们再建立一个文件，将其通过引导扇区加载入内存，然后将控制权交给它。<br>首先，我们先理清楚一个问题，是不是被引导扇区加载到内存的就是操作系统的内核呢，我们先看看一个操作系统从开机到开始运行要经过一个怎样的过程：引导-&gt;加载内核入内存-&gt;跳入保护模式-&gt;开始执行内核。<br>所以，很明显，在内核开始执行前，不仅仅要加载内核，还有跳入保护模式等等，而这些工作都由引导扇区来做，很有可能不止512字节，所以我们把这个过程交给叫做Loader的模块来做。引导扇区负责把Loader加载到内存，并把控制权交给它，然后其他工作都由Loader来做，而它就没有512字节的限制了。</p>
<h2 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h2><a id="more"></a>
<p>FAT12是DOS时代就开始使用的文件系统，直到现在还在使用。几乎所有的文件系统都会把磁盘划分为若干层次（扇区：磁盘上的最小数据单元；簇：一个或者多个扇区；分区：通常指整个文件系统）以方便组织和管理，所以我们将软盘做成FAT12格式，以方便Kernel的操作。<br>引导扇区是整个软盘的第0个扇区，在这个扇区中有一个很重要的数据结构叫做BPB(BIOS Parameter Block)，引导扇区的格式如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180227/bmEkJIldf9.png?imageslim" alt="mark"><br>其中，名称以BPB开头的域输入BPB,以BS_开头的域只是引导扇区的一部分。以下是整个软盘的结构图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180227/L924A4fH0k.png?imageslim" alt="mark"><br>接下来，我们试着把Loader复制到软盘上，并引导扇区找到并加载它。为简单起见，我们规定Loader只能放在根目录中，而根目录信息存放在FAT2后面的根目录区中。所以先研究根目录区。<br>根目录区位于第二个FAT表之后，开始的扇区号为19，它有若干个目录条目组成，条目最多有BPB_RootEntCnt个。由于根目录的大小依赖BPB_RootEntCnt的，所以长度不固定。<br>根目录区中的条目格式：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180227/k4Kh5dIHg9.png?imageslim" alt="mark"><br>当我们寻找Loader时，只要发现文件名正确就认为它是我们要找的那一个文件。其中最重要的信息是DIR_FstClus，即文件开始簇号，它会告诉我们文件存放在磁盘的什么位置，从而让我们可以找到它。由于一簇只包含一个扇区，所以简化起见，下面都用扇区来替代簇。，需要注意的是，数据区的第一个簇号是2。所以，我们必须计算根目录区所占的扇区数才能知道数据区的第一个簇在哪里。假设根目录区总共有RootDirSectors个扇区，则有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootDirSectors = ((BPB_RootEntCnt*32)+(BPB_BytsPerSec-1))/BPB_BytsPerSec</span><br></pre></td></tr></table></figure>
<p>有了以上公式，可以通过根目录区找到文件并看到内容，而FAT的作用在于，如果文件大于512字节，我们需要FAT表来找到所有的簇。</p>
<h2 id="DOS可以识别的引导盘"><a href="#DOS可以识别的引导盘" class="headerlink" title="DOS可以识别的引导盘"></a>DOS可以识别的引导盘</h2><p>既然引导扇区需要有BPB等头信息才能被微软识别，我们就先加上它，让程序开头变成下面的形式：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp </span><span class="keyword">short </span>LABEL_START		<span class="comment">; Start to boot.</span></span><br><span class="line">	<span class="keyword">nop	</span>			<span class="comment">; 这个 nop 不可少</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">; 下面是 FAT12 磁盘的头</span></span><br><span class="line">	<span class="keyword">BS_OEMName	</span>DB <span class="string">'ForrestY'</span>	<span class="comment">; OEM String, 必须 8 个字节</span></span><br><span class="line">	<span class="keyword">BPB_BytsPerSec	</span>DW <span class="number">512</span>		<span class="comment">; 每扇区字节数</span></span><br><span class="line">	<span class="keyword">BPB_SecPerClus	</span>DB <span class="number">1</span>		<span class="comment">; 每簇多少扇区</span></span><br><span class="line">	<span class="keyword">BPB_RsvdSecCnt	</span>DW <span class="number">1</span>		<span class="comment">; Boot 记录占用多少扇区</span></span><br><span class="line">	<span class="keyword">BPB_NumFATs	</span>DB <span class="number">2</span>		<span class="comment">; 共有多少 FAT 表</span></span><br><span class="line">	<span class="keyword">BPB_RootEntCnt	</span>DW <span class="number">224</span>		<span class="comment">; 根目录文件数最大值</span></span><br><span class="line">	<span class="keyword">BPB_TotSec16	</span>DW <span class="number">2880</span>		<span class="comment">; 逻辑扇区总数</span></span><br><span class="line">	<span class="keyword">BPB_Media	</span>DB <span class="number">0xF0</span>		<span class="comment">; 媒体描述符</span></span><br><span class="line">	<span class="keyword">BPB_FATSz16	</span>DW <span class="number">9</span>		<span class="comment">; 每FAT扇区数</span></span><br><span class="line">	<span class="keyword">BPB_SecPerTrk	</span>DW <span class="number">18</span>		<span class="comment">; 每磁道扇区数</span></span><br><span class="line">	<span class="keyword">BPB_NumHeads	</span>DW <span class="number">2</span>		<span class="comment">; 磁头数(面数)</span></span><br><span class="line">	<span class="keyword">BPB_HiddSec	</span>DD <span class="number">0</span>		<span class="comment">; 隐藏扇区数</span></span><br><span class="line">	<span class="keyword">BPB_TotSec32	</span>DD <span class="number">0</span>		<span class="comment">; wTotalSectorCount为0时这个值记录扇区数</span></span><br><span class="line">	<span class="keyword">BS_DrvNum	</span>DB <span class="number">0</span>		<span class="comment">; 中断 13 的驱动器号</span></span><br><span class="line">	<span class="keyword">BS_Reserved1	</span>DB <span class="number">0</span>		<span class="comment">; 未使用</span></span><br><span class="line">	<span class="keyword">BS_BootSig	</span>DB <span class="number">29</span>h		<span class="comment">; 扩展引导标记 (29h)</span></span><br><span class="line">	<span class="keyword">BS_VolID	</span>DD <span class="number">0</span>		<span class="comment">; 卷序列号</span></span><br><span class="line">	<span class="keyword">BS_VolLab	</span>DB <span class="string">'OrangeS0.02'</span><span class="comment">; 卷标, 必须 11 个字节</span></span><br><span class="line">	<span class="keyword">BS_FileSysType	</span>DB <span class="string">'FAT12   '</span>	<span class="comment">; 文件系统类型, 必须 8个字节</span></span><br></pre></td></tr></table></figure></p>
<p>把生成的Boot.bin写入磁盘引导扇区，运行的效果没有变。说明我们现在的软盘已经能被DOS以及Linux识别了，我们已经可以方便地往上添加或删除文件了。</p>
<h2 id="一个最简单的Loader"><a href="#一个最简单的Loader" class="headerlink" title="一个最简单的Loader"></a>一个最简单的Loader</h2><p>我们先写一个最小的，让其显示一个字符，然后进入死循环。<br>新建一个loader.asm，其代码如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">org	<span class="number">0100h</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="number">0B800h</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ah</span>, <span class="number">0Fh</span>				<span class="comment">; 0000: 黑底    1111: 白字</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="string">'L'</span></span><br><span class="line">	<span class="keyword">mov</span>	[<span class="built_in">gs</span>:((<span class="number">80</span> * <span class="number">0</span> + <span class="number">39</span>) * <span class="number">2</span>)], <span class="built_in">ax</span>	<span class="comment">; 屏幕第 0 行, 第 39 列。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">jmp</span>	$				<span class="comment">; 到此停住</span></span><br></pre></td></tr></table></figure></p>
<p>我们将其编译,命令如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">loader</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">loader</span><span class="selector-class">.bin</span></span><br></pre></td></tr></table></figure></p>
<p>为了以后扩展不出问题，我们将编译后的二进制文件放在某个段内偏移0x100的位置。</p>
<h2 id="加载Loader如内存"><a href="#加载Loader如内存" class="headerlink" title="加载Loader如内存"></a>加载Loader如内存</h2><p>要加载一个文件如内存，免不了要读软盘，这时就要用到BIOS中断int 13h。它的用法如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180227/hfIaF1Jjl8.png?imageslim" alt="mark">。<br>从上可知，中断需要的参数不是原来提到的从第0扇区开始的扇区号，而是柱面号、磁头号以及在当前柱面上的扇区号3个分量，所以需要我们自己来转换一下。对于1.44MB的软盘来说，总共有两面，每面80个磁道，每个磁道有18个扇区。下面的公式就是软盘容量的由来：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span>x <span class="number">80</span> x <span class="number">18</span> x <span class="number">512</span> =<span class="number">1.44</span>MB</span><br></pre></td></tr></table></figure></p>
<p>于是，磁头号、柱面号和起始扇区号可以用下图方法来计算：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180227/ifaIbHjIF9.png?imageslim" alt="mark"><br>下面，我们先写一个读软盘区的函数：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>	<span class="built_in">bp</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bp</span>, <span class="built_in">sp</span></span><br><span class="line">	<span class="keyword">sub</span>	<span class="built_in">esp</span>, <span class="number">2</span> <span class="comment">; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">byte</span> [<span class="built_in">bp</span>-<span class="number">2</span>], <span class="built_in">cl</span></span><br><span class="line">	<span class="keyword">push</span>	<span class="built_in">bx</span>			<span class="comment">; 保存 bx</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bl</span>, [BPB_SecPerTrk]	<span class="comment">; bl: 除数</span></span><br><span class="line">	<span class="keyword">div</span>	<span class="built_in">bl</span>			<span class="comment">; y 在 al 中, z 在 ah 中</span></span><br><span class="line">	<span class="keyword">inc</span>	<span class="number">ah</span>			<span class="comment">; z ++</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cl</span>, <span class="number">ah</span>			<span class="comment">; cl &lt;- 起始扇区号</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">dh</span>, <span class="built_in">al</span>			<span class="comment">; dh &lt;- y</span></span><br><span class="line">	<span class="keyword">shr</span>	<span class="built_in">al</span>, <span class="number">1</span>			<span class="comment">; y &gt;&gt; 1 (y/BPB_NumHeads)</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ch</span>, <span class="built_in">al</span>			<span class="comment">; ch &lt;- 柱面号</span></span><br><span class="line">	<span class="keyword">and</span>	<span class="number">dh</span>, <span class="number">1</span>			<span class="comment">; dh &amp; 1 = 磁头号</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">bx</span>			<span class="comment">; 恢复 bx</span></span><br><span class="line">	<span class="comment">; 至此, "柱面号, 起始扇区, 磁头号" 全部得到</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dl</span>, [BS_DrvNum]		<span class="comment">; 驱动器号 (0 表示 A 盘)</span></span><br><span class="line"><span class="symbol">.GoOnReading:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ah</span>, <span class="number">2</span>			<span class="comment">; 读</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="built_in">byte</span> [<span class="built_in">bp</span>-<span class="number">2</span>]		<span class="comment">; 读 al 个扇区</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">13h</span></span><br><span class="line">	<span class="keyword">jc</span>	.GoOnReading		<span class="comment">; 如果读取错误 CF 会被置为 1, </span></span><br><span class="line">					<span class="comment">; 这时就不停地读, 直到正确为止</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">esp</span>, <span class="number">2</span></span><br><span class="line">	<span class="keyword">pop</span>	<span class="built_in">bp</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>因为这段代码中用到了堆栈，要在程序开头初始化ss和esp<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseOfStack		<span class="built_in">equ</span>	<span class="number">07c00h</span>	<span class="comment">; 堆栈基地址(栈底, 从这个位置向低地址生长)</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">sp</span>, BaseOfStack</span><br></pre></td></tr></table></figure></p>
<p>读扇区的函数写好了，下面我们就开始在软盘中寻找Loader.bin<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor</span>	<span class="number">ah</span>, <span class="number">ah</span>	<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">dl</span>, <span class="built_in">dl</span>	<span class="comment">;  |  软驱复位</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">13h</span>	<span class="comment">; /</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">; 下面在 A 盘的根目录寻找 LOADER.BIN</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">word</span> [wSectorNo], SectorNoOfRootDirectory</span><br><span class="line"><span class="symbol">LABEL_SEARCH_IN_ROOT_DIR_BEGIN:</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">word</span> [wRootDirSizeForLoop], <span class="number">0</span>	<span class="comment">;  `. 判断根目录区是不是已经读完</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_NO_LOADERBIN		<span class="comment">;  /  如果读完表示没有找到 LOADER.BIN</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">word</span> [wRootDirSizeForLoop]	<span class="comment">; /</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, BaseOfLoader</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span>			<span class="comment">; es &lt;- BaseOfLoader</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">bx</span>, OffsetOfLoader	<span class="comment">; bx &lt;- OffsetOfLoader</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, [wSectorNo]		<span class="comment">; ax &lt;- Root Directory 中的某 Sector 号</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cl</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">call</span>	ReadSector</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">si</span>, LoaderFileName	<span class="comment">; ds:si -&gt; "LOADER  BIN"</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">di</span>, OffsetOfLoader	<span class="comment">; es:di -&gt; BaseOfLoader:0100</span></span><br><span class="line">	<span class="keyword">cld</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">dx</span>, <span class="number">10h</span></span><br><span class="line"><span class="symbol">LABEL_SEARCH_FOR_LOADERBIN:</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">dx</span>, <span class="number">0</span>				   <span class="comment">; `. 循环次数控制,</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_GOTO_NEXT_SECTOR_IN_ROOT_DIR <span class="comment">;  / 如果已经读完了一个 Sector,</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">dx</span>				   <span class="comment">; /  就跳到下一个 Sector</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cx</span>, <span class="number">11</span></span><br><span class="line"><span class="symbol">LABEL_CMP_FILENAME:</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">cx</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">	jz	LABEL</span>_FILENAME_FOUND	<span class="comment">; 如果比较了 11 个字符都相等, 表示找到</span></span><br><span class="line">	<span class="keyword">dec</span>	<span class="built_in">cx</span></span><br><span class="line">	<span class="keyword">lodsb</span>				<span class="comment">; ds:si -&gt; al</span></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">al</span>, <span class="built_in">byte</span> [<span class="built_in">es</span>:<span class="built_in">di</span>]</span><br><span class="line"><span class="symbol">	jz	LABEL</span>_GO_ON</span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_DIFFERENT		<span class="comment">; 只要发现不一样的字符就表明本 DirectoryEntry</span></span><br><span class="line">					<span class="comment">; 不是我们要找的 LOADER.BIN</span></span><br><span class="line"><span class="symbol">LABEL_GO_ON:</span></span><br><span class="line">	<span class="keyword">inc</span>	<span class="built_in">di</span></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_CMP_FILENAME	<span class="comment">; 继续循环</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_DIFFERENT:</span></span><br><span class="line">	<span class="keyword">and</span>	<span class="built_in">di</span>, <span class="number">0FFE0h</span>		<span class="comment">; else `. di &amp;= E0 为了让它指向本条目开头</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">di</span>, <span class="number">20h</span>			<span class="comment">;       |</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">si</span>, LoaderFileName	<span class="comment">;       | di += 20h  下一个目录条目</span></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_SEARCH_FOR_LOADERBIN<span class="comment">;    /</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">word</span> [wSectorNo], <span class="number">1</span></span><br><span class="line"><span class="symbol">	jmp	LABEL</span>_SEARCH_IN_ROOT_DIR_BEGIN</span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_NO_LOADERBIN:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">dh</span>, <span class="number">2</span>			<span class="comment">; "No LOADER."</span></span><br><span class="line">	<span class="keyword">call</span>	DispStr			<span class="comment">; 显示字符串</span></span><br><span class="line">%ifdef	_BOOT_DEBUG_</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="number">4c00h</span>		<span class="comment">; `.</span></span><br><span class="line">	<span class="keyword">int</span>	<span class="number">21h</span>			<span class="comment">; /  没有找到 LOADER.BIN, 回到 DOS</span></span><br><span class="line"><span class="meta">%else</span></span><br><span class="line">	<span class="keyword">jmp</span>	$			<span class="comment">; 没有找到 LOADER.BIN, 死循环在这里</span></span><br><span class="line"><span class="meta">%endif</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_FILENAME_FOUND:</span>			<span class="comment">; 找到 LOADER.BIN 后便来到这里继续</span></span><br><span class="line">	<span class="keyword">jmp</span>	$			<span class="comment">; 代码暂时停在这里</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码就是遍历根目录区所有的扇区，将每一个扇区加载入内存，然后从中寻找文件名为Loader.bin的条目，直到找到为止。找到的那一刻，es:di是指向条目中字母N后面的那个字符。<br>接着我们编译出boot.bin<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">boot</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">boot</span><span class="selector-class">.bin</span></span><br></pre></td></tr></table></figure></p>
<p>,然后在bximage生成一个软盘映像，然后在Linux下输入命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nasm loader<span class="selector-class">.asm</span> -o loader.bin</span><br><span class="line"><span class="selector-tag">dd</span> <span class="keyword">if</span>=boot<span class="selector-class">.bin</span> of=<span class="selector-tag">a</span><span class="selector-class">.img</span> bs=<span class="number">512</span> count=<span class="number">1</span> conv=notrunc</span><br><span class="line">sudo mount -o loop <span class="selector-tag">a</span><span class="selector-class">.img</span> /mnt/floppy</span><br><span class="line">sudo cp loader<span class="selector-class">.bin</span> /mnt/floppy/ -v </span><br><span class="line">sudo umount /mnt/floppy</span><br></pre></td></tr></table></figure></p>
<h2 id="向Loader交出控制权"><a href="#向Loader交出控制权" class="headerlink" title="向Loader交出控制权"></a>向Loader交出控制权</h2><p>上面代码调试通过后，我i门就已经成功的将Loader加载入内存了，接着我们加上一个跳转。开始执行Loader<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp	</span><span class="keyword">BaseOfLoader:OffsetOfLoader	</span><span class="comment">; 这一句正式跳转到已加载到内</span></span><br><span class="line">						<span class="comment">; 存中的 LOADER.BIN 的开始处，</span></span><br><span class="line">						<span class="comment">; 开始执行 LOADER.BIN 的代码。</span></span><br><span class="line">						<span class="comment">; Boot Sector 的使命到此结束。</span></span><br></pre></td></tr></table></figure></p>
<p>最后的结果如下<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180227/2icjEELJIa.png?imageslim" alt="mark"></p>
<h1 id="保护下的“操作系统”"><a href="#保护下的“操作系统”" class="headerlink" title="保护下的“操作系统”"></a>保护下的“操作系统”</h1><p>为了让自己的操作系统内核至少应该可以在Linux下用GCC编译链接，所以我们假设已经有了一个内核，Loader肯定要加载它乳内存，而且内核开始执行对的时候肯定已经在保护模式下了，所以Loader要做的只要有两件事：</p>
<ul>
<li>加载内核如内存</li>
<li>跳入保护模式<br>将来的内核是在Linux下编译链接出的ELF格式文件，直接放进内存肯定不行，下一章就会开始研究ELF格式。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> FAT12 </tag>
            
            <tag> Loader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[财富之路-2018最容易赚钱的调查问卷平台]]></title>
      <url>/2018/02/25/%E8%B4%A2%E5%AF%8C%E4%B9%8B%E8%B7%AF-2018%E6%9C%80%E5%AE%B9%E6%98%93%E8%B5%9A%E9%92%B1%E7%9A%84%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7%E5%B9%B3%E5%8F%B0/</url>
      <content type="html"><![CDATA[<h1 id="91问问调查"><a href="#91问问调查" class="headerlink" title="91问问调查"></a>91问问调查</h1><a id="more"></a>
<p><a href="https://www.91wenwen.net/event/invite/hn1XX9NE0Ks%253D" target="_blank" rel="noopener">https://www.91wenwen.net/event/invite/hn1XX9NE0Ks%253D</a></p>
<pre><code>  1、注册送积分。注册的时候送50积分=0.5元，等你完善个人信息的时候再送200积分=2.5元。

  2、调查赚钱。登陆账户后，进入调查中心，里面有适合你的调查问卷，认真参与，即可获得奖励。每参加一次调查，获得2-10元。

  3、有奖出题。参加快速问答（也就是投票）的设计，设计的问答被网站选用即可获取200积分
</code></pre><h1 id="投吧"><a href="#投吧" class="headerlink" title="投吧"></a>投吧</h1><p><a href="http://www.votebar.com/r.aspx?r=572819231769001075" target="_blank" rel="noopener">http://www.votebar.com/r.aspx?r=572819231769001075</a></p>
<p>老牌网站，操作简单，内容丰富，成功率高，二十四小时更新，奖励会即时到账户里，满10元可提现；每天签到就有奖，最大的缺点是有时有点卡，一旦出现卡顿，成功机率就会下降，这时就下线吧，等下次再答。这个网站是我的最爱，因为第一个注册的就是它，从开始到现在，已经过万字头。</p>
<h1 id="第一调查网"><a href="#第一调查网" class="headerlink" title="第一调查网"></a>第一调查网</h1><p><a href="http://www.1diaocha.com/user/Register.aspx?account=wcq19941215" target="_blank" rel="noopener">http://www.1diaocha.com/user/Register.aspx?account=wcq19941215</a><br>应该说国内最早开始的调查网站，内容丰富</p>
]]></content>
      
        <categories>
            
            <category> 财富之路 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网赚 </tag>
            
            <tag> 调查问卷 </tag>
            
            <tag> 学生兼职 </tag>
            
            <tag> 投吧 </tag>
            
            <tag> 赚钱 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-3）]]></title>
      <url>/2018/01/24/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-3%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h1><p>说到这个，应该不会太陌生，但是对它可能值停留在理论学习阶段，没法像数据结构那样，理性的认识，下面我们先从几个问题出发<br><a id="more"></a></p>
<ul>
<li>什么叫做“页”<br>所谓“页”，就是一块内存，在80386中，页的大小是固定的4096字节。而后来，页的大小还可以是2MB或者4MB，并且可以访问多于4GB的内存。</li>
<li>逻辑地址、线性地址、物理地址<br>在未打开分页机制时，线性地址等同于物理地址。当分页开启时，分段机制将逻辑地址转换成线性地址，然后在通过分页机制变为物理地址。</li>
<li>为什么分页<br>-分段管理机制，已经提供了很好的保护机制，而分页的主要目的是在线实现虚拟存储器。线性地址中，任意一个页都能映射到物理地址中的任何一个页。<h2 id="1-分页机制概述"><a href="#1-分页机制概述" class="headerlink" title="1.分页机制概述"></a>1.分页机制概述</h2>分页机制就像一个函数：<br>物理地址 = f(线下地址)<br>我们通过下图看看f是怎样的。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/hA35m7j963.png?imageslim" alt="mark"><br>如图所示，转换使用两级页表，第一级叫做页目录，大小为4KB，存储在一个物理页中，每个表项4字节长，公有1024个表项。每个表项对应第二级的一个页表，第二级的每一个页表也有1024个表项，每一个表项对应一个物理页。页目录的表项简称PDE，页表的表项简称PTE.<br>进行转化时，先是从由寄存器cr3指定的页目录中根据线性地址的高10位得到页表地址，然后在页表中根据线性地址的第12到21位得到物理页首地址，将这个首地址加上线性地址低12位，便得到了物理地址。<br>分页机制是否生效的开关位于cr0的最高位PG位。如果PG=1，则分页机制生效。<h2 id="2-编写代码启动分页机制"><a href="#2-编写代码启动分页机制" class="headerlink" title="2.编写代码启动分页机制"></a>2.编写代码启动分页机制</h2>下面，我们在pmtest2.asmde 基础进行修改，将实验内存写入和读取的描述符、代码以及数据统统去掉，并添加这样一个函数SetupPaging,代码如下<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">PageDirBase		<span class="built_in">equ</span>	<span class="number">200000h</span>	<span class="comment">; 页目录开始地址: 2M</span></span><br><span class="line">PageTblBase		<span class="built_in">equ</span>	<span class="number">201000h</span>	<span class="comment">; 页表开始地址: 2M+4K</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">LABEL_DESC_PAGE_DIR:</span> Descriptor PageDirBase, <span class="number">4095</span>, DA_DRW<span class="comment">;Page Directory</span></span><br><span class="line"><span class="symbol">LABEL_DESC_PAGE_TBL:</span> Descriptor PageTblBase, <span class="number">1023</span>, DA_DRW|DA_LIMIT_4K<span class="comment">;Page Tables</span></span><br><span class="line">...</span><br><span class="line">SelectorPageDir		<span class="built_in">equ</span>	LABEL_DESC_PAGE_DIR	- LABEL_GDT</span><br><span class="line">SelectorPageTbl		<span class="built_in">equ</span>	LABEL_DESC_PAGE_TBL	- LABEL_GDT</span><br><span class="line">...</span><br><span class="line"><span class="comment">; 启动分页机制 --------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">SetupPaging:</span></span><br><span class="line">	<span class="comment">; 为简化处理, 所有线性地址对应相等的物理地址.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">; 首先初始化页目录</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, SelectorPageDir	<span class="comment">; 此段首地址为 PageDirBase</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ecx</span>, <span class="number">1024</span>		<span class="comment">; 共 1K 个表项</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">edi</span>, <span class="built_in">edi</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, PageTblBase | PG_P  | PG_USU | PG_RWW</span><br><span class="line"><span class="symbol">.1:</span></span><br><span class="line">	<span class="keyword">stosd</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">eax</span>, <span class="number">4096</span>		<span class="comment">; 为了简化, 所有页表在内存中是连续的.</span></span><br><span class="line">	<span class="keyword">loop</span>	.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">; 再初始化所有页表 (1K 个, 4M 内存空间)</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, SelectorPageTbl	<span class="comment">; 此段首地址为 PageTblBase</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ecx</span>, <span class="number">1024</span> * <span class="number">1024</span>	<span class="comment">; 共 1M 个页表项, 也即有 1M 个页</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">edi</span>, <span class="built_in">edi</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, PG_P  | PG_USU | PG_RWW</span><br><span class="line"><span class="symbol">.2:</span></span><br><span class="line">	<span class="keyword">stosd</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">eax</span>, <span class="number">4096</span>		<span class="comment">; 每一页指向 4K 的空间</span></span><br><span class="line">	<span class="keyword">loop</span>	.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, PageDirBase</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cr3</span>, <span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">	<span class="keyword">or</span>	<span class="built_in">eax</span>, <span class="number">80000000h</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">jmp</span>	short .<span class="number">3</span></span><br><span class="line"><span class="symbol">.3:</span></span><br><span class="line">	<span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="comment">; 分页机制启动完毕 ----------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，PageDirBase和PageTblBase是两个宏，指定了页目录表和页表在内存中的位置。页目录表位于地址处2MB，有1024个表项，占用4KB空间爱你，紧接着页目录表便是页表，位于地址2MB+4KB处。<br>为了罗技清晰和代码编写便捷，我们分别定义两个段，用来存放页目录表和页表，大小分别是4KB和4MB。<br>为了简单起见，我们就爱那个所有线性地址映射到相同的物理地址，于是线性地址和物理地址的关系符合下面的公式:<br>物理地址 = f（线性地址） = 线性地址<br>下面，我们看看PDE和PTE</p>
<h2 id="3-PDE和PTB"><a href="#3-PDE和PTB" class="headerlink" title="3.PDE和PTB"></a>3.PDE和PTB</h2><p>PDE:<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/00aBD7D55j.png?imageslim" alt="mark"><br>PTE：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/ImdLmm0ldI.png?imageslim" alt="mark"></p>
<ul>
<li>读写权限。此位与U/S位和寄存器cr0中的WP位相互作用。R/W=0表示只读；R/W=1表示刻度并可写。</li>
<li>U/S指定一个页或者一组页的特权级。此位与R/W位和寄存器cr0中的WP位相互作用。U/S=0表示系统级别，如果CPL为0、1、2那么他便是在此级别；U/S=1表示用户级别，如果CPL为3，那么他便是在此级别。<br>如果cr0中WP位为0，那么即便用户级页面的R/W=0，系统级陈翔任然具备写权限；如果WP位为1，那么系统级程序也不能写入用户级只读页。</li>
<li>PWT用于控制对单个页或者页表的缓冲策略。</li>
<li>PCD用于控制对单个页湖综合页表的缓冲。</li>
<li>A指示页或页表是否被访问。</li>
<li>D指示页或页表是否被写入</li>
<li>PS决定页大小</li>
<li>PAT选择PAT条目</li>
<li>G指示全局页<br>CPU会将最近常用的页目录和页表项保存在一个叫做TLB的缓冲区中。只有在TLB中找不到被请求页的转换信息时，才会到内存中去寻找。<br>当页目录或页表项被更改时，操作系统应该马上使TLB中对应的条目无效，以便下次使用到此条目时让他获得更新。<br>当cr0被加载时，所有TLB都会自动无效，除非页或页表条目的G位被设置。<h2 id="4-cr3"><a href="#4-cr3" class="headerlink" title="4.cr3"></a>4.cr3</h2>cr0指向页目录表，它的结构如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/Cg64A9kl1F.png?imageslim" alt="mark"><br>cr3又叫做PDBR。它的高20位将是页目录表首地址的高20位，页目录首地址的低12位会是0，也就是说页目录表会是4KB对齐的。类似的，PDE中的页表基址以及PTE的页基址也是如此。<h2 id="5-克勤克俭用内存"><a href="#5-克勤克俭用内存" class="headerlink" title="5.克勤克俭用内存"></a>5.克勤克俭用内存</h2>前面，我们用来 4MB的空间来存放页表，并用它映射了4GB的内存空间，而我们的物理内存不见得有这么大，这显然是太浪费了。如果我们的内存总数只有16MB的话，知识页表就占有25%的内存空间爱你了。而实际上如果仅仅是对等映射的话，16MB的内存只要4个页表就够了。所以我们有必要知道内存有多大，然后根据内存大小确定多少页表是够用的。<br>那么程序如何知道机器内存有多少内存呢？实际上方法不止一个，在此，我们仅介绍一种通用性比较器的，就是利用中断15h.<br>在调用它之前，需要填充如下寄存器：</li>
<li>eax  int 15h 可完成许多工作，主要由ax的值决定，我们想要获取内存信息，需要将ax赋值为0E820h。</li>
<li>ebx  放置着“后续值”，第一次调用时ebx必须为0.</li>
<li>es:di  指向一个地址范围描述符结构ARDS，BIOS将会填充此结构。</li>
<li>ecx es：di所指向的地址范围描述符结构的大小，以字节为单位。</li>
<li>edxd 0534D4150h(‘SMAP’)    BIOS将会使用此标志，对调用者将要请求的系统映像信息进行校验，这些信息会被BIOS放置到es:di所指向的结构中。<br>中断调用之后，结果存放于下列寄存器之中。</li>
<li>CF  CF=0表示没有错误，否则存在错误。</li>
<li>eax 0534D4150h(‘SMAP’).</li>
<li>es:di 返回的地址房范围描述符结构指针，和输入值相同。</li>
<li>ecx BIOS填充在地址范围描述中的字节数量，被BIOS所返回的最小值是20字节。</li>
<li>ebx 这里放置着为等到下一个地址描述符所需要的后续值，这个值的实际形势依赖于具体的BIOS的实现，调用者不必关心他的具体形式，只需在下次迭代时将其原封不懂的放置在ebx中，就可以通过它获取下一个地址范围描述符。如果它的值为0，表示它是组后一个地址范围描述符。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/5hlIemfmi3.png?imageslim" alt="mark"><h2 id="6-进一步体会分页机制"><a href="#6-进一步体会分页机制" class="headerlink" title="6.进一步体会分页机制"></a>6.进一步体会分页机制</h2>在此之前，不知道你有没有注意股哦一个细节，如果你写一个程序，并改个名复制一份，然后同时调用，你会发现，从变量地址到寄存器的值，几乎全部都是一样的！这就是分页机制的功劳，下面我们就来摸摸你下这个效果。<br>先执行某个线性地址处的模块，然后通过改变cr3来转换地址映射关系，再执行同一个线性地址处的模块，由于地址映射已经改变，所以两次得到的应该是不同的输出。<br>映射关系转化前的情形如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/ill3jgE9Cf.png?imageslim" alt="mark"><br>从上图很清楚的可以看到，LinearAddrDemo地址映射到ProcFoo打印出红色的字符串Foo，所以执行时我们应该可以看到红色的Foo。<br>随后，我们改版地址映射关系，变化成如图所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/F947bj2jC6.png?imageslim" alt="mark"><br>页目录表和页表的切换让LinearAddrDemo映射到ProcBar处，所以当我们再一次调用过程ProcPagingDemo时，程序将装异到ProcBar处执行，我们将看到红色的字符串Bar。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180125/lH7hBj2LF4.png?imageslim" alt="mark"><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1>中断我们一直在用，最近的一次是通过int 15h得到了计算机内存信息。但是这都是在实模式下进行的，然后在保护模式下显示出来。<br>这是因为在保护模式下，中断机制发生了很大变化，原来的中断向量表已经被IDT所代替，实模式下能用的BIOS中断在保护模式下已经不能用了。你可能没有听过IDT，它也是个描述符，叫做中断描述符表。IDT中的描述符可以是下面三种之一：</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
<li>任务门描述符<br>IDT的作用是将每一个中断向量和一个描述符对应起来。<br>下图是中断向量到中断处理程序的对应过程。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/EhecH46D7i.png?imageslim" alt="mark"><br>联系调用门，我们知道，其实中断门和陷阱门的作用机理几乎是一样的，只不过使用调用门时使用call指令，而这里我们使用int指令。<br>其中，IDT中的任务门在某些操作系统中根本就没有用到，所以我们不做过多关注。<br>对比调用门我们知道，在中断门和陷阱门中BYTE4的低5位变成了保留位，而不再是Param Count。而且，表示TYPE的4位也将变为0XE(中断门或0XF(陷阱门。<br>知道这些还不够，因为中断还涉及处理器与硬件的联系等。<h2 id="中断和异常机制"><a href="#中断和异常机制" class="headerlink" title="中断和异常机制"></a>中断和异常机制</h2>中断和异常都是在程序执行过程中的强制转移，转移到相应的处理程序。中断通常在程序执行时因为硬件而随机发生，它们通常用来处理处理器外部的事件，比如外围设备的请求。当然软件也可以通过int n指令来产生中断。异常则通常在处理器执行指令过程中检测到错误时发生。<br>他们通俗来讲，都是软件或者硬件发生了某种情形而通知处理器的行为。<br>那么。处理器可以处理哪些问题，以及如何处理呢？下表给出了答案：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/2H280kAi10.png?imageslim" alt="mark"><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/1L1li00eLg.png?imageslim" alt="mark"><br>三种错误类型：</li>
<li>Fault 是一种可被更正的异常，而且一旦被更正，程序可以不失连续地继续执行。当一个fault发生时，处理器会吧产生fault的指令之前的状态保存起来。</li>
<li>Trap 是一种在发生trap的指令之后立即被报告的异常，它也允许程序或任务不失连续性的继续执行。异常处理程序的返回地址将会是产生trap的指令之后的那条指令。</li>
<li>Abort 是一种不总是报告精确异常发生未知的异常，他不允许陈翔或任务继续执行，而是用来报告严重错误的。<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2>中断有外部中断，由硬件产生的中断，另一种是由指令int n产生的中断。<br>外部中断，分为不可屏蔽中断（NMI）和可屏蔽中断两种。分别由CPU的两根引脚NMI和INTR来接收。如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/EmL2lGC0lC.png?imageslim" alt="mark"><br>可屏蔽中断与CPU的关系是通过对可编程中断控制器8259A建立起来的。8259A是中断机制中所有外围设备的一个代理，这个代理不但可以根据优先级在同时发生中断的设备中选择应该处理的请求，而且可以通过对其寄存器的设置来屏蔽或打开相应的中断。<br>主8259A对应的端口地址为20h和21h，从8259A对应的端口地址是A0h和A1h。<h2 id="编程操作8259A"><a href="#编程操作8259A" class="headerlink" title="编程操作8259A"></a>编程操作8259A</h2>对8259A的设置是通过向相应的端口写入特定的ICW（Initialization Command Word）来实现的，它的格式如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/45eb5m4BF5.png?imageslim" alt="mark"><br>下面是设置8259A的代码项目地址：<br><a href="https://pan.baidu.com/s/1d3TV7C" target="_blank" rel="noopener">下载地址</a><br>密码：akis<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Init8259A ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">Init8259A:</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">011h</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">020h</span>, <span class="built_in">al</span>	<span class="comment">; 主8259, ICW1.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">0A0h</span>, <span class="built_in">al</span>	<span class="comment">; 从8259, ICW1.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">020h</span>	<span class="comment">; IRQ0 对应中断向量 0x20</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">021h</span>, <span class="built_in">al</span>	<span class="comment">; 主8259, ICW2.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">028h</span>	<span class="comment">; IRQ8 对应中断向量 0x28</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">0A1h</span>, <span class="built_in">al</span>	<span class="comment">; 从8259, ICW2.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">004h</span>	<span class="comment">; IR2 对应从8259</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">021h</span>, <span class="built_in">al</span>	<span class="comment">; 主8259, ICW3.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">002h</span>	<span class="comment">; 对应主8259的 IR2</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">0A1h</span>, <span class="built_in">al</span>	<span class="comment">; 从8259, ICW3.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">001h</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">021h</span>, <span class="built_in">al</span>	<span class="comment">; 主8259, ICW4.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">0A1h</span>, <span class="built_in">al</span>	<span class="comment">; 从8259, ICW4.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">11111110b</span>	<span class="comment">; 仅仅开启定时器中断</span></span><br><span class="line">	<span class="comment">;mov	al, 11111111b	; 屏蔽主8259所有中断</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">021h</span>, <span class="built_in">al</span>	<span class="comment">; 主8259, OCW1.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="number">11111111b</span>	<span class="comment">; 屏蔽从8259所有中断</span></span><br><span class="line">	<span class="keyword">out</span>	<span class="number">0A1h</span>, <span class="built_in">al</span>	<span class="comment">; 从8259, OCW1.</span></span><br><span class="line">	<span class="keyword">call</span>	io_delay</span><br><span class="line"></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="comment">; Init8259A ---------------------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这段代码分别往主、从两个8259A各写入了4个ICW。在往8259A写入ICW2时，我们看到IRQ0对应了中断向量号20h，于是，IRQ0~IRQ7就对应中断向量20h~27h；类似的还有其他的。<br>在代码后半部分，我们通过对端口21h和A1h的操作屏蔽了所有的外部中断，这一次写入的不再是ICW了，而是OCW(Operation Control Word)格式如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/F6lH73eheb.png?imageslim" alt="mark"><br>可见，若想屏蔽某一个中断，将对应的那一位设为1即可。</p>
<h2 id="建立IDT以及实现一个中断"><a href="#建立IDT以及实现一个中断" class="headerlink" title="建立IDT以及实现一个中断"></a>建立IDT以及实现一个中断</h2><p>对8259A操作完成后，就是建立IDT了。<br>为了方便操作，我们把IDT放进一个单独的段中。在pmtest9a.asm中可以看到，这个iDT不能再简单了，全部的255个描述符完全相同，都设置指向SelectorCode32:SpuriousHandler的中断门。SUpriousHandler也很简单，在屏幕的右上角打印红色的！，然后进入死循环。<br>我们可以修改下IDT,把80h号中断单独列出来，并新增加一个函数来处理这个中断：UserIntHandler，它和SuprioustHandler很类似，只是在函数末尾通过iretd指令返回，而不是进入四循环。代码如pmtest9c.asm，运行结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/8CElG4EK19.png?imageslim" alt="mark"></p>
<h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><p>可屏蔽中断与NMI的区别在于是否收到IF位的影响，而8259A的中断屏蔽寄存器（IMR）也影响着中断是否会被响应。所以，外部可屏蔽中断的发生就受到两个因素的影响，只有当IF位为1，并且IMR相应位为0时才会发生。<br>在代码pmtest9.asm的387行到392行可以看到，这个中断处理程序很简单，除了发送EOI的两行语句以及iretd，只有一条指令，就是把屏幕第0行、第70行的字符增一，变成ASCII中位于它后面的字符、由于第0行、第70行已被写入字符I,所以第一次中断发生时，那里会变成J，再次中断就变成K,以后每发生一次时钟中断，字符就会变动一次，就会看到不断变化中的字符。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/f7gd74icm1.png?imageslim" alt="mark"></p>
<h1 id="保护模式下的I-O"><a href="#保护模式下的I-O" class="headerlink" title="保护模式下的I/O"></a>保护模式下的I/O</h1><p>保护模式对I/O也做了限制，用户进程如果不被允许，是无法进行I/O操作的，这种限制通过两个方面来实现，IOPL和I/O许可位图。</p>
<ul>
<li>IOPL<br>她位于寄存器eflags的第12、13位，如图<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180126/ikd32HbKcL.png?imageslim" alt="mark"><br>指令in、ins、out、outs、cli、sti只有在CPL&lt;=IOPL时才执行。<br>可以改变IOPL的指令只有popf和iretd，只有运行在ring0的程序才能将其改变。运行在低特权级下的程序无法改变IOPL.<br>指令popf同样可以用来改变IF,只有CPL&lt;=IOPL时，popf才可以成功将IF改变。</li>
<li>I/O许可位图<br>之所以叫做位图，是因为它的每一位表示一个字节的端口地址是否可用，若为0表示可用，若为1表示不可用。由于每一个任务都可以有单独的TSS，所以每一个任务可以有它单独的I/O许可位图。<br>I/O许可位图必须以0FFh结尾。若I/O许可位图基址大于或等于TSS段界限，就表示没有I/O许可位图，若CPL&lt;=IOPL，则所有I/O指令都会引起异常。I/O许可位图的使用使得即时在同一特权级下不同的任务也可以有不同的I/O访问权限<h1 id="保护模式小结"><a href="#保护模式小结" class="headerlink" title="保护模式小结"></a>保护模式小结</h1>“保护模式”包含如下几个方面的含义：</li>
<li>在GDT、LDT以及IDT中，每一个描述符都有自己的界限和属性等内容，是对描述符所描述对象的一种限定和保护</li>
<li>分页机制中的PDE和PTE都含有R/W以及U/S位，提供页级保护</li>
<li>页式存储的使用使得应用程序使用的是线性地址空间而不是物理地址，于是物理内存就被保护起来</li>
<li>中断不再像实模式下一样使用，也提供特权检验等内容</li>
<li>I/O指令不再随便使用，于是端口被保护起龙</li>
<li>在程序运行过程中，如果遇到不同特权级间的访问等情况，会对CPL、RPL、DPL、IOPL等内容进行非常严格的检验，同时可能伴随堆栈的切换，这都对不同层级的程序进行了保护。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> 页式存储 </tag>
            
            <tag> 中断和异常 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-2）]]></title>
      <url>/2018/01/20/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-2%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="保护模式进阶"><a href="#保护模式进阶" class="headerlink" title="保护模式进阶"></a>保护模式进阶</h1><p>前面我们学习了保护模式，对它的一个整体有了了解，其中突出讲解了保护模式下的强大寻址能力，但是保护模式不仅仅有这个优点，下面我们继续学习保护模式。<br><a id="more"></a></p>
<h1 id="1-补个坑"><a href="#1-补个坑" class="headerlink" title="1.补个坑"></a>1.补个坑</h1><p>前面我们还是把保护模式写在引导扇区，这就限制在了512字节，我们就借用DOS的引导扇区来解除这个限制。<br>首先，我们按照如下操作进行：</p>
<ul>
<li>到Bochs官网下载FreeDOs。解压后将其中的a.img复制到工作目录下，并改名为freedos.img。</li>
<li>然后用bximage深层一个软盘映像，命名为pm.img。</li>
<li><p>在修改bochsrc，为如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">###############################################################</span><br><span class="line"># Configuration file for Bochs</span><br><span class="line">###############################################################</span><br><span class="line"></span><br><span class="line"># how much memory the emulated machine will have</span><br><span class="line">megs: <span class="number">32</span></span><br><span class="line"></span><br><span class="line"># filename <span class="keyword">of</span> ROM images</span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-latest  </span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest </span><br><span class="line"></span><br><span class="line"># what disk images will be used</span><br><span class="line">floppya: <span class="number">1</span>_44=freedos.img, status=inserted</span><br><span class="line">floppyb: <span class="number">1</span>_44=pm.img, status=inserted</span><br><span class="line"></span><br><span class="line"># choose the boot disk.</span><br><span class="line">boot: a</span><br><span class="line"></span><br><span class="line"># <span class="keyword">where</span> do we send log messages?</span><br><span class="line"># log: bochsout.txt</span><br><span class="line"></span><br><span class="line"># disable the mouse</span><br><span class="line">mouse: enabled=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"># enable key mapping, using US layout <span class="keyword">as</span> default.</span><br><span class="line">keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后启动bochs ,初始化b盘，如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/EF4FdhJKB7.png?imageslim" alt="mark"></p>
</li>
<li><p>再将代码中的07c00h改为0100h，并重新编译如图</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">pmtest2</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">pmtest2</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再将pmtest2.com复制到软盘pm.img上,执行如下图命令：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop pm<span class="selector-class">.img</span> /mnt/floppy</span><br><span class="line">sudo cp pmtest2<span class="selector-class">.com</span> /mnt/floppy/</span><br><span class="line">sudo umount /mnt/floppy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/IciDc4aDlH.png?imageslim" alt="mark"><br>最后的调试结果如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/7Bklcg40F5.png?imageslim" alt="mark"></p>
<h2 id="2-保护模式进阶正题"><a href="#2-保护模式进阶正题" class="headerlink" title="2.保护模式进阶正题"></a>2.保护模式进阶正题</h2><p>坑补完了，下面正式开始保护模式的进阶学习，前面我们提到实模式下1MB的寻址能力太差了，上一篇为了突出重点，所以最后直接写的死循环，所以想要退出，只能重启电脑，现在我们尝试体验下保护模式强大的寻址能力。<br>首先实验下读写大地址内存。在前面的代码的基础上，新建一个段段以5MB为基址，远远超出实模式下的1MB界限。<br>新增的代码段为：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LABEL_DESC_DATA:</span>   Descriptor    <span class="number">0</span>,      DataLen-<span class="number">1</span>, D<span class="built_in">A_DRW</span>    <span class="comment">; Data</span></span><br><span class="line"><span class="symbol">LABEL_DESC_STACK:</span>  Descriptor    <span class="number">0</span>,     TopOfStack, D<span class="built_in">A_DRWA</span>+D<span class="built_in">A_32</span><span class="comment">; Stack, 32 位</span></span><br><span class="line"><span class="symbol">LABEL_DESC_TEST:</span>   Descriptor <span class="number">0500000</span>h,     <span class="number">0</span>ffffh, D<span class="built_in">A_DRW</span></span><br></pre></td></tr></table></figure></p>
<p>在上篇代码的这个位置：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/KehElbkK9g.png?imageslim" alt="mark"><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectorData	</span>	<span class="meta">equ</span>	LABEL_DESC_DATA		- LABEL_GDT</span><br><span class="line"><span class="keyword">SelectorStack	</span>	<span class="meta">equ</span>	LABEL_DESC_STACK	- LABEL_GDT</span><br><span class="line"><span class="keyword">SelectorTest	</span>	<span class="meta">equ</span>	LABEL_DESC_TEST		- LABEL_GDT</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/7208m6j05d.png?imageslim" alt="mark"><br>然后需要添加的代码如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .data1]	 ; 数据段</span><br><span class="line">ALIGN	32</span><br><span class="line">[BITS	32]</span><br><span class="line">LABEL_DATA:</span><br><span class="line">SPValueInRealMode	dw	0</span><br><span class="line">; 字符串</span><br><span class="line">PMMessage:		db	<span class="string">"In Protect Mode now. ^-^"</span>, 0	; 在保护模式中显示</span><br><span class="line">OffsetPMMessage		equ	PMMessage - $$</span><br><span class="line">StrTest:		db	<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>, 0</span><br><span class="line">OffsetStrTest		equ	StrTest - $$</span><br><span class="line">DataLen			equ	$ - LABEL_DATA</span><br><span class="line">; END of [SECTION .data1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 全局堆栈段</span><br><span class="line">[SECTION .gs]</span><br><span class="line">ALIGN	32</span><br><span class="line">[BITS	32]</span><br><span class="line">LABEL_STACK:</span><br><span class="line">	times 512 db 0</span><br><span class="line"></span><br><span class="line">TopOfStack	equ	$ - LABEL_STACK - 1</span><br><span class="line"></span><br><span class="line">; END of [SECTION .gs]</span><br></pre></td></tr></table></figure></p>
<p>如下图所示<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/h0C6F3aEDG.png?imageslim" alt="mark"><br>接下来我就不贴代码了，主要分析代码，理解其中原理，具体代码可以在<a href="https://pan.baidu.com/s/1htgaLMG" target="_blank" rel="noopener">这里下载</a>密码为：xang</p>
<h2 id="3-代码以及原理分析"><a href="#3-代码以及原理分析" class="headerlink" title="3.代码以及原理分析"></a>3.代码以及原理分析</h2><p>我们直接看到第166行，也就是[SECTION .s32]段，这一段首先将ds、es、gs分别初始化，ds指向新增的数据段，es指向新增的5MB内存，gs指向显存。<br>之后是显示字符串，再然后是开始读写大地址内存了（第198行到200行），由于要读写2次相同的内存，所以我们读写分别用函数TestRead、TestWrite来表示这两个函数的入口分别在206行和222行，其中TestRead还调用了DispAL（将al中的字节用16进制数表示，字的前景色任然是红色）和DispReturn（模拟回车，让下一个字符显示在下一行的开头处）这两个函数。注意edi始终要指向显示的下一个字符的位置，所以，如果程序除了显示字符外还用到edi，需要事先保存它的值，以免在显示时产生混乱。<br>最后，我们说下如何在保护模式下跳转到实模式。因为我们不能从323位代码返回实模式，只能从16位返回，这是因为无法实现从32位代码段返回时，cs高速缓冲寄存器中的属性符合实模式的要求（实模式不能改变段属性）。所以我们增加了第15行Normal描述符，在返回实模式之前，应该把选择子SelectorNormal加载到ds、es、ss.<br>下面我们再看看返回到实模式的段[SECTION .s16code]，如上所说，把Normal赋给ds、es、fs、gs和ss，然后cr0的PE位置为0，接下来跳转。<br>这块还不理解，以后理解了再补上！！！<br>再跳回实模式之后，关闭A20，打开中断，重新回到原来的样子。</p>
<h2 id="4-LDT（Local-Descriptor-Table）"><a href="#4-LDT（Local-Descriptor-Table）" class="headerlink" title="4.LDT（Local Descriptor Table）"></a>4.LDT（Local Descriptor Table）</h2><h3 id="感性认识"><a href="#感性认识" class="headerlink" title="- 感性认识"></a>- 感性认识</h3><p>LDT是局部描述符表的建成，我们先还是通过代码来对它产生感性认识。在这里，我就不再贴代码了，仅仅把重要的代码写出来，方便理解。下面有这个部分的完整可执行代码下载。<br>下面是代码执行完的结果：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180120/LgBf31BHBe.png?imageslim" alt="mark"><br>[这里下载]<a href="https://pan.baidu.com/s/1mkj6GPi" target="_blank" rel="noopener">https://pan.baidu.com/s/1mkj6GPi</a>)<br>密码为：uzja</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="- 代码分析"></a>- 代码分析</h3><p>在pmtest3.asm中，从11行开始到134行，是对LDT的初始化，包括对选择子的创建。<br>接着是新增的两个节，其中一个是新的描述符表，也就是LDT，另一个是代码段，对应新增的LDT中的一个描述符。<br>然后在217行到220行，是加载ldte，这里和GDT很相似，但是在选择子上，多了一个SA_TIL,这个属性在pm.inc中可以看到，是：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SA_TIL</span> <span class="meta">EQU</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180121/A0IGBk32Ec.png?imageslim" alt="mark"><br>从上图可知这个属性将SelectorLDTCodeA的TI位 置为1.<br>这一位是区别GDT的选择子和LDT的选择子的关键。如果TI被置位，那么系统将从LDT中寻找相应描述符。<br>总结下这部分内容，我们已经看到，在描述符中段基址段界限定义了一个段的范围，这无疑是一种对段的保护。所以，不知不觉，我们已经接触到了一些保护机制。接下来，我们将加深对“保护”的理解，下面，我们即将介绍的是特权级。</p>
<h2 id="5-特权级"><a href="#5-特权级" class="headerlink" title="5.特权级"></a>5.特权级</h2><ul>
<li>特权级概述<br>在IA32的分段机制中，特权级总共有4个特权级别，从高到低分别为0、1、2、3.数字越小特权级越大。<br>所以我们也将高特权的称为内层，而把低特权级称为外层。</li>
<li>CPL、DPL、RPL<br>CPU通过识别以上三种特权级进行特权级检验。<br>首先，CPL（Current Priviliege Level）。它是当前只想能够的程序或者任务的特权级，被存储在cs和ss的第0位和第1位上。在通常情况下，CPL等于代码所在的段的特权级。在遇到一致代码段时，可以被相同或者更低特权的代码访问。否则不改变CPL。<br>其次，DPL（Descriptor Privilege Level）。DPL表示段或者门的特权级。它被存储在段描述符或者门描述符的DPL字段中。根据门或者段的类型不同，DPL将会被区别对待。在数据段中，DPL规定了可以访问此段的最低特级权；在非一致代码段，DPL规定访问此段的特权级；在调用门，DPL规定了当前执行的程序或任务可以访问此调用门的最低特权级，和数据段一样。<br>最后，RPL（Requested Privilege Level）。RPL是通过段选择子的第0位和第1位表现出来的。CPU通过检测RPL和CPl来确认一个访问请求是否合法。也就是说，如果RPL的数字比CPL大，呢么RPL将会起决定性作用。<br>操作系统往往用RPL来避免低特权应用访问高特权段内的数据。</li>
<li>一个特权级检验实验<br>由上面我们很容易知道，对于数据的访问，特权级检验还是比较简单的，只要CPL和RPL都小于被访问的数据段的DPL就可以了。<br>我们现在就开始实验：<br>首先，将先前例子中的数据段描述符的DPL修改一下，将LABEL_DESC_DATA对应的段描述符的DPL修改为1：<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LABEL_DESC_DATA:</span>   Descriptor       <span class="number">0</span>,       DataLen - <span class="number">1</span>, D<span class="built_in">A_DRW</span>+D<span class="built_in">A_DPL1</span>	<span class="comment">; Data</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行后结果不变。<br>接着，继续将刚修改过的数据段的选择子RPL改为3<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectorData	</span>	<span class="meta">equ</span>	LABEL_DESC_DATA		- LABEL_GDT+SA_RPL3</span><br></pre></td></tr></table></figure></p>
<p>这时，出现错误了<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180121/9iEb64i8id.png?imageslim" alt="mark"><br>这个错误很好理解，我们违反了特权级的规则，用RPL=3的选择子去访问DPL=1的段，浴室引起异常。而我们又没有相应的异常处理模块，于是出错。<br>下面，我们再看看不同特权级之间的转移情况是怎样的。</p>
<ul>
<li>不同特权级代码之间的转移<br>程序从一个代码段到另一个代码段之前，目标代码的选择子会被加载到cs中。作为加载过程的一部分，处理器会坚持描述符的界限、类型、特权级等。<br>程序控制转移的发生，可以是由指令jmp、call、ret、sysenter、sysexit、int或iret引起，也可以由中断和异常机制引起。<h2 id="6-特权级转移"><a href="#6-特权级转移" class="headerlink" title="6.特权级转移"></a>6.特权级转移</h2></li>
<li>首先，同门先来看看通过jmp或者call进行直接转移<br>对通过jmp或call进行直接转移，如果目标是非一致性代码段，要求CPL必须等于目标段的DPL，同时要求RPL小雨等于DPL；如果是一致代码段，则要求CPL大于或者等于目标段的DPL，此时RPL不做检查。<br>所以想要自由的进行不同特权级之间的转移，就需要用门或者TSS.<br>-接着， “门”的初体验<br>门也是一种描述符，它的结构如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180122/EG1Bi2Il21.png?imageslim" alt="mark"><br>门描述符的结构就是这样子，直观可以看出，一个门描述了有一个选择子和一个偏移所指定的线性地址，程序正是同这个地址进行转移的。门描述符分为4种：<br>（1）调用门（Call Gates）<br>（2）中断门（Interrupt Gates）<br>（3）陷阱门（Trap Gates）<br>（4）任务门（Task Gates）<br>我们先看看调用门，值关注它的工作方式，在代码段pmtest3.asm的基础上增加一个代码段作为调用门转移的目标段：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SECTION</span> .sdest]<span class="comment">; 调用门目标段</span></span><br><span class="line">[<span class="meta">BITS</span>	<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">LABEL_SEG_CODE_DEST:</span></span><br><span class="line">	<span class="comment">;jmp	$</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, SelectorVideo</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">gs</span>, <span class="built_in">ax</span>			<span class="comment">; 视频段选择子(目的)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">edi</span>, (<span class="number">80</span> * <span class="number">12</span> + <span class="number">0</span>) * <span class="number">2</span>	<span class="comment">; 屏幕第 12 行, 第 0 列。</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="number">ah</span>, <span class="number">0Ch</span>			<span class="comment">; 0000: 黑底    1100: 红字</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">al</span>, <span class="string">'C'</span></span><br><span class="line">	<span class="keyword">mov</span>	[<span class="built_in">gs</span>:<span class="built_in">edi</span>], <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">retf</span></span><br><span class="line"></span><br><span class="line">SegCodeDestLen	<span class="built_in">equ</span>	$ - LABEL_SEG_CODE_DEST</span><br><span class="line"><span class="comment">; END of [SECTION .sdest]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们带酸用call指令掉哦也难怪将要建立的调用门，所以，在这段代码的结尾调用了一个retf指令。<br>接着，计入这个代码段的描述符，选择子以及初始化这个描述符的代码。<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LABEL_DESC_CODE_DEST:</span> Descriptor <span class="number">0</span>,SegCodeDestLen-<span class="number">1</span>, D<span class="built_in">A_C</span>+D<span class="built_in">A_32</span><span class="comment">; 非一致代码段,32</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectorCodeDest	</span><span class="meta">equ</span>	LABEL_DESC_CODE_DEST	- LABEL_GDT</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 初始化测试调用门的代码段描述符</span></span><br><span class="line">	<span class="keyword">xor</span>	<span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">	<span class="keyword">shl</span>	<span class="built_in">eax</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">add</span>	<span class="built_in">eax</span>, LABEL_SEG_CODE_DEST</span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">word</span> [LABEL_DESC_CODE_DEST + <span class="number">2</span>], <span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">shr</span>	<span class="built_in">eax</span>, <span class="number">16</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">byte</span> [LABEL_DESC_CODE_DEST + <span class="number">4</span>], <span class="built_in">al</span></span><br><span class="line">	<span class="keyword">mov</span>	<span class="built_in">byte</span> [LABEL_DESC_CODE_DEST + <span class="number">7</span>], <span class="number">ah</span></span><br></pre></td></tr></table></figure>
<p>初始化描述符已经能够很熟悉了，以后就不再赘述了。<br>下面添加调用门：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">; 门                               目标选择子,偏移,DCount, 属性</span></span><br><span class="line"><span class="symbol">LABEL_CALL_GATE_TEST:</span> Gate SelectorCodeDest,   <span class="number">0</span>,     <span class="number">0</span>, D<span class="built_in">A_386CGate</span>+D<span class="built_in">A_DPL0</span></span><br></pre></td></tr></table></figure></p>
<p>这个，我们用了一个宏Gate来初始化，这个宏可以在pm.inc中找到。他和Descriptor宏有点类似，也是将描述符的构成要素分别安置在相应的位置，是代码看起来非常清晰。<br>我们的门描述符的属性是DA_386CGate，表示它是一个调研那个门。里面指定的选择子是SelectorCodeDest，表明代码段是刚刚新调价的代码段。偏移地址是0，表示将跳转到目标代码段的开头出。另外，我们把其DPL指定为0.<br>好了，现在调用门准备就绪了，它指向的位置是SelectorCodeDest：0，即标号LABEL_SEG_CODE_DEST处的代码。<br>到这里，我们就可以用call指令来使用这个调用门了，这个call指令被放进局部任务之前，由于我们新加的代码以指令retf结尾，所以代码最终将会跳回call指令的下面继续执行，所以，我们最终会看到在pmtest3执行结果的基础上，多出一个红色的字母C。如图所示：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180124/bmK3AeF8ga.png?imageslim" alt="mark"><br>总结起来，调用门听起来很可怕，本质上只不过是个入口地址，只是增加了若干的属性而已。<br>我们接下来，激昂要用它来实现不同特权级的代码之间的转移，下图是特权检测的规则：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180124/A0eeC4Lh3F.png?imageslim" alt="mark"><br>从上可知，通过调用门和call指令，可以实现从低特权级到高特权级的转移。</p>
<p>下面，我们看一下整个转移过程是怎样的。</p>
<ul>
<li>根据目标代码段的DPL从TSS中选择应该切换至哪个ss和esp</li>
<li>从TSS中读取新的ss和esp。在这个过程中如果发现ss、esp或者TSS界限错误都会导致无效TSS异常</li>
<li>对ss描述符进行检验，若异常，同样产生异常</li>
<li>暂时性地保存当前ss和esp的值</li>
<li>加载新的ss和esp</li>
<li>将刚刚保存起来的ss和esp的值压入新栈</li>
<li>从调用者堆栈中将参数复制到被调用者堆栈中，复制参数的数目由调用门中Param Count一项来决定。</li>
<li>将当前的cs和eip压栈。</li>
<li>加载调用门中指定的心得cs和eip，开始执行被调用者过程。<br>综上，使用调用门的过程实际上分为两个部分，一部分是从低特权级到高特权级，通过调用门和call指令来实现；另一部分是从高特权级到di低特权级，通过ret指令来实现。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> Bochs </tag>
            
            <tag> NASM </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo+Github+Coding+万网域名建站教学--如何被百度谷歌收录]]></title>
      <url>/2018/01/18/Hexo-Github-Coding-%E4%B8%87%E7%BD%91%E5%9F%9F%E5%90%8D%E5%BB%BA%E7%AB%99%E6%95%99%E5%AD%A6-%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>这篇博文主要是写搭建好博客以后，想要自己的网站能被其他人看到，那么最起码能在百度或者谷歌中搜索出来。<br><a id="more"></a></p>
<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><p>首先必须得满足以下条件才能用我的方法：</p>
<ul>
<li>一个备案过了的域名比如wcqwolflow.com,域名可以在<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>上买</li>
<li>在Github上部署好的博客</li>
<li>在Coding部署好的博客<br>被谷歌收录特别简单，但是被百度收录巨麻烦，Coding可以看成是国内的Github，因为Github嫌弃百度蜘蛛爬取的太频繁，所以屏蔽的百度。<br>所以我的思路就是，通过对我的域名的解析操作，<br>让国内的域名解析到Yourname.Coding.me<br>让国外的域名解析到Yourname.github.io<br>最后的成果就是可以通过<a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">China.com</a>解析到如下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/dl6F3fBJf5.png?imageslim" alt="mark"><h1 id="2-具体步骤"><a href="#2-具体步骤" class="headerlink" title="2.具体步骤"></a>2.具体步骤</h1><h3 id="第一步：在Github和Coding上同时部署和发布你的小站"><a href="#第一步：在Github和Coding上同时部署和发布你的小站" class="headerlink" title="第一步：在Github和Coding上同时部署和发布你的小站"></a>第一步：在Github和Coding上同时部署和发布你的小站</h3>这个网上教程一大堆，最后的结果就是执行命令<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>后，在Coding和Github上都可以看到自己的博客文件<br>如下：<br>Coding：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/m7iG2bFADl.png?imageslim" alt="mark"><br>Github：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/egLBga0aFh.png?imageslim" alt="mark"></p>
<h3 id="第二步：在Github和Coding上都绑定自己的域名"><a href="#第二步：在Github和Coding上都绑定自己的域名" class="headerlink" title="第二步：在Github和Coding上都绑定自己的域名"></a>第二步：在Github和Coding上都绑定自己的域名</h3><p>其中要在Coding的Page服务里修改成如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/4d26KE7J1j.png?imageslim" alt="mark"><br>在Github的Setting里修改成如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/4FgIcf5275.png?imageslim" alt="mark"><br>第三步：注册DNSPOD，并在购买域名的商家处修改DNS服务器为图中记录类型为NS的地方：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/Iih6cCkfBE.png?imageslim" alt="mark"><br>在这里解释下为什么选择DNSPOD，我在万网买的一年的域名，但是万网的线路类型选择了世界以后，在DNS解析时，还是没法将海外的解析成wcq19941215.github.io，所以换成了DNSPOD图中的参数设置：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/eaJGmd6Bm9.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/LGkcDbmb97.png?imageslim" alt="mark"></p>
<p>到此，域名设置都完成了，我们可以在百度和谷歌里输入site:你的域名。<br>会显示类似下图的样子：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/L5E69k1cFf.png?imageslim" alt="mark"><br>我们点击<strong>提交网址</strong><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/D0laH6FbBe.png?imageslim" alt="mark"><br>可以看到上面的图片，具体怎么提交给百度和谷歌的方式有一大堆，可以自己去看看。</p>
<h1 id="3-最关键的地方"><a href="#3-最关键的地方" class="headerlink" title="3.最关键的地方"></a>3.最关键的地方</h1><p>你如果按照我的做了，你在如图画圈的地方应该看到的是<strong>抓取成功 (有跳转)</strong>，那么意味着，百度蜘蛛永远无法爬取到你的网站：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/DJhL2c1j03.png?imageslim" alt="mark"><br>这是因为Coding的银牌会员默认是跳转首页，然后再跳转到你的仓库的，解决办法如下：<br>首先在Coding的Page服务页面找到这个<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/BbA6a5Ii9i.png?imageslim" alt="mark"><br>然后在你网站首页加上这个：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/iF1G54Aecb.png?imageslim" alt="mark"><br>加这个的方法是，在你本地找到hexo放置的地方themes\next\layout_partials\footer.swig 加上下面代码如图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/bBiHb8Lf43.png?imageslim" alt="mark"><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  Hosted by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://pages.coding.me"</span> <span class="attr">style</span>=<span class="string">"font-weight: bold"</span>&gt;</span>Coding Pages<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>两天左右，等DNS迭代递归全球服务器解析完成和Coding首页审核完成，你就会在百度中看到这个：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/j2J4gaKa2d.png?imageslim" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建遇到的坑 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 域名 </tag>
            
            <tag> Hexo </tag>
            
            <tag> DNS解析 </tag>
            
            <tag> 百度抓取成功 (有跳转) </tag>
            
            <tag> 谷歌收录 </tag>
            
            <tag> Coding </tag>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2.1）]]></title>
      <url>/2018/01/16/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-1%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><p>和开始理解操作系统一样，我们可能对什么是保护模式完全不了解，没关系，我们先从下面代码开始。</p>
<h2 id="1-认识保护模式"><a href="#1-认识保护模式" class="headerlink" title="1. 认识保护模式"></a>1. 认识保护模式</h2><a id="more"></a>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%include</span>	<span class="string">"pm.inc"</span>	<span class="comment">;常量 ，宏 ，以及一些说明</span></span><br><span class="line">org <span class="number">07c00h</span> </span><br><span class="line"><span class="symbol">	jmp LABEL</span>_BEGIN</span><br><span class="line">[<span class="meta">SECTION</span> .gdt]</span><br><span class="line"><span class="comment">; GDT</span></span><br><span class="line"><span class="comment">;								段基址，		   段界限，		         属性</span></span><br><span class="line"><span class="symbol">LABEL_GDT:</span>			Descriptor		 <span class="number">0</span>,		 		    <span class="number">0</span>,			      <span class="number">0</span><span class="comment">;空描述符</span></span><br><span class="line"><span class="symbol">LABEL_DESC_CODE32:</span>	Descriptor	     <span class="number">0</span>,  SegCode32Len - <span class="number">1</span>,		DA_C+DA_32<span class="comment">;非一致代码段</span></span><br><span class="line"><span class="symbol">LABEL_DESC_VIDEO:</span>	Descriptor <span class="number">0B8000h</span>,            <span class="number">0ffffh</span>,			 DA_DRW<span class="comment">;显存首地址</span></span><br><span class="line"><span class="comment">; GDT结束</span></span><br><span class="line"></span><br><span class="line">GdtLen  <span class="built_in">equ</span>  $-LABEL_GDT 	<span class="comment">;GDT长度</span></span><br><span class="line">GdtPtr  <span class="built_in">dw</span>	 GdtLen-<span class="number">1</span>		<span class="comment">;GDT界限</span></span><br><span class="line">		<span class="built_in">dd</span>   <span class="number">0</span>				<span class="comment">;GDT基地址</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">;GDT选择子</span></span><br><span class="line">SelectorCode32		<span class="built_in">equ</span>		LABEL_DESC_CODE32	-LABEL_GDT</span><br><span class="line">SelectorVideo		<span class="built_in">equ</span>		LABEL_DESC_VIDEO	-LABEL_GDT</span><br><span class="line"><span class="comment">; END of [SECTION .gdt]</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">SECTION</span> .s16]</span><br><span class="line">[<span class="meta">BITS</span> <span class="number">16</span>]</span><br><span class="line"><span class="symbol">LABEL_BEGIN:</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">sp</span>, <span class="number">0100h</span></span><br><span class="line">		<span class="comment">;初始化32位代码段描述符</span></span><br><span class="line">		<span class="keyword">xor</span>		<span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">shl</span> 	<span class="built_in">eax</span>,<span class="number">4</span></span><br><span class="line">		<span class="keyword">add</span>		<span class="built_in">eax</span>,LABEL_SEG_CODE32</span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">word</span> [LABEL_DESC_CODE32+<span class="number">2</span>],<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">shr</span>		<span class="built_in">eax</span>,<span class="number">16</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">byte</span> [LABEL_DESC_CODE32+<span class="number">4</span>],<span class="built_in">al</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">byte</span> [LABEL_DESC_CODE32+<span class="number">7</span>],<span class="number">ah</span></span><br><span class="line">		<span class="comment">;为加载GDTR做准备</span></span><br><span class="line">		<span class="keyword">xor</span>		<span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">		<span class="keyword">mov</span> 	<span class="built_in">ax</span>,<span class="built_in">ds</span></span><br><span class="line">		<span class="keyword">shl</span>		<span class="built_in">eax</span>,<span class="number">4</span></span><br><span class="line">		<span class="keyword">add</span>		<span class="built_in">eax</span>,LABEL_GDT<span class="comment">;eax&lt;-gdt基地址</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">dword</span> [GdtPtr+<span class="number">2</span>],<span class="built_in">eax</span><span class="comment">;[GdtPtr+2]&lt;-gdt基地址</span></span><br><span class="line">		<span class="comment">;加载GDTR</span></span><br><span class="line">		<span class="keyword">lgdt</span>	[GdtPtr]</span><br><span class="line">		</span><br><span class="line">		<span class="comment">;关中断</span></span><br><span class="line">		<span class="keyword">cli</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">;打开地址线A20</span></span><br><span class="line">		<span class="keyword">in</span>		<span class="built_in">al</span>,<span class="number">92h</span></span><br><span class="line">		<span class="keyword">or</span>		<span class="built_in">al</span>,<span class="number">00000010b</span></span><br><span class="line">		<span class="keyword">out</span>		<span class="number">92h</span>,<span class="built_in">al</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">;准备切换到保护模式</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">eax</span>,<span class="built_in">cr0</span></span><br><span class="line">		<span class="keyword">or</span>		<span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">cr0</span>,<span class="built_in">eax</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">;真正进入保护模式</span></span><br><span class="line">		<span class="keyword">jmp</span>		<span class="built_in">dword</span> SelectorCode32:<span class="number">0</span><span class="comment">;执行这一句会吧SelectorCODE32装入cs,</span></span><br><span class="line">			<span class="comment">;并且跳转到Code32Selector:0;</span></span><br><span class="line">			<span class="comment">;END of [SECTION .s16]</span></span><br><span class="line">[<span class="meta">SECTION</span> .s32]<span class="comment">;32位代码段，由实模式跳入</span></span><br><span class="line">[<span class="meta">BITS</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">LABEL_SEG_CODE32:</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,SelectorVideo</span><br><span class="line">		<span class="keyword">mov</span>	<span class="built_in">gs</span>,<span class="built_in">ax</span><span class="comment">;视频段选择子（目的）</span></span><br><span class="line">		<span class="keyword">mov</span>	<span class="built_in">edi</span>,(<span class="number">80</span>*<span class="number">11</span>+<span class="number">79</span>)*<span class="number">2</span><span class="comment">;屏幕第11行，第79列。</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0Ch</span>	<span class="comment">;0000:黑底 1100：红字</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'P'</span></span><br><span class="line">		<span class="keyword">mov</span>	[<span class="built_in">gs</span>:<span class="built_in">edi</span>],<span class="built_in">ax</span></span><br><span class="line">		<span class="comment">;到此停止</span></span><br><span class="line">		<span class="keyword">jmp</span> $</span><br><span class="line">SegCode32Len	<span class="built_in">equ</span> $-LABEL_SEG_CODE32</span><br><span class="line"><span class="comment">;END of [SECTION .32]</span></span><br></pre></td></tr></table></figure>
<p>可能上述代码，你看到一半就不耐烦了，没关系，先执行一下它，和前面一个章节一样，先生成pmtest.bin文件，看看效果再说，执行如图所示命令：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180116/BKIk16f1IH.png?imageslim" alt="mark"><br>得到的结果如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180116/F80d0J5i7L.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180116/i40dAHgdb1.png?imageslim" alt="mark"><br>可以看到，在屏幕的右边有个红色的“P”,显然程序的最后一部分将其写入了显存中<br>（PS:该项目的地址都在第二篇博文里）</p>
<h2 id="2-代码解释"><a href="#2-代码解释" class="headerlink" title="2. 代码解释"></a>2. 代码解释</h2><p>首先，看[SECTION .gdt]段，其中的Descriptor是在pm.inc中的宏。具体意义先不用管，只用了解这是一个数据结构，8字节大小。<br>如下:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 节选自pm.inc</span></span><br><span class="line"><span class="comment">;描述符</span></span><br><span class="line"><span class="comment">; usage: Descriptor Base, Limit, Attr</span></span><br><span class="line"><span class="comment">;        Base:  dd</span></span><br><span class="line"><span class="comment">;        Limit: dd (low 20 bits available)</span></span><br><span class="line"><span class="comment">;        Attr:  dw (lower 4 bits of higher byte are always 0)</span></span><br><span class="line">%macro Descriptor <span class="number">3</span></span><br><span class="line">	<span class="built_in">dw</span>	<span class="subst">%2</span> &amp; <span class="number">0FFFFh</span>				<span class="comment">; 段界限1</span></span><br><span class="line">	<span class="built_in">dw</span>	<span class="subst">%1</span> &amp; <span class="number">0FFFFh</span>				<span class="comment">; 段基址1</span></span><br><span class="line">	<span class="built_in">db</span>	(<span class="subst">%1</span> &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0FFh</span>			<span class="comment">; 段基址2</span></span><br><span class="line">	<span class="built_in">dw</span>	((<span class="subst">%2</span> &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0F00h</span>) | (<span class="subst">%3</span> &amp; <span class="number">0F0FFh</span>)	<span class="comment">; 属性1 + 段界限2 + 属性2</span></span><br><span class="line">	<span class="built_in">db</span>	(<span class="subst">%1</span> &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0FFh</span>			<span class="comment">; 段基址3</span></span><br><span class="line">%endmacro <span class="comment">; 共 8 字节</span></span><br></pre></td></tr></table></figure></p>
<p>在这个段中，并列的三个Decriptor，所构成的数据就是GDT()<br>GdtLen是它的长度，GdtPtr包含6字节，前2字节是GDT的界限，后4字节是GDT的基地址.<br>后面两个段[SECTION .16]和[SECTION .32]很容易理解是16位和32位代码段，意思就是在16位中修改了GDT中的值，然后跳转到32位，执行最后一小段显示红色P的代码，然后进入无线循环。也就是真正进入保护模式。<br>从这个我们可以了解如下内容：</p>
<ul>
<li>我们定义了一个叫做GDT的数据结构（可能现在有人会想，为啥到现在都不讲什么是保护模式，它有什么用？不急慢慢往后看这部分的内容很多的）</li>
<li>后面的16位的段，进行了一些对GDT的操作</li>
<li>最后jmp到了32位，执行写入显存显示红字，然后结束了</li>
</ul>
<p>我们不明白的有：</p>
<ul>
<li>GDT是什么？有什么用？</li>
<li>程序对它进行了什么操作</li>
<li>jmp SelectorCode32：0 和以前的jmp有什么不同</li>
</ul>
<h2 id="3-GDT（Global-Descriptor-Table）"><a href="#3-GDT（Global-Descriptor-Table）" class="headerlink" title="3.GDT（Global Descriptor Table）"></a>3.GDT（Global Descriptor Table）</h2><p>首先解释保护模式和实模式。<br>在IA32下，cpu有保护模式和实模式两种工作模式。当我们打开PC时，cpu工作在实模式下，经过莫衷机制后，才进入保护模式。在保护模式下CPU有巨大的寻址能力，并且为32位操作系统提供了更好的硬件保障。<br>在Intel8086时，CPU有16位的寄存器、16位的数据总线以及20位的地址总线和1MB的寻址能力。一个地址由段和偏移两部分组成，物理地址的计算公式如下：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">物理地址 </span>=<span class="string"> 段值 * 16 + 偏移</span></span><br></pre></td></tr></table></figure></p>
<p>从80386开始，CPU进入32位，有32位地址线，所以寻址空间达到4GB。所以但从寻址看，16位已经不满足了。所以需要新方法来提供更强大的寻址能力。<br>在实模式下，16位寄存器通过段+偏移来达到1MB的寻址能力，而32为寄存器一个就可以寻址4GB的空间了，但在保护模式下，任然可用过段+偏移的方式，但是，这时的段的概念已经发生根本性的变化了。这时的段只是索引，指向了一个数据结构—GDT（也可以是LDT以后会讲）。其中的表项有个专门的明治，叫做描述符。<br>总的来说，GDT的作用是用来提供<strong>段式存储机制</strong>。这种机制是通过寄存器和GDT中的描述符共同提供的，下面我们看看代码段和数据段描述符的结构：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/743jAb4dBf.png?imageslim" alt="mark"></p>
<p>在本例中的描述符有三个节选上面的 代码如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .gdt]</span><br><span class="line"><span class="comment">; GDT</span></span><br><span class="line"><span class="comment">;								段基址，		   段界限，		  属性</span></span><br><span class="line"><span class="symbol">LABEL_GDT:</span>			Descriptor		 <span class="number">0</span>,		 		    <span class="number">0</span>,			      <span class="number">0</span><span class="comment">;空描述符</span></span><br><span class="line"><span class="symbol">LABEL_DESC_CODE32:</span>	Descriptor	     <span class="number">0</span>,  SegCode32Len - <span class="number">1</span>,		DA_C +DA_32<span class="comment">;非一致代码段</span></span><br><span class="line"><span class="symbol">LABEL_DESC_VIDEO:</span>	Descriptor <span class="number">0</span>B8000h,            <span class="number">0</span>ffffh,			 DA_DRW<span class="comment">;显存首地址</span></span><br><span class="line"><span class="comment">; GDT结束</span></span><br></pre></td></tr></table></figure></p>
<p>其中DESC_VIDEO的基地址为0B000h，是显存处。<br>现在我们知道了GDT中的每一个描述符定义一个段，那么cs、ds等段寄存器是这样和这些段对应的：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,SelectorVideo</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">gs</span>,<span class="built_in">ax</span></span><br></pre></td></tr></table></figure></p>
<p>其中SelectorVideo为：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SelectorVideo </span><span class="meta">equ</span> LABEL_DESC_VIDEO - LABEL_GDT</span><br></pre></td></tr></table></figure></p>
<p>其中SelectorVideo直观可以看出是DESC_VIDEO这个描述符相对于GDT基址的偏移。实际上它有专门的名称，叫做选择子，它也不是一个偏移。<br>总之，整个段式寻址示意图如下：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/I4kd01GbED.png?imageslim" alt="mark"></p>
<p>到此，我们对这段代码理解的差不多了，仅剩下[SECTION .16]段了，其实也很容易了，既然下[SECTION .32]是32位程序，那么下[SECTION .16]的任务就是从实模式向保护模式跳转了。</p>
<h2 id="4-实模式向保护模式的跳转"><a href="#4-实模式向保护模式的跳转" class="headerlink" title="4.实模式向保护模式的跳转"></a>4.实模式向保护模式的跳转</h2><p>首先，我们把[SECTION .16]段，拿出来仔细看看<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SECTION</span> .s16]</span><br><span class="line">[<span class="meta">BITS</span> <span class="number">16</span>]</span><br><span class="line"><span class="symbol">LABEL_BEGIN:</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">sp</span>, <span class="number">0100h</span></span><br><span class="line">		<span class="comment">;初始化32位代码段描述符</span></span><br><span class="line">		<span class="keyword">xor</span>		<span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">		<span class="keyword">shl</span> 	<span class="built_in">eax</span>,<span class="number">4</span></span><br><span class="line">		<span class="keyword">add</span>		<span class="built_in">eax</span>,LABEL_SEG_CODE32</span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">word</span> [LABEL_DESC_CODE32+<span class="number">2</span>],<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">shr</span>		<span class="built_in">eax</span>,<span class="number">16</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">byte</span> [LABEL_DESC_CODE32+<span class="number">4</span>],<span class="built_in">al</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">byte</span> [LABEL_DESC_CODE32+<span class="number">7</span>],<span class="number">ah</span></span><br><span class="line">		<span class="comment">;为加载GDTR做准备</span></span><br><span class="line">		<span class="keyword">xor</span>		<span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">		<span class="keyword">mov</span> 	<span class="built_in">ax</span>,<span class="built_in">ds</span></span><br><span class="line">		<span class="keyword">shl</span>		<span class="built_in">eax</span>,<span class="number">4</span></span><br><span class="line">		<span class="keyword">add</span>		<span class="built_in">eax</span>,LABEL_GDT<span class="comment">;eax&lt;-gdt基地址</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">dword</span> [GdtPtr+<span class="number">2</span>],<span class="built_in">eax</span><span class="comment">;[GdtPtr+2]&lt;-gdt基地址</span></span><br><span class="line">		<span class="comment">;加载GDTR</span></span><br><span class="line">		<span class="keyword">lgdt</span>	[GdtPtr]</span><br><span class="line">		</span><br><span class="line">		<span class="comment">;关中断</span></span><br><span class="line">		<span class="keyword">cli</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">;打开地址线A20</span></span><br><span class="line">		<span class="keyword">in</span>		<span class="built_in">al</span>,<span class="number">92h</span></span><br><span class="line">		<span class="keyword">or</span>		<span class="built_in">al</span>,<span class="number">00000010b</span></span><br><span class="line">		<span class="keyword">out</span>		<span class="number">92h</span>,<span class="built_in">al</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">;准备切换到保护模式</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">eax</span>,<span class="built_in">cr0</span></span><br><span class="line">		<span class="keyword">or</span>		<span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line">		<span class="keyword">mov</span>		<span class="built_in">cr0</span>,<span class="built_in">eax</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">;真正进入保护模式</span></span><br><span class="line">		<span class="keyword">jmp</span>		<span class="built_in">dword</span> SelectorCode32:<span class="number">0</span><span class="comment">;执行这一句会吧SelectorCODE32装入cs,</span></span><br><span class="line">	<span class="comment">;并且跳转到Code32Selector:0;</span></span><br><span class="line"><span class="comment">;END of [SECTION .s16]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>初始化32位代码段描述符<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">add</span>		<span class="built_in">eax</span>,LABEL_SEG_CODE32</span><br><span class="line">  	<span class="keyword">mov</span>		<span class="built_in">word</span> [LABEL_DESC_CODE32+<span class="number">2</span>],<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">shr</span>		<span class="built_in">eax</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">mov</span>		<span class="built_in">byte</span> [LABEL_DESC_CODE32+<span class="number">4</span>],<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span>		<span class="built_in">byte</span> [LABEL_DESC_CODE32+<span class="number">7</span>],<span class="number">ah</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先把[SECTION .s32]赋值给eax,然后把他分为3个部分，分别给[LABEL_DESC_CODE32的相应位置，至此初始化完成。<br>然后，因为保护模式下的中方段处理机制是不一样的的，不关掉中断会出现错误。<br>接着打开A20,因为它默认是关闭的。（具体这块的解释因为涉及到8086的历史问题，就不再赘述了）<br>最后的一部分代码中的寄存器cr0如图所示<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180118/jjfaHij78b.png?imageslim" alt="mark"><br>所以代码中的0到1，是决定性的，因为cr0的0号位置是PE,此位是0时为实模式，为1时是保护模式！</p>
<p>执行完<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span> , <span class="built_in">eax</span></span><br></pre></td></tr></table></figure></p>
<p>系统就运行在保护模式下了。但是此时cs的值任然是实模式下的值，我们需要把代码段的选择子装入cs。所以才有了：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> SelectorCOde32:<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>这个jmp看起来稍微复杂了点，因为它不得不放在16位的段中，目标却是32位的。至此，我们成功进入保护模式。<br>下面我们总结进入保护模式的主要步骤：</p>
<ol>
<li>准备GDT.</li>
<li>用lgdt加载gdte.</li>
<li>关中断。</li>
<li>打开A20。</li>
<li>置cr0的PE位为1.</li>
<li>跳转，进入保护模式。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 保护模式 </tag>
            
            <tag> Bochs </tag>
            
            <tag> NASM </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE's:一个操作系统实现》搭建工作环境（1）]]></title>
      <url>/2018/01/08/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%90%AD%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>BOchs虚拟机可以让我们像上帝一样，随时让时间“停住”钻进计算机里的小计算机里，CPU、内存、硬盘等尽收眼底</p>
<h1 id="Bochs虚拟机的安装"><a href="#Bochs虚拟机的安装" class="headerlink" title="Bochs虚拟机的安装"></a>Bochs虚拟机的安装</h1><p>安装环境：Window7 64位下的Vm虚拟机（11.0.4）下的Ubuntu16.0.4 Bochs2.6.9<br><a id="more"></a><br>安装过程：</p>
<h3 id="1我在官网下载好bochs-2-6-9-tar-gz后，放在MyOS目录下，第一步解压"><a href="#1我在官网下载好bochs-2-6-9-tar-gz后，放在MyOS目录下，第一步解压" class="headerlink" title="1我在官网下载好bochs-2.6.9.tar.gz后，放在MyOS目录下，第一步解压"></a>1我在官网下载好bochs-2.6.9.tar.gz后，放在MyOS目录下，第一步解压</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">tar</span> <span class="selector-tag">zxvf</span> <span class="selector-tag">bochs-2</span><span class="selector-class">.6</span><span class="selector-class">.9</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/cDlga9kdgG.png?imageslim" alt="mark"><br><a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">Bochs下载链接</a></p>
<h3 id="2进入bochs-2-6-9目录下开始编译安装："><a href="#2进入bochs-2-6-9目录下开始编译安装：" class="headerlink" title="2进入bochs-2.6.9目录下开始编译安装："></a>2进入bochs-2.6.9目录下开始编译安装：</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo make</span></span><br></pre></td></tr></table></figure>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/6DHfcmKmkK.png?imageslim" alt="mark"><br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make <span class="keyword">install</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/mjgJdjIHA5.png?imageslim" alt="mark"></p>
<h3 id="3安装完成后如图"><a href="#3安装完成后如图" class="headerlink" title="3安装完成后如图"></a>3安装完成后如图</h3><p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/Am3iebGHJ5.png?imageslim" alt="mark"></p>
<h1 id="Bochs的使用"><a href="#Bochs的使用" class="headerlink" title="Bochs的使用"></a>Bochs的使用</h1><h3 id="1创建一个软盘映像代码如图所示："><a href="#1创建一个软盘映像代码如图所示：" class="headerlink" title="1创建一个软盘映像代码如图所示："></a>1创建一个软盘映像代码如图所示：</h3><p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/EeIc4d74Ig.png?imageslim" alt="mark"><br>完成以后，在当前目录下就多出了一个a.img<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/5h3KKIg1kF.png?imageslim" alt="mark"></p>
<p>现在我们有了“计算机”和“软盘”，是时候将引导扇区写进软盘了。我们使用dd命令：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=boot.bin <span class="attribute">of</span>=a.img <span class="attribute">bs</span>=512 <span class="attribute">count</span>=1 <span class="attribute">conv</span>=notrunc</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/8cIc1k6E7l.png?imageslim" alt="mark"><br>其中 boot.bin 文件需要复制到和a.img同一目录下。这行代码中“conv=notrunc”若不用，a.img会被截断，因为boot.bin比a.img小。</p>
<h3 id="2配置Bochs"><a href="#2配置Bochs" class="headerlink" title="2配置Bochs"></a>2配置Bochs</h3><p>这一步是为了说明虚拟级的内存大小、硬盘映射和软盘映射都是哪些文件。配置文件bochsrc内容如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">###############################################################</span><br><span class="line"># Configuration file for Bochs</span><br><span class="line">###############################################################</span><br><span class="line"></span><br><span class="line"># how much memory the emulated machine will have</span><br><span class="line">megs: <span class="number">32</span></span><br><span class="line"></span><br><span class="line"># filename <span class="keyword">of</span> ROM images</span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-latest  </span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest  </span><br><span class="line"></span><br><span class="line"># what disk images will be used</span><br><span class="line">floppya: <span class="number">1</span>_44=a.img, status=inserted</span><br><span class="line"></span><br><span class="line"># choose the boot disk.</span><br><span class="line">boot: floppy</span><br><span class="line"></span><br><span class="line"># <span class="keyword">where</span> do we send log messages?</span><br><span class="line"># log: bochsout.txt</span><br><span class="line"></span><br><span class="line"># disable the mouse</span><br><span class="line">mouse: enabled=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"># enable key mapping, using US layout <span class="keyword">as</span> default.</span><br><span class="line">keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map</span><br></pre></td></tr></table></figure></p>
<p>然后再输入命令：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bochs </span>-f <span class="keyword">bochsrc</span></span><br></pre></td></tr></table></figure></p>
<p>会出现下面内容，然后选择6，若出现黑色的框也就是Bochs那就是成功啦，然后再终端输入c,大功告成！！</p>
<p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/gCgECHfE4k.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/HelLGFAadh.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/36jHJ3j25d.png?imageslim" alt="mark"></p>
<h1 id="用Bochs调试操作系统"><a href="#用Bochs调试操作系统" class="headerlink" title="用Bochs调试操作系统"></a>用Bochs调试操作系统</h1><p>我们以开始的引导扇区为例，在07c00h处设置断点，从这里开始执行，然后单步执行，和其他调试工具一样。同时在任何时刻你都可以查看CPU寄存器，或者查看某个内存地址处的内容。下面我们具体操作一下：<br>注意！！！： bochs 2.3.5 以上的版本没有dump_cpu了,可以用r，fp，mmx，sse，dreg，sreg，creg命令代替。<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/L6H379dBAL.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/h0JJHfaeAJ.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/fA4DIDi1L2.png?imageslim" alt="mark"></p>
<p>附录调试命令：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180110/g44l6hbDlC.png?imageslim" alt="mark"></p>
<h1 id="接着安装GCC和NASM"><a href="#接着安装GCC和NASM" class="headerlink" title="接着安装GCC和NASM"></a>接着安装GCC和NASM</h1><p>查看某软件是否安装的命令 <em>*</em> -v<br>下载安装某软件的命令，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get  <span class="keyword">install</span>  <span class="keyword">build</span>-essential ***</span><br><span class="line">例子：安装nasm</span><br><span class="line">sudo apt-<span class="keyword">get</span>  <span class="keyword">install</span>  <span class="keyword">build</span>-essential nasm</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NASM </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> Bochs2.6.9虚拟机 </tag>
            
            <tag> Bochs配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《ORANGE's:一个操作系统实现》准备工作（0）]]></title>
      <url>/2018/01/08/%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%880%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>马上开始动手写最小的一个“操作系统”</p>
<h1 id="1-准备的工具"><a href="#1-准备的工具" class="headerlink" title="1.准备的工具"></a>1.准备的工具</h1><a id="more"></a>
<ul>
<li>具有Window或者Linux的计算机</li>
<li>汇编编译器NASM下载地址：<a href="http://www.nasm.us/" target="_blank" rel="noopener">http://www.nasm.us/</a></li>
<li>VM虚拟机（11.1.3）</li>
<li>MASM2015当作汇编的编辑器<!-- more -->
<h1 id="2-操作系统源码"><a href="#2-操作系统源码" class="headerlink" title="2.操作系统源码"></a>2.操作系统源码</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	org   <span class="number">07c00h</span> <span class="comment">;告诉编译器程序加载到7c00处</span></span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">ax</span>,<span class="built_in">cs</span>  </span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">call</span>  DispStr <span class="comment">;调用显示字符串例程</span></span><br><span class="line">	<span class="keyword">jmp</span>   $        <span class="comment">;无限循环</span></span><br><span class="line"><span class="symbol">DispStr:</span></span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">ax</span>,  BootMessage</span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">bp</span>, <span class="built_in">ax</span>    <span class="comment">;ES:BP=串地址</span></span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">cx</span>, <span class="number">16</span>    <span class="comment">;CX=串长度</span></span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">ax</span>, <span class="number">01301h</span> <span class="comment">;AH=13,AL=01h</span></span><br><span class="line">	<span class="keyword">mov</span>   <span class="built_in">bx</span>, <span class="number">000ch</span>  <span class="comment">;页号为0（BH=0）黑底红字（Bl=OCh，高亮）</span></span><br><span class="line">	<span class="keyword">mov</span>	  <span class="built_in">dl</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">int</span>	  <span class="number">10h</span>          <span class="comment">;10h号中断</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="symbol">BootMessage:</span>		<span class="built_in">db</span>	<span class="string">"His World dwj!"</span> </span><br><span class="line"><span class="built_in">times</span> 	<span class="number">510</span>-($-$$)	<span class="built_in">db</span>	<span class="number">0</span>	<span class="comment">; 填充剩下的空间，使生成的二进制代码恰好为512字节</span></span><br><span class="line"><span class="built_in">dw</span> 	<span class="number">0xaa55</span>				<span class="comment">; 结束标志</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3编译源码制作img文件（软盘镜像文件）"><a href="#3编译源码制作img文件（软盘镜像文件）" class="headerlink" title="3编译源码制作img文件（软盘镜像文件）"></a>3编译源码制作img文件（软盘镜像文件）</h1><p>操作系统要在裸机上跑（没有操作系统的电脑），所以使用VM虚拟机来运行我们写的操作系统，同时又因为现在很多人的电脑都没有光驱了，所以没法制作光盘来做启动盘，这个时候可以用如下命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">boot</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">boot</span><span class="selector-class">.img</span></span><br></pre></td></tr></table></figure></p>
<p>来生成img文件，这个文件就等同于软盘文件，可以放在虚拟机里跑。具体的例子如图：</p>
<h3 id="（1）首先在MASM上编写汇编源码（各行代码含义后面会讲到）："><a href="#（1）首先在MASM上编写汇编源码（各行代码含义后面会讲到）：" class="headerlink" title="（1）首先在MASM上编写汇编源码（各行代码含义后面会讲到）："></a>（1）首先在MASM上编写汇编源码（各行代码含义后面会讲到）：</h3><p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/BCkJ6F151e.png?imageslim" alt="mark"></p>
<h3 id="（2）然后在cmd中，找到boot-asm的位置，如图："><a href="#（2）然后在cmd中，找到boot-asm的位置，如图：" class="headerlink" title="（2）然后在cmd中，找到boot.asm的位置，如图："></a>（2）然后在cmd中，找到boot.asm的位置，如图：</h3><p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/5KG10BH2cK.png?imageslim" alt="mark"></p>
<h3 id="（3）然后输入命令："><a href="#（3）然后输入命令：" class="headerlink" title="（3）然后输入命令："></a>（3）然后输入命令：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nasm</span> <span class="selector-tag">boot</span><span class="selector-class">.asm</span> <span class="selector-tag">-o</span> <span class="selector-tag">boot</span><span class="selector-class">.img</span></span><br></pre></td></tr></table></figure>
<p>就可以看到，新生成了boot.img<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/4ekCGEfjBE.png?imageslim" alt="mark"></p>
<h3 id="（4）打开虚拟机新建，如下列图："><a href="#（4）打开虚拟机新建，如下列图：" class="headerlink" title="（4）打开虚拟机新建，如下列图："></a>（4）打开虚拟机新建，如下列图：</h3><p><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/Fg2dkCba48.png?imageslim" alt="mark"><br>一路NEXT，直到下图：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/C3ICejfIBa.png?imageslim" alt="mark"><br>然后可以得到一个空白的裸机，用来跑自己写的OS用：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/0Ab0DD75m7.png?imageslim" alt="mark"><br>因为我用的.img文件做虚拟软盘，所以需要编辑虚拟机设置：<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/llFa4lkc3B.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/aAbgGgg08h.png?imageslim" alt="mark"><br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/4hDBeIEhl2.png?imageslim" alt="mark"><br>然后选择自己的boot.img文件在那即可<br><img src="http://p29pmm8g4.bkt.clouddn.com/blog/180109/LEB5778Fa8.png?imageslim" alt="mark"></p>
<p>即可显示Hello World!<br>是不是有点小激动呢，哈哈。但是，事实上，这个东西还算不上完整的操作系统，只是最简单的引导扇区，但是它和其他软件不同，它是直接在裸机上跑的，已经具备了操作系统的一个特性。</p>
<h1 id="4代码解释"><a href="#4代码解释" class="headerlink" title="4代码解释"></a>4代码解释</h1><p>org   07c00h：以为计算机电源被打开时，它会先进行加电自检，然后寻找启动盘，这行代码就是告诉BIOS，一旦发现了引导扇区，就将这段512字节的内容装载到0000:7c00处，然后将控制权交给这段引导代码。到此，计算机不再由BIOS中固有的程序控制，而编程由自己的OS的一部分来控制。</p>
<p>mov   ax,cs  mov   ds,ax<br>mov   es,ax：这三个mov指令，是将ds和es两个段寄存器指向与cs相同的段。</p>
<p>mov   ax,  BootMessage：把BootMessage中的值的首地址传给寄存器ax(pS：Nasm中，不加[]的标签或者变量都被认为是地址)。</p>
<p>($-$$)：开始汇编处，距离本行的相对位置。</p>
<p>dw     0xaa55：计算机只有找到0xaa55为结束，才会认为是软盘启动。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> ORANGE&#39;s的学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NASM </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 于渊 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[王超群的博客世界]]></title>
      <url>/2018/01/04/%E7%8E%8B%E8%B6%85%E7%BE%A4%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<h1 id="写在开头的话"><a href="#写在开头的话" class="headerlink" title="写在开头的话"></a>写在开头的话</h1><p>一直都想搞个博客，但是一直都有事情耽搁了，现在在做毕设，刚好可以把以前没做的事都好好的做做。包括操作系统的实现、机器学习、算法与数据结构等等，都系统的学一下，弥补在大学没有深入学习的遗憾。</p>
<h2 id="首先是博客搭建"><a href="#首先是博客搭建" class="headerlink" title="首先是博客搭建"></a>首先是博客搭建</h2><p>以前用过腾讯云+wordpress在Linux下建站，但是没时间管理，所以弃了，现在用的是Github+hexo，感觉很不错，也让人有欲望写学习笔记和写心得，现在把搭建博客的流程详细记录一下，为第一篇博文练手，也可以给其他像我一样想这样建立自己博客的朋友提供一个参考。<br><a id="more"></a><br>具体的搭建流程可以参考<a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">https://www.cnblogs.com/visugar/p/6821777.html</a></p>
<p>下面我只把HEXO使用的相关命令贴出来：</p>
<h2 id="一、将本地与git仓库对应连接起来"><a href="#一、将本地与git仓库对应连接起来" class="headerlink" title="一、将本地与git仓库对应连接起来"></a>一、将本地与git仓库对应连接起来</h2><h3 id="1、绑定用户"><a href="#1、绑定用户" class="headerlink" title="1、绑定用户"></a>1、绑定用户</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>
<h3 id="2、配置ssh"><a href="#2、配置ssh" class="headerlink" title="2、配置ssh"></a>2、配置ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"email@example.com"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3、测试ssh"><a href="#3、测试ssh" class="headerlink" title="3、测试ssh"></a>3、测试ssh</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -T git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure>
<h3 id="4、克隆仓库到本地"><a href="#4、克隆仓库到本地" class="headerlink" title="4、克隆仓库到本地"></a>4、克隆仓库到本地</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:Your Name/*****.github.io.git</span><br></pre></td></tr></table></figure>
<h3 id="5、初始化仓库"><a href="#5、初始化仓库" class="headerlink" title="5、初始化仓库"></a>5、初始化仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure>
<h2 id="二、上传项目、文件、文件夹"><a href="#二、上传项目、文件、文件夹" class="headerlink" title="二、上传项目、文件、文件夹"></a>二、上传项目、文件、文件夹</h2><h3 id="1、上传README文件"><a href="#1、上传README文件" class="headerlink" title="1、上传README文件"></a>1、上传README文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch README.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add README.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'first_commit</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github.com:Your Name/*****.github.io.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>
<h3 id="2、上传项目、文件、文件夹"><a href="#2、上传项目、文件、文件夹" class="headerlink" title="2、上传项目、文件、文件夹"></a>2、上传项目、文件、文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add . </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">'first_commit'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github.com:Your Name/*****.github.io.git</span></span><br><span class="line">（如果错误  git remote rm origin）</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br><span class="line">（如果错误  git pull origin master）</span><br></pre></td></tr></table></figure>
<h2 id="三、下载项目"><a href="#三、下载项目" class="headerlink" title="三、下载项目"></a>三、下载项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull git@github.com:Your Name/*****.github.io.git</span></span><br></pre></td></tr></table></figure>
<h2 id="其次是学习"><a href="#其次是学习" class="headerlink" title="其次是学习"></a>其次是学习</h2><p>主要在完成毕设的同时，学习OS，首先学习下ORANGE’S：一个操作系统的实现这本书，手头有这本书的扫描版和相关光盘附件。</p>
<p>下载地址：<a href="https://pan.baidu.com/s/1o8US7J8" title="下载地址" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8US7J8</a> 密码：byf9</p>
<p>然后再学习MIT6.828课程。<br>预计在2018年2月就学完第一块了。剩下的计划慢慢来吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> 江汉大学 </tag>
            
            <tag> HEXO </tag>
            
            <tag> Orange S：一个操作系统的实现(有光盘) </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
