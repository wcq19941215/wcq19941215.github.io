<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-4）]]></title>
    <url>%2F2018%2F02%2F27%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[突破512字节的限制前面我们的工作是完成了一个简陋的引导扇区，虽然感觉没做啥，但是我们实际上积累了很多代码，熟悉了保护模式。并且对存储管理、特权级控制等有了一个整体的认识。下面，我们要想办法将自己的OS进入到保护模式，虽然进入保护模式不难，但是总会收到引导扇区512字节的限制，所以下面，我们再建立一个文件，将其通过引导扇区加载入内存，然后将控制权交给它。首先，我们先理清楚一个问题，是不是被引导扇区加载到内存的就是操作系统的内核呢，我们先看看一个操作系统从开机到开始运行要经过一个怎样的过程：引导-&gt;加载内核入内存-&gt;跳入保护模式-&gt;开始执行内核。所以，很明显，在内核开始执行前，不仅仅要加载内核，还有跳入保护模式等等，而这些工作都由引导扇区来做，很有可能不止512字节，所以我们把这个过程交给叫做Loader的模块来做。引导扇区负责把Loader加载到内存，并把控制权交给它，然后其他工作都由Loader来做，而它就没有512字节的限制了。 FAT12FAT12是DOS时代就开始使用的文件系统，直到现在还在使用。几乎所有的文件系统都会把磁盘划分为若干层次（扇区：磁盘上的最小数据单元；簇：一个或者多个扇区；分区：通常指整个文件系统）以方便组织和管理，所以我们将软盘做成FAT12格式，以方便Kernel的操作。引导扇区是整个软盘的第0个扇区，在这个扇区中有一个很重要的数据结构叫做BPB(BIOS Parameter Block)，引导扇区的格式如下图：其中，名称以BPB开头的域输入BPB,以BS_开头的域只是引导扇区的一部分。以下是整个软盘的结构图：接下来，我们试着把Loader复制到软盘上，并引导扇区找到并加载它。为简单起见，我们规定Loader只能放在根目录中，而根目录信息存放在FAT2后面的根目录区中。所以先研究根目录区。根目录区位于第二个FAT表之后，开始的扇区号为19，它有若干个目录条目组成，条目最多有BPB_RootEntCnt个。由于根目录的大小依赖BPB_RootEntCnt的，所以长度不固定。根目录区中的条目格式：当我们寻找Loader时，只要发现文件名正确就认为它是我们要找的那一个文件。其中最重要的信息是DIR_FstClus，即文件开始簇号，它会告诉我们文件存放在磁盘的什么位置，从而让我们可以找到它。由于一簇只包含一个扇区，所以简化起见，下面都用扇区来替代簇。，需要注意的是，数据区的第一个簇号是2。所以，我们必须计算根目录区所占的扇区数才能知道数据区的第一个簇在哪里。假设根目录区总共有RootDirSectors个扇区，则有： 1RootDirSectors = ((BPB_RootEntCnt*32)+(BPB_BytsPerSec-1))/BPB_BytsPerSec 有了以上公式，可以通过根目录区找到文件并看到内容，而FAT的作用在于，如果文件大于512字节，我们需要FAT表来找到所有的簇。 DOS可以识别的引导盘既然引导扇区需要有BPB等头信息才能被微软识别，我们就先加上它，让程序开头变成下面的形式：1234567891011121314151617181920212223jmp short LABEL_START ; Start to boot. nop ; 这个 nop 不可少 ; 下面是 FAT12 磁盘的头 BS_OEMName DB 'ForrestY' ; OEM String, 必须 8 个字节 BPB_BytsPerSec DW 512 ; 每扇区字节数 BPB_SecPerClus DB 1 ; 每簇多少扇区 BPB_RsvdSecCnt DW 1 ; Boot 记录占用多少扇区 BPB_NumFATs DB 2 ; 共有多少 FAT 表 BPB_RootEntCnt DW 224 ; 根目录文件数最大值 BPB_TotSec16 DW 2880 ; 逻辑扇区总数 BPB_Media DB 0xF0 ; 媒体描述符 BPB_FATSz16 DW 9 ; 每FAT扇区数 BPB_SecPerTrk DW 18 ; 每磁道扇区数 BPB_NumHeads DW 2 ; 磁头数(面数) BPB_HiddSec DD 0 ; 隐藏扇区数 BPB_TotSec32 DD 0 ; wTotalSectorCount为0时这个值记录扇区数 BS_DrvNum DB 0 ; 中断 13 的驱动器号 BS_Reserved1 DB 0 ; 未使用 BS_BootSig DB 29h ; 扩展引导标记 (29h) BS_VolID DD 0 ; 卷序列号 BS_VolLab DB 'OrangeS0.02'; 卷标, 必须 11 个字节 BS_FileSysType DB 'FAT12 ' ; 文件系统类型, 必须 8个字节 把生成的Boot.bin写入磁盘引导扇区，运行的效果没有变。说明我们现在的软盘已经能被DOS以及Linux识别了，我们已经可以方便地往上添加或删除文件了。 一个最简单的Loader我们先写一个最小的，让其显示一个字符，然后进入死循环。新建一个loader.asm，其代码如下：123456789org 0100h mov ax, 0B800h mov gs, ax mov ah, 0Fh ; 0000: 黑底 1111: 白字 mov al, 'L' mov [gs:((80 * 0 + 39) * 2)], ax ; 屏幕第 0 行, 第 39 列。 jmp $ ; 到此停住 我们将其编译,命令如下：1nasm loader.asm -o loader.bin 为了以后扩展不出问题，我们将编译后的二进制文件放在某个段内偏移0x100的位置。 加载Loader如内存要加载一个文件如内存，免不了要读软盘，这时就要用到BIOS中断int 13h。它的用法如下：。从上可知，中断需要的参数不是原来提到的从第0扇区开始的扇区号，而是柱面号、磁头号以及在当前柱面上的扇区号3个分量，所以需要我们自己来转换一下。对于1.44MB的软盘来说，总共有两面，每面80个磁道，每个磁道有18个扇区。下面的公式就是软盘容量的由来：12 x 80 x 18 x 512 =1.44MB 于是，磁头号、柱面号和起始扇区号可以用下图方法来计算：下面，我们先写一个读软盘区的函数：123456789101112131415161718192021222324252627push bp mov bp, sp sub esp, 2 ; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2] mov byte [bp-2], cl push bx ; 保存 bx mov bl, [BPB_SecPerTrk] ; bl: 除数 div bl ; y 在 al 中, z 在 ah 中 inc ah ; z ++ mov cl, ah ; cl &lt;- 起始扇区号 mov dh, al ; dh &lt;- y shr al, 1 ; y &gt;&gt; 1 (y/BPB_NumHeads) mov ch, al ; ch &lt;- 柱面号 and dh, 1 ; dh &amp; 1 = 磁头号 pop bx ; 恢复 bx ; 至此, "柱面号, 起始扇区, 磁头号" 全部得到 mov dl, [BS_DrvNum] ; 驱动器号 (0 表示 A 盘).GoOnReading: mov ah, 2 ; 读 mov al, byte [bp-2] ; 读 al 个扇区 int 13h jc .GoOnReading ; 如果读取错误 CF 会被置为 1, ; 这时就不停地读, 直到正确为止 add esp, 2 pop bp ret 因为这段代码中用到了堆栈，要在程序开头初始化ss和esp1234567BaseOfStack equ 07c00h ; 堆栈基地址(栈底, 从这个位置向低地址生长)....mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, BaseOfStack 读扇区的函数写好了，下面我们就开始在软盘中寻找Loader.bin12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061xor ah, ah ; `. xor dl, dl ; | 软驱复位 int 13h ; / ; 下面在 A 盘的根目录寻找 LOADER.BIN mov word [wSectorNo], SectorNoOfRootDirectoryLABEL_SEARCH_IN_ROOT_DIR_BEGIN: cmp word [wRootDirSizeForLoop], 0 ; `. 判断根目录区是不是已经读完 jz LABEL_NO_LOADERBIN ; / 如果读完表示没有找到 LOADER.BIN dec word [wRootDirSizeForLoop] ; / mov ax, BaseOfLoader mov es, ax ; es &lt;- BaseOfLoader mov bx, OffsetOfLoader ; bx &lt;- OffsetOfLoader mov ax, [wSectorNo] ; ax &lt;- Root Directory 中的某 Sector 号 mov cl, 1 call ReadSector mov si, LoaderFileName ; ds:si -&gt; "LOADER BIN" mov di, OffsetOfLoader ; es:di -&gt; BaseOfLoader:0100 cld mov dx, 10hLABEL_SEARCH_FOR_LOADERBIN: cmp dx, 0 ; `. 循环次数控制, jz LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR ; / 如果已经读完了一个 Sector, dec dx ; / 就跳到下一个 Sector mov cx, 11LABEL_CMP_FILENAME: cmp cx, 0 jz LABEL_FILENAME_FOUND ; 如果比较了 11 个字符都相等, 表示找到 dec cx lodsb ; ds:si -&gt; al cmp al, byte [es:di] jz LABEL_GO_ON jmp LABEL_DIFFERENT ; 只要发现不一样的字符就表明本 DirectoryEntry ; 不是我们要找的 LOADER.BINLABEL_GO_ON: inc di jmp LABEL_CMP_FILENAME ; 继续循环LABEL_DIFFERENT: and di, 0FFE0h ; else `. di &amp;= E0 为了让它指向本条目开头 add di, 20h ; | mov si, LoaderFileName ; | di += 20h 下一个目录条目 jmp LABEL_SEARCH_FOR_LOADERBIN; /LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR: add word [wSectorNo], 1 jmp LABEL_SEARCH_IN_ROOT_DIR_BEGINLABEL_NO_LOADERBIN: mov dh, 2 ; "No LOADER." call DispStr ; 显示字符串%ifdef _BOOT_DEBUG_ mov ax, 4c00h ; `. int 21h ; / 没有找到 LOADER.BIN, 回到 DOS%else jmp $ ; 没有找到 LOADER.BIN, 死循环在这里%endifLABEL_FILENAME_FOUND: ; 找到 LOADER.BIN 后便来到这里继续 jmp $ ; 代码暂时停在这里 这段代码就是遍历根目录区所有的扇区，将每一个扇区加载入内存，然后从中寻找文件名为Loader.bin的条目，直到找到为止。找到的那一刻，es:di是指向条目中字母N后面的那个字符。接着我们编译出boot.bin1nasm boot.asm -o boot.bin ,然后在bximage生成一个软盘映像，然后在Linux下输入命令：12345nasm loader.asm -o loader.bindd if=boot.bin of=a.img bs=512 count=1 conv=notruncsudo mount -o loop a.img /mnt/floppysudo cp loader.bin /mnt/floppy/ -v sudo umount /mnt/floppy 向Loader交出控制权上面代码调试通过后，我i门就已经成功的将Loader加载入内存了，接着我们加上一个跳转。开始执行Loader1234jmp BaseOfLoader:OffsetOfLoader ; 这一句正式跳转到已加载到内 ; 存中的 LOADER.BIN 的开始处， ; 开始执行 LOADER.BIN 的代码。 ; Boot Sector 的使命到此结束。 最后的结果如下 保护下的“操作系统”为了让自己的操作系统内核至少应该可以在Linux下用GCC编译链接，所以我们假设已经有了一个内核，Loader肯定要加载它乳内存，而且内核开始执行对的时候肯定已经在保护模式下了，所以Loader要做的只要有两件事： 加载内核如内存 跳入保护模式将来的内核是在Linux下编译链接出的ELF格式文件，直接放进内存肯定不行，下一章就会开始研究ELF格式。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>FAT12</tag>
        <tag>Loader</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[财富之路-2018最容易赚钱的调查问卷平台]]></title>
    <url>%2F2018%2F02%2F25%2F%E8%B4%A2%E5%AF%8C%E4%B9%8B%E8%B7%AF-2018%E6%9C%80%E5%AE%B9%E6%98%93%E8%B5%9A%E9%92%B1%E7%9A%84%E8%B0%83%E6%9F%A5%E9%97%AE%E5%8D%B7%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[91问问调查https://www.91wenwen.net/event/invite/hn1XX9NE0Ks%253D 1、注册送积分。注册的时候送50积分=0.5元，等你完善个人信息的时候再送200积分=2.5元。 2、调查赚钱。登陆账户后，进入调查中心，里面有适合你的调查问卷，认真参与，即可获得奖励。每参加一次调查，获得2-10元。 3、有奖出题。参加快速问答（也就是投票）的设计，设计的问答被网站选用即可获取200积分 投吧http://www.votebar.com/r.aspx?r=572819231769001075 老牌网站，操作简单，内容丰富，成功率高，二十四小时更新，奖励会即时到账户里，满10元可提现；每天签到就有奖，最大的缺点是有时有点卡，一旦出现卡顿，成功机率就会下降，这时就下线吧，等下次再答。这个网站是我的最爱，因为第一个注册的就是它，从开始到现在，已经过万字头。 第一调查网http://www.1diaocha.com/user/Register.aspx?account=wcq19941215应该说国内最早开始的调查网站，内容丰富]]></content>
      <categories>
        <category>财富之路</category>
      </categories>
      <tags>
        <tag>网赚</tag>
        <tag>调查问卷</tag>
        <tag>学生兼职</tag>
        <tag>投吧</tag>
        <tag>赚钱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-3）]]></title>
    <url>%2F2018%2F01%2F24%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[页式存储说到这个，应该不会太陌生，但是对它可能值停留在理论学习阶段，没法像数据结构那样，理性的认识，下面我们先从几个问题出发 什么叫做“页”所谓“页”，就是一块内存，在80386中，页的大小是固定的4096字节。而后来，页的大小还可以是2MB或者4MB，并且可以访问多于4GB的内存。 逻辑地址、线性地址、物理地址在未打开分页机制时，线性地址等同于物理地址。当分页开启时，分段机制将逻辑地址转换成线性地址，然后在通过分页机制变为物理地址。 为什么分页 -分段管理机制，已经提供了很好的保护机制，而分页的主要目的是在线实现虚拟存储器。线性地址中，任意一个页都能映射到物理地址中的任何一个页。1.分页机制概述分页机制就像一个函数：物理地址 = f(线下地址)我们通过下图看看f是怎样的。如图所示，转换使用两级页表，第一级叫做页目录，大小为4KB，存储在一个物理页中，每个表项4字节长，公有1024个表项。每个表项对应第二级的一个页表，第二级的每一个页表也有1024个表项，每一个表项对应一个物理页。页目录的表项简称PDE，页表的表项简称PTE.进行转化时，先是从由寄存器cr3指定的页目录中根据线性地址的高10位得到页表地址，然后在页表中根据线性地址的第12到21位得到物理页首地址，将这个首地址加上线性地址低12位，便得到了物理地址。分页机制是否生效的开关位于cr0的最高位PG位。如果PG=1，则分页机制生效。2.编写代码启动分页机制下面，我们在pmtest2.asmde 基础进行修改，将实验内存写入和读取的描述符、代码以及数据统统去掉，并添加这样一个函数SetupPaging,代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PageDirBase equ 200000h ; 页目录开始地址: 2MPageTblBase equ 201000h ; 页表开始地址: 2M+4K...LABEL_DESC_PAGE_DIR: Descriptor PageDirBase, 4095, DA_DRW;Page DirectoryLABEL_DESC_PAGE_TBL: Descriptor PageTblBase, 1023, DA_DRW|DA_LIMIT_4K;Page Tables...SelectorPageDir equ LABEL_DESC_PAGE_DIR - LABEL_GDTSelectorPageTbl equ LABEL_DESC_PAGE_TBL - LABEL_GDT...; 启动分页机制 --------------------------------------------------------------SetupPaging: ; 为简化处理, 所有线性地址对应相等的物理地址. ; 首先初始化页目录 mov ax, SelectorPageDir ; 此段首地址为 PageDirBase mov es, ax mov ecx, 1024 ; 共 1K 个表项 xor edi, edi xor eax, eax mov eax, PageTblBase | PG_P | PG_USU | PG_RWW.1: stosd add eax, 4096 ; 为了简化, 所有页表在内存中是连续的. loop .1 ; 再初始化所有页表 (1K 个, 4M 内存空间) mov ax, SelectorPageTbl ; 此段首地址为 PageTblBase mov es, ax mov ecx, 1024 * 1024 ; 共 1M 个页表项, 也即有 1M 个页 xor edi, edi xor eax, eax mov eax, PG_P | PG_USU | PG_RWW.2: stosd add eax, 4096 ; 每一页指向 4K 的空间 loop .2 mov eax, PageDirBase mov cr3, eax mov eax, cr0 or eax, 80000000h mov cr0, eax jmp short .3.3: nop ret; 分页机制启动完毕 ---------------------------------------------------------- 可以看到，PageDirBase和PageTblBase是两个宏，指定了页目录表和页表在内存中的位置。页目录表位于地址处2MB，有1024个表项，占用4KB空间爱你，紧接着页目录表便是页表，位于地址2MB+4KB处。为了罗技清晰和代码编写便捷，我们分别定义两个段，用来存放页目录表和页表，大小分别是4KB和4MB。为了简单起见，我们就爱那个所有线性地址映射到相同的物理地址，于是线性地址和物理地址的关系符合下面的公式:物理地址 = f（线性地址） = 线性地址下面，我们看看PDE和PTE 3.PDE和PTBPDE:PTE： 读写权限。此位与U/S位和寄存器cr0中的WP位相互作用。R/W=0表示只读；R/W=1表示刻度并可写。 U/S指定一个页或者一组页的特权级。此位与R/W位和寄存器cr0中的WP位相互作用。U/S=0表示系统级别，如果CPL为0、1、2那么他便是在此级别；U/S=1表示用户级别，如果CPL为3，那么他便是在此级别。如果cr0中WP位为0，那么即便用户级页面的R/W=0，系统级陈翔任然具备写权限；如果WP位为1，那么系统级程序也不能写入用户级只读页。 PWT用于控制对单个页或者页表的缓冲策略。 PCD用于控制对单个页湖综合页表的缓冲。 A指示页或页表是否被访问。 D指示页或页表是否被写入 PS决定页大小 PAT选择PAT条目 G指示全局页CPU会将最近常用的页目录和页表项保存在一个叫做TLB的缓冲区中。只有在TLB中找不到被请求页的转换信息时，才会到内存中去寻找。当页目录或页表项被更改时，操作系统应该马上使TLB中对应的条目无效，以便下次使用到此条目时让他获得更新。当cr0被加载时，所有TLB都会自动无效，除非页或页表条目的G位被设置。4.cr3cr0指向页目录表，它的结构如图：cr3又叫做PDBR。它的高20位将是页目录表首地址的高20位，页目录首地址的低12位会是0，也就是说页目录表会是4KB对齐的。类似的，PDE中的页表基址以及PTE的页基址也是如此。5.克勤克俭用内存前面，我们用来 4MB的空间来存放页表，并用它映射了4GB的内存空间，而我们的物理内存不见得有这么大，这显然是太浪费了。如果我们的内存总数只有16MB的话，知识页表就占有25%的内存空间爱你了。而实际上如果仅仅是对等映射的话，16MB的内存只要4个页表就够了。所以我们有必要知道内存有多大，然后根据内存大小确定多少页表是够用的。那么程序如何知道机器内存有多少内存呢？实际上方法不止一个，在此，我们仅介绍一种通用性比较器的，就是利用中断15h.在调用它之前，需要填充如下寄存器： eax int 15h 可完成许多工作，主要由ax的值决定，我们想要获取内存信息，需要将ax赋值为0E820h。 ebx 放置着“后续值”，第一次调用时ebx必须为0. es:di 指向一个地址范围描述符结构ARDS，BIOS将会填充此结构。 ecx es：di所指向的地址范围描述符结构的大小，以字节为单位。 edxd 0534D4150h(‘SMAP’) BIOS将会使用此标志，对调用者将要请求的系统映像信息进行校验，这些信息会被BIOS放置到es:di所指向的结构中。中断调用之后，结果存放于下列寄存器之中。 CF CF=0表示没有错误，否则存在错误。 eax 0534D4150h(‘SMAP’). es:di 返回的地址房范围描述符结构指针，和输入值相同。 ecx BIOS填充在地址范围描述中的字节数量，被BIOS所返回的最小值是20字节。 ebx 这里放置着为等到下一个地址描述符所需要的后续值，这个值的实际形势依赖于具体的BIOS的实现，调用者不必关心他的具体形式，只需在下次迭代时将其原封不懂的放置在ebx中，就可以通过它获取下一个地址范围描述符。如果它的值为0，表示它是组后一个地址范围描述符。6.进一步体会分页机制在此之前，不知道你有没有注意股哦一个细节，如果你写一个程序，并改个名复制一份，然后同时调用，你会发现，从变量地址到寄存器的值，几乎全部都是一样的！这就是分页机制的功劳，下面我们就来摸摸你下这个效果。先执行某个线性地址处的模块，然后通过改变cr3来转换地址映射关系，再执行同一个线性地址处的模块，由于地址映射已经改变，所以两次得到的应该是不同的输出。映射关系转化前的情形如图：从上图很清楚的可以看到，LinearAddrDemo地址映射到ProcFoo打印出红色的字符串Foo，所以执行时我们应该可以看到红色的Foo。随后，我们改版地址映射关系，变化成如图所示：页目录表和页表的切换让LinearAddrDemo映射到ProcBar处，所以当我们再一次调用过程ProcPagingDemo时，程序将装异到ProcBar处执行，我们将看到红色的字符串Bar。中断和异常中断我们一直在用，最近的一次是通过int 15h得到了计算机内存信息。但是这都是在实模式下进行的，然后在保护模式下显示出来。这是因为在保护模式下，中断机制发生了很大变化，原来的中断向量表已经被IDT所代替，实模式下能用的BIOS中断在保护模式下已经不能用了。你可能没有听过IDT，它也是个描述符，叫做中断描述符表。IDT中的描述符可以是下面三种之一： 中断门描述符 陷阱门描述符 任务门描述符IDT的作用是将每一个中断向量和一个描述符对应起来。下图是中断向量到中断处理程序的对应过程。联系调用门，我们知道，其实中断门和陷阱门的作用机理几乎是一样的，只不过使用调用门时使用call指令，而这里我们使用int指令。其中，IDT中的任务门在某些操作系统中根本就没有用到，所以我们不做过多关注。对比调用门我们知道，在中断门和陷阱门中BYTE4的低5位变成了保留位，而不再是Param Count。而且，表示TYPE的4位也将变为0XE(中断门或0XF(陷阱门。知道这些还不够，因为中断还涉及处理器与硬件的联系等。中断和异常机制中断和异常都是在程序执行过程中的强制转移，转移到相应的处理程序。中断通常在程序执行时因为硬件而随机发生，它们通常用来处理处理器外部的事件，比如外围设备的请求。当然软件也可以通过int n指令来产生中断。异常则通常在处理器执行指令过程中检测到错误时发生。他们通俗来讲，都是软件或者硬件发生了某种情形而通知处理器的行为。那么。处理器可以处理哪些问题，以及如何处理呢？下表给出了答案：三种错误类型： Fault 是一种可被更正的异常，而且一旦被更正，程序可以不失连续地继续执行。当一个fault发生时，处理器会吧产生fault的指令之前的状态保存起来。 Trap 是一种在发生trap的指令之后立即被报告的异常，它也允许程序或任务不失连续性的继续执行。异常处理程序的返回地址将会是产生trap的指令之后的那条指令。 Abort 是一种不总是报告精确异常发生未知的异常，他不允许陈翔或任务继续执行，而是用来报告严重错误的。外部中断中断有外部中断，由硬件产生的中断，另一种是由指令int n产生的中断。外部中断，分为不可屏蔽中断（NMI）和可屏蔽中断两种。分别由CPU的两根引脚NMI和INTR来接收。如图：可屏蔽中断与CPU的关系是通过对可编程中断控制器8259A建立起来的。8259A是中断机制中所有外围设备的一个代理，这个代理不但可以根据优先级在同时发生中断的设备中选择应该处理的请求，而且可以通过对其寄存器的设置来屏蔽或打开相应的中断。主8259A对应的端口地址为20h和21h，从8259A对应的端口地址是A0h和A1h。编程操作8259A对8259A的设置是通过向相应的端口写入特定的ICW（Initialization Command Word）来实现的，它的格式如下：下面是设置8259A的代码项目地址：下载地址密码：akis12345678910111213141516171819202122232425262728293031323334353637383940414243; Init8259A ---------------------------------------------------------------------------------------------Init8259A: mov al, 011h out 020h, al ; 主8259, ICW1. call io_delay out 0A0h, al ; 从8259, ICW1. call io_delay mov al, 020h ; IRQ0 对应中断向量 0x20 out 021h, al ; 主8259, ICW2. call io_delay mov al, 028h ; IRQ8 对应中断向量 0x28 out 0A1h, al ; 从8259, ICW2. call io_delay mov al, 004h ; IR2 对应从8259 out 021h, al ; 主8259, ICW3. call io_delay mov al, 002h ; 对应主8259的 IR2 out 0A1h, al ; 从8259, ICW3. call io_delay mov al, 001h out 021h, al ; 主8259, ICW4. call io_delay out 0A1h, al ; 从8259, ICW4. call io_delay mov al, 11111110b ; 仅仅开启定时器中断 ;mov al, 11111111b ; 屏蔽主8259所有中断 out 021h, al ; 主8259, OCW1. call io_delay mov al, 11111111b ; 屏蔽从8259所有中断 out 0A1h, al ; 从8259, OCW1. call io_delay ret; Init8259A --------------------------------------------------------------------------------------------- 这段代码分别往主、从两个8259A各写入了4个ICW。在往8259A写入ICW2时，我们看到IRQ0对应了中断向量号20h，于是，IRQ0~IRQ7就对应中断向量20h~27h；类似的还有其他的。在代码后半部分，我们通过对端口21h和A1h的操作屏蔽了所有的外部中断，这一次写入的不再是ICW了，而是OCW(Operation Control Word)格式如下：可见，若想屏蔽某一个中断，将对应的那一位设为1即可。 建立IDT以及实现一个中断对8259A操作完成后，就是建立IDT了。为了方便操作，我们把IDT放进一个单独的段中。在pmtest9a.asm中可以看到，这个iDT不能再简单了，全部的255个描述符完全相同，都设置指向SelectorCode32:SpuriousHandler的中断门。SUpriousHandler也很简单，在屏幕的右上角打印红色的！，然后进入死循环。我们可以修改下IDT,把80h号中断单独列出来，并新增加一个函数来处理这个中断：UserIntHandler，它和SuprioustHandler很类似，只是在函数末尾通过iretd指令返回，而不是进入四循环。代码如pmtest9c.asm，运行结果如下： 时钟中断可屏蔽中断与NMI的区别在于是否收到IF位的影响，而8259A的中断屏蔽寄存器（IMR）也影响着中断是否会被响应。所以，外部可屏蔽中断的发生就受到两个因素的影响，只有当IF位为1，并且IMR相应位为0时才会发生。在代码pmtest9.asm的387行到392行可以看到，这个中断处理程序很简单，除了发送EOI的两行语句以及iretd，只有一条指令，就是把屏幕第0行、第70行的字符增一，变成ASCII中位于它后面的字符、由于第0行、第70行已被写入字符I,所以第一次中断发生时，那里会变成J，再次中断就变成K,以后每发生一次时钟中断，字符就会变动一次，就会看到不断变化中的字符。 保护模式下的I/O保护模式对I/O也做了限制，用户进程如果不被允许，是无法进行I/O操作的，这种限制通过两个方面来实现，IOPL和I/O许可位图。 IOPL她位于寄存器eflags的第12、13位，如图指令in、ins、out、outs、cli、sti只有在CPL&lt;=IOPL时才执行。可以改变IOPL的指令只有popf和iretd，只有运行在ring0的程序才能将其改变。运行在低特权级下的程序无法改变IOPL.指令popf同样可以用来改变IF,只有CPL&lt;=IOPL时，popf才可以成功将IF改变。 I/O许可位图之所以叫做位图，是因为它的每一位表示一个字节的端口地址是否可用，若为0表示可用，若为1表示不可用。由于每一个任务都可以有单独的TSS，所以每一个任务可以有它单独的I/O许可位图。I/O许可位图必须以0FFh结尾。若I/O许可位图基址大于或等于TSS段界限，就表示没有I/O许可位图，若CPL&lt;=IOPL，则所有I/O指令都会引起异常。I/O许可位图的使用使得即时在同一特权级下不同的任务也可以有不同的I/O访问权限保护模式小结“保护模式”包含如下几个方面的含义： 在GDT、LDT以及IDT中，每一个描述符都有自己的界限和属性等内容，是对描述符所描述对象的一种限定和保护 分页机制中的PDE和PTE都含有R/W以及U/S位，提供页级保护 页式存储的使用使得应用程序使用的是线性地址空间而不是物理地址，于是物理内存就被保护起来 中断不再像实模式下一样使用，也提供特权检验等内容 I/O指令不再随便使用，于是端口被保护起龙 在程序运行过程中，如果遇到不同特权级间的访问等情况，会对CPL、RPL、DPL、IOPL等内容进行非常严格的检验，同时可能伴随堆栈的切换，这都对不同层级的程序进行了保护。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>页式存储</tag>
        <tag>中断和异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2-2）]]></title>
    <url>%2F2018%2F01%2F20%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[保护模式进阶前面我们学习了保护模式，对它的一个整体有了了解，其中突出讲解了保护模式下的强大寻址能力，但是保护模式不仅仅有这个优点，下面我们继续学习保护模式。 1.补个坑前面我们还是把保护模式写在引导扇区，这就限制在了512字节，我们就借用DOS的引导扇区来解除这个限制。首先，我们按照如下操作进行： 到Bochs官网下载FreeDOs。解压后将其中的a.img复制到工作目录下，并改名为freedos.img。 然后用bximage深层一个软盘映像，命名为pm.img。 在修改bochsrc，为如下： 1234567891011121314151617181920212223242526################################################################ Configuration file for Bochs################################################################ how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file=$BXSHARE/BIOS-bochs-latest vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest # what disk images will be usedfloppya: 1_44=freedos.img, status=insertedfloppyb: 1_44=pm.img, status=inserted# choose the boot disk.boot: a# where do we send log messages?# log: bochsout.txt# disable the mousemouse: enabled=0# enable key mapping, using US layout as default.keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map 然后启动bochs ,初始化b盘，如图： 再将代码中的07c00h改为0100h，并重新编译如图 1nasm pmtest2.asm -o pmtest2.com 再将pmtest2.com复制到软盘pm.img上,执行如下图命令： 123sudo mount -o loop pm.img /mnt/floppysudo cp pmtest2.com /mnt/floppy/sudo umount /mnt/floppy 最后的调试结果如图： 2.保护模式进阶正题坑补完了，下面正式开始保护模式的进阶学习，前面我们提到实模式下1MB的寻址能力太差了，上一篇为了突出重点，所以最后直接写的死循环，所以想要退出，只能重启电脑，现在我们尝试体验下保护模式强大的寻址能力。首先实验下读写大地址内存。在前面的代码的基础上，新建一个段段以5MB为基址，远远超出实模式下的1MB界限。新增的代码段为：123LABEL_DESC_DATA: Descriptor 0, DataLen-1, DA_DRW ; DataLABEL_DESC_STACK: Descriptor 0, TopOfStack, DA_DRWA+DA_32; Stack, 32 位LABEL_DESC_TEST: Descriptor 0500000h, 0ffffh, DA_DRW 在上篇代码的这个位置：123SelectorData equ LABEL_DESC_DATA - LABEL_GDTSelectorStack equ LABEL_DESC_STACK - LABEL_GDTSelectorTest equ LABEL_DESC_TEST - LABEL_GDT 然后需要添加的代码如下：123456789101112131415161718192021222324[SECTION .data1] ; 数据段ALIGN 32[BITS 32]LABEL_DATA:SPValueInRealMode dw 0; 字符串PMMessage: db "In Protect Mode now. ^-^", 0 ; 在保护模式中显示OffsetPMMessage equ PMMessage - $$StrTest: db "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 0OffsetStrTest equ StrTest - $$DataLen equ $ - LABEL_DATA; END of [SECTION .data1]; 全局堆栈段[SECTION .gs]ALIGN 32[BITS 32]LABEL_STACK: times 512 db 0TopOfStack equ $ - LABEL_STACK - 1; END of [SECTION .gs] 如下图所示接下来我就不贴代码了，主要分析代码，理解其中原理，具体代码可以在这里下载密码为：xang 3.代码以及原理分析我们直接看到第166行，也就是[SECTION .s32]段，这一段首先将ds、es、gs分别初始化，ds指向新增的数据段，es指向新增的5MB内存，gs指向显存。之后是显示字符串，再然后是开始读写大地址内存了（第198行到200行），由于要读写2次相同的内存，所以我们读写分别用函数TestRead、TestWrite来表示这两个函数的入口分别在206行和222行，其中TestRead还调用了DispAL（将al中的字节用16进制数表示，字的前景色任然是红色）和DispReturn（模拟回车，让下一个字符显示在下一行的开头处）这两个函数。注意edi始终要指向显示的下一个字符的位置，所以，如果程序除了显示字符外还用到edi，需要事先保存它的值，以免在显示时产生混乱。最后，我们说下如何在保护模式下跳转到实模式。因为我们不能从323位代码返回实模式，只能从16位返回，这是因为无法实现从32位代码段返回时，cs高速缓冲寄存器中的属性符合实模式的要求（实模式不能改变段属性）。所以我们增加了第15行Normal描述符，在返回实模式之前，应该把选择子SelectorNormal加载到ds、es、ss.下面我们再看看返回到实模式的段[SECTION .s16code]，如上所说，把Normal赋给ds、es、fs、gs和ss，然后cr0的PE位置为0，接下来跳转。这块还不理解，以后理解了再补上！！！再跳回实模式之后，关闭A20，打开中断，重新回到原来的样子。 4.LDT（Local Descriptor Table）- 感性认识LDT是局部描述符表的建成，我们先还是通过代码来对它产生感性认识。在这里，我就不再贴代码了，仅仅把重要的代码写出来，方便理解。下面有这个部分的完整可执行代码下载。下面是代码执行完的结果：[这里下载]https://pan.baidu.com/s/1mkj6GPi)密码为：uzja - 代码分析在pmtest3.asm中，从11行开始到134行，是对LDT的初始化，包括对选择子的创建。接着是新增的两个节，其中一个是新的描述符表，也就是LDT，另一个是代码段，对应新增的LDT中的一个描述符。然后在217行到220行，是加载ldte，这里和GDT很相似，但是在选择子上，多了一个SA_TIL,这个属性在pm.inc中可以看到，是：1SA_TIL EQU 4 从上图可知这个属性将SelectorLDTCodeA的TI位 置为1.这一位是区别GDT的选择子和LDT的选择子的关键。如果TI被置位，那么系统将从LDT中寻找相应描述符。总结下这部分内容，我们已经看到，在描述符中段基址段界限定义了一个段的范围，这无疑是一种对段的保护。所以，不知不觉，我们已经接触到了一些保护机制。接下来，我们将加深对“保护”的理解，下面，我们即将介绍的是特权级。 5.特权级 特权级概述在IA32的分段机制中，特权级总共有4个特权级别，从高到低分别为0、1、2、3.数字越小特权级越大。所以我们也将高特权的称为内层，而把低特权级称为外层。 CPL、DPL、RPLCPU通过识别以上三种特权级进行特权级检验。首先，CPL（Current Priviliege Level）。它是当前只想能够的程序或者任务的特权级，被存储在cs和ss的第0位和第1位上。在通常情况下，CPL等于代码所在的段的特权级。在遇到一致代码段时，可以被相同或者更低特权的代码访问。否则不改变CPL。其次，DPL（Descriptor Privilege Level）。DPL表示段或者门的特权级。它被存储在段描述符或者门描述符的DPL字段中。根据门或者段的类型不同，DPL将会被区别对待。在数据段中，DPL规定了可以访问此段的最低特级权；在非一致代码段，DPL规定访问此段的特权级；在调用门，DPL规定了当前执行的程序或任务可以访问此调用门的最低特权级，和数据段一样。最后，RPL（Requested Privilege Level）。RPL是通过段选择子的第0位和第1位表现出来的。CPU通过检测RPL和CPl来确认一个访问请求是否合法。也就是说，如果RPL的数字比CPL大，呢么RPL将会起决定性作用。操作系统往往用RPL来避免低特权应用访问高特权段内的数据。 一个特权级检验实验由上面我们很容易知道，对于数据的访问，特权级检验还是比较简单的，只要CPL和RPL都小于被访问的数据段的DPL就可以了。我们现在就开始实验：首先，将先前例子中的数据段描述符的DPL修改一下，将LABEL_DESC_DATA对应的段描述符的DPL修改为1：1LABEL_DESC_DATA: Descriptor 0, DataLen - 1, DA_DRW+DA_DPL1 ; Data 运行后结果不变。接着，继续将刚修改过的数据段的选择子RPL改为31SelectorData equ LABEL_DESC_DATA - LABEL_GDT+SA_RPL3 这时，出现错误了这个错误很好理解，我们违反了特权级的规则，用RPL=3的选择子去访问DPL=1的段，浴室引起异常。而我们又没有相应的异常处理模块，于是出错。下面，我们再看看不同特权级之间的转移情况是怎样的。 不同特权级代码之间的转移程序从一个代码段到另一个代码段之前，目标代码的选择子会被加载到cs中。作为加载过程的一部分，处理器会坚持描述符的界限、类型、特权级等。程序控制转移的发生，可以是由指令jmp、call、ret、sysenter、sysexit、int或iret引起，也可以由中断和异常机制引起。6.特权级转移 首先，同门先来看看通过jmp或者call进行直接转移对通过jmp或call进行直接转移，如果目标是非一致性代码段，要求CPL必须等于目标段的DPL，同时要求RPL小雨等于DPL；如果是一致代码段，则要求CPL大于或者等于目标段的DPL，此时RPL不做检查。所以想要自由的进行不同特权级之间的转移，就需要用门或者TSS.-接着， “门”的初体验门也是一种描述符，它的结构如下：门描述符的结构就是这样子，直观可以看出，一个门描述了有一个选择子和一个偏移所指定的线性地址，程序正是同这个地址进行转移的。门描述符分为4种：（1）调用门（Call Gates）（2）中断门（Interrupt Gates）（3）陷阱门（Trap Gates）（4）任务门（Task Gates）我们先看看调用门，值关注它的工作方式，在代码段pmtest3.asm的基础上增加一个代码段作为调用门转移的目标段：1234567891011121314151617[SECTION .sdest]; 调用门目标段[BITS 32]LABEL_SEG_CODE_DEST: ;jmp $ mov ax, SelectorVideo mov gs, ax ; 视频段选择子(目的) mov edi, (80 * 12 + 0) * 2 ; 屏幕第 12 行, 第 0 列。 mov ah, 0Ch ; 0000: 黑底 1100: 红字 mov al, 'C' mov [gs:edi], ax retfSegCodeDestLen equ $ - LABEL_SEG_CODE_DEST; END of [SECTION .sdest] 我们带酸用call指令掉哦也难怪将要建立的调用门，所以，在这段代码的结尾调用了一个retf指令。接着，计入这个代码段的描述符，选择子以及初始化这个描述符的代码。1LABEL_DESC_CODE_DEST: Descriptor 0,SegCodeDestLen-1, DA_C+DA_32; 非一致代码段,32 1SelectorCodeDest equ LABEL_DESC_CODE_DEST - LABEL_GDT 123456789; 初始化测试调用门的代码段描述符 xor eax, eax mov ax, cs shl eax, 4 add eax, LABEL_SEG_CODE_DEST mov word [LABEL_DESC_CODE_DEST + 2], ax shr eax, 16 mov byte [LABEL_DESC_CODE_DEST + 4], al mov byte [LABEL_DESC_CODE_DEST + 7], ah 初始化描述符已经能够很熟悉了，以后就不再赘述了。下面添加调用门：123; 门 目标选择子,偏移,DCount, 属性LABEL_CALL_GATE_TEST: Gate SelectorCodeDest, 0, 0, DA_386CGate+DA_DPL0 这个，我们用了一个宏Gate来初始化，这个宏可以在pm.inc中找到。他和Descriptor宏有点类似，也是将描述符的构成要素分别安置在相应的位置，是代码看起来非常清晰。我们的门描述符的属性是DA_386CGate，表示它是一个调研那个门。里面指定的选择子是SelectorCodeDest，表明代码段是刚刚新调价的代码段。偏移地址是0，表示将跳转到目标代码段的开头出。另外，我们把其DPL指定为0.好了，现在调用门准备就绪了，它指向的位置是SelectorCodeDest：0，即标号LABEL_SEG_CODE_DEST处的代码。到这里，我们就可以用call指令来使用这个调用门了，这个call指令被放进局部任务之前，由于我们新加的代码以指令retf结尾，所以代码最终将会跳回call指令的下面继续执行，所以，我们最终会看到在pmtest3执行结果的基础上，多出一个红色的字母C。如图所示：总结起来，调用门听起来很可怕，本质上只不过是个入口地址，只是增加了若干的属性而已。我们接下来，激昂要用它来实现不同特权级的代码之间的转移，下图是特权检测的规则：从上可知，通过调用门和call指令，可以实现从低特权级到高特权级的转移。 下面，我们看一下整个转移过程是怎样的。 根据目标代码段的DPL从TSS中选择应该切换至哪个ss和esp 从TSS中读取新的ss和esp。在这个过程中如果发现ss、esp或者TSS界限错误都会导致无效TSS异常 对ss描述符进行检验，若异常，同样产生异常 暂时性地保存当前ss和esp的值 加载新的ss和esp 将刚刚保存起来的ss和esp的值压入新栈 从调用者堆栈中将参数复制到被调用者堆栈中，复制参数的数目由调用门中Param Count一项来决定。 将当前的cs和eip压栈。 加载调用门中指定的心得cs和eip，开始执行被调用者过程。综上，使用调用门的过程实际上分为两个部分，一部分是从低特权级到高特权级，通过调用门和call指令来实现；另一部分是从高特权级到di低特权级，通过ret指令来实现。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>Bochs</tag>
        <tag>NASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+Coding+万网域名建站教学--如何被百度谷歌收录]]></title>
    <url>%2F2018%2F01%2F18%2FHexo-Github-Coding-%E4%B8%87%E7%BD%91%E5%9F%9F%E5%90%8D%E5%BB%BA%E7%AB%99%E6%95%99%E5%AD%A6-%E5%A6%82%E4%BD%95%E8%A2%AB%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这篇博文主要是写搭建好博客以后，想要自己的网站能被其他人看到，那么最起码能在百度或者谷歌中搜索出来。 1.准备工作首先必须得满足以下条件才能用我的方法： 一个备案过了的域名比如wcqwolflow.com,域名可以在万网上买 在Github上部署好的博客 在Coding部署好的博客被谷歌收录特别简单，但是被百度收录巨麻烦，Coding可以看成是国内的Github，因为Github嫌弃百度蜘蛛爬取的太频繁，所以屏蔽的百度。所以我的思路就是，通过对我的域名的解析操作，让国内的域名解析到Yourname.Coding.me让国外的域名解析到Yourname.github.io最后的成果就是可以通过China.com解析到如下图：2.具体步骤第一步：在Github和Coding上同时部署和发布你的小站这个网上教程一大堆，最后的结果就是执行命令123hexo cleanhexo ghexo d 后，在Coding和Github上都可以看到自己的博客文件如下：Coding：Github： 第二步：在Github和Coding上都绑定自己的域名其中要在Coding的Page服务里修改成如下：在Github的Setting里修改成如下：第三步：注册DNSPOD，并在购买域名的商家处修改DNS服务器为图中记录类型为NS的地方：在这里解释下为什么选择DNSPOD，我在万网买的一年的域名，但是万网的线路类型选择了世界以后，在DNS解析时，还是没法将海外的解析成wcq19941215.github.io，所以换成了DNSPOD图中的参数设置： 到此，域名设置都完成了，我们可以在百度和谷歌里输入site:你的域名。会显示类似下图的样子：我们点击提交网址可以看到上面的图片，具体怎么提交给百度和谷歌的方式有一大堆，可以自己去看看。 3.最关键的地方你如果按照我的做了，你在如图画圈的地方应该看到的是抓取成功 (有跳转)，那么意味着，百度蜘蛛永远无法爬取到你的网站：这是因为Coding的银牌会员默认是跳转首页，然后再跳转到你的仓库的，解决办法如下：首先在Coding的Page服务页面找到这个然后在你网站首页加上这个：加这个的方法是，在你本地找到hexo放置的地方themes\next\layout_partials\footer.swig 加上下面代码如图：123&lt;span&gt; Hosted by &lt;a href="https://pages.coding.me" style="font-weight: bold"&gt;Coding Pages&lt;/a&gt; &lt;/span&gt; 两天左右，等DNS迭代递归全球服务器解析完成和Coding首页审核完成，你就会在百度中看到这个：]]></content>
      <categories>
        <category>博客搭建遇到的坑</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>Hexo</tag>
        <tag>DNS解析</tag>
        <tag>百度抓取成功 (有跳转)</tag>
        <tag>谷歌收录</tag>
        <tag>Coding</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE-s-一个操作系统实现》保护模式（2.1）]]></title>
    <url>%2F2018%2F01%2F16%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%882-1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[保护模式和开始理解操作系统一样，我们可能对什么是保护模式完全不了解，没关系，我们先从下面代码开始。 1. 认识保护模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576%include "pm.inc" ;常量 ，宏 ，以及一些说明org 07c00h jmp LABEL_BEGIN[SECTION .gdt]; GDT; 段基址， 段界限， 属性LABEL_GDT: Descriptor 0, 0, 0;空描述符LABEL_DESC_CODE32: Descriptor 0, SegCode32Len - 1, DA_C+DA_32;非一致代码段LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW;显存首地址; GDT结束GdtLen equ $-LABEL_GDT ;GDT长度GdtPtr dw GdtLen-1 ;GDT界限 dd 0 ;GDT基地址 ;GDT选择子SelectorCode32 equ LABEL_DESC_CODE32 -LABEL_GDTSelectorVideo equ LABEL_DESC_VIDEO -LABEL_GDT; END of [SECTION .gdt][SECTION .s16][BITS 16]LABEL_BEGIN: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, 0100h ;初始化32位代码段描述符 xor eax,eax mov ax, cs shl eax,4 add eax,LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32+2],ax shr eax,16 mov byte [LABEL_DESC_CODE32+4],al mov byte [LABEL_DESC_CODE32+7],ah ;为加载GDTR做准备 xor eax,eax mov ax,ds shl eax,4 add eax,LABEL_GDT;eax&lt;-gdt基地址 mov dword [GdtPtr+2],eax;[GdtPtr+2]&lt;-gdt基地址 ;加载GDTR lgdt [GdtPtr] ;关中断 cli ;打开地址线A20 in al,92h or al,00000010b out 92h,al ;准备切换到保护模式 mov eax,cr0 or eax,1 mov cr0,eax ;真正进入保护模式 jmp dword SelectorCode32:0;执行这一句会吧SelectorCODE32装入cs, ;并且跳转到Code32Selector:0; ;END of [SECTION .s16][SECTION .s32];32位代码段，由实模式跳入[BITS 32]LABEL_SEG_CODE32: mov ax,SelectorVideo mov gs,ax;视频段选择子（目的） mov edi,(80*11+79)*2;屏幕第11行，第79列。 mov ah,0Ch ;0000:黑底 1100：红字 mov al,'P' mov [gs:edi],ax ;到此停止 jmp $SegCode32Len equ $-LABEL_SEG_CODE32;END of [SECTION .32] 可能上述代码，你看到一半就不耐烦了，没关系，先执行一下它，和前面一个章节一样，先生成pmtest.bin文件，看看效果再说，执行如图所示命令：得到的结果如下：可以看到，在屏幕的右边有个红色的“P”,显然程序的最后一部分将其写入了显存中（PS:该项目的地址都在第二篇博文里） 2. 代码解释首先，看[SECTION .gdt]段，其中的Descriptor是在pm.inc中的宏。具体意义先不用管，只用了解这是一个数据结构，8字节大小。如下:12345678910111213; 节选自pm.inc;描述符; usage: Descriptor Base, Limit, Attr; Base: dd; Limit: dd (low 20 bits available); Attr: dw (lower 4 bits of higher byte are always 0)%macro Descriptor 3 dw %2 &amp; 0FFFFh ; 段界限1 dw %1 &amp; 0FFFFh ; 段基址1 db (%1 &gt;&gt; 16) &amp; 0FFh ; 段基址2 dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) ; 属性1 + 段界限2 + 属性2 db (%1 &gt;&gt; 24) &amp; 0FFh ; 段基址3%endmacro ; 共 8 字节 在这个段中，并列的三个Decriptor，所构成的数据就是GDT()GdtLen是它的长度，GdtPtr包含6字节，前2字节是GDT的界限，后4字节是GDT的基地址.后面两个段[SECTION .16]和[SECTION .32]很容易理解是16位和32位代码段，意思就是在16位中修改了GDT中的值，然后跳转到32位，执行最后一小段显示红色P的代码，然后进入无线循环。也就是真正进入保护模式。从这个我们可以了解如下内容： 我们定义了一个叫做GDT的数据结构（可能现在有人会想，为啥到现在都不讲什么是保护模式，它有什么用？不急慢慢往后看这部分的内容很多的） 后面的16位的段，进行了一些对GDT的操作 最后jmp到了32位，执行写入显存显示红字，然后结束了 我们不明白的有： GDT是什么？有什么用？ 程序对它进行了什么操作 jmp SelectorCode32：0 和以前的jmp有什么不同 3.GDT（Global Descriptor Table）首先解释保护模式和实模式。在IA32下，cpu有保护模式和实模式两种工作模式。当我们打开PC时，cpu工作在实模式下，经过莫衷机制后，才进入保护模式。在保护模式下CPU有巨大的寻址能力，并且为32位操作系统提供了更好的硬件保障。在Intel8086时，CPU有16位的寄存器、16位的数据总线以及20位的地址总线和1MB的寻址能力。一个地址由段和偏移两部分组成，物理地址的计算公式如下：1物理地址 = 段值 * 16 + 偏移 从80386开始，CPU进入32位，有32位地址线，所以寻址空间达到4GB。所以但从寻址看，16位已经不满足了。所以需要新方法来提供更强大的寻址能力。在实模式下，16位寄存器通过段+偏移来达到1MB的寻址能力，而32为寄存器一个就可以寻址4GB的空间了，但在保护模式下，任然可用过段+偏移的方式，但是，这时的段的概念已经发生根本性的变化了。这时的段只是索引，指向了一个数据结构–GDT（也可以是LDT以后会讲）。其中的表项有个专门的明治，叫做描述符。总的来说，GDT的作用是用来提供段式存储机制。这种机制是通过寄存器和GDT中的描述符共同提供的，下面我们看看代码段和数据段描述符的结构： 在本例中的描述符有三个节选上面的 代码如下：1234567[SECTION .gdt]; GDT; 段基址， 段界限， 属性LABEL_GDT: Descriptor 0, 0, 0;空描述符LABEL_DESC_CODE32: Descriptor 0, SegCode32Len - 1, DA_C +DA_32;非一致代码段LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW;显存首地址; GDT结束 其中DESC_VIDEO的基地址为0B000h，是显存处。现在我们知道了GDT中的每一个描述符定义一个段，那么cs、ds等段寄存器是这样和这些段对应的：12mov ax,SelectorVideomov gs,ax 其中SelectorVideo为：1SelectorVideo equ LABEL_DESC_VIDEO - LABEL_GDT 其中SelectorVideo直观可以看出是DESC_VIDEO这个描述符相对于GDT基址的偏移。实际上它有专门的名称，叫做选择子，它也不是一个偏移。总之，整个段式寻址示意图如下： 到此，我们对这段代码理解的差不多了，仅剩下[SECTION .16]段了，其实也很容易了，既然下[SECTION .32]是32位程序，那么下[SECTION .16]的任务就是从实模式向保护模式跳转了。 4.实模式向保护模式的跳转首先，我们把[SECTION .16]段，拿出来仔细看看12345678910111213141516171819202122232425262728293031323334353637383940414243[SECTION .s16][BITS 16]LABEL_BEGIN: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, 0100h ;初始化32位代码段描述符 xor eax,eax mov ax, cs shl eax,4 add eax,LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32+2],ax shr eax,16 mov byte [LABEL_DESC_CODE32+4],al mov byte [LABEL_DESC_CODE32+7],ah ;为加载GDTR做准备 xor eax,eax mov ax,ds shl eax,4 add eax,LABEL_GDT;eax&lt;-gdt基地址 mov dword [GdtPtr+2],eax;[GdtPtr+2]&lt;-gdt基地址 ;加载GDTR lgdt [GdtPtr] ;关中断 cli ;打开地址线A20 in al,92h or al,00000010b out 92h,al ;准备切换到保护模式 mov eax,cr0 or eax,1 mov cr0,eax ;真正进入保护模式 jmp dword SelectorCode32:0;执行这一句会吧SelectorCODE32装入cs, ;并且跳转到Code32Selector:0;;END of [SECTION .s16] 初始化32位代码段描述符12345 add eax,LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32+2],axshr eax,16mov byte [LABEL_DESC_CODE32+4],almov byte [LABEL_DESC_CODE32+7],ah 先把[SECTION .s32]赋值给eax,然后把他分为3个部分，分别给[LABEL_DESC_CODE32的相应位置，至此初始化完成。然后，因为保护模式下的中方段处理机制是不一样的的，不关掉中断会出现错误。接着打开A20,因为它默认是关闭的。（具体这块的解释因为涉及到8086的历史问题，就不再赘述了）最后的一部分代码中的寄存器cr0如图所示所以代码中的0到1，是决定性的，因为cr0的0号位置是PE,此位是0时为实模式，为1时是保护模式！ 执行完1mov cr0 , eax 系统就运行在保护模式下了。但是此时cs的值任然是实模式下的值，我们需要把代码段的选择子装入cs。所以才有了：1jmp dword SelectorCOde32:0 这个jmp看起来稍微复杂了点，因为它不得不放在16位的段中，目标却是32位的。至此，我们成功进入保护模式。下面我们总结进入保护模式的主要步骤： 准备GDT. 用lgdt加载gdte. 关中断。 打开A20。 置cr0的PE位为1. 跳转，进入保护模式。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>保护模式</tag>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>Bochs</tag>
        <tag>NASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE's:一个操作系统实现》搭建工作环境（1）]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E6%90%AD%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[BOchs虚拟机可以让我们像上帝一样，随时让时间“停住”钻进计算机里的小计算机里，CPU、内存、硬盘等尽收眼底 Bochs虚拟机的安装安装环境：Window7 64位下的Vm虚拟机（11.0.4）下的Ubuntu16.0.4 Bochs2.6.9安装过程： 1我在官网下载好bochs-2.6.9.tar.gz后，放在MyOS目录下，第一步解压1sudo tar zxvf bochs-2.6.9.tar.gz Bochs下载链接 2进入bochs-2.6.9目录下开始编译安装：1sudo make 1sudo make install 3安装完成后如图 Bochs的使用1创建一个软盘映像代码如图所示：完成以后，在当前目录下就多出了一个a.img 现在我们有了“计算机”和“软盘”，是时候将引导扇区写进软盘了。我们使用dd命令：1dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc 其中 boot.bin 文件需要复制到和a.img同一目录下。这行代码中“conv=notrunc”若不用，a.img会被截断，因为boot.bin比a.img小。 2配置Bochs这一步是为了说明虚拟级的内存大小、硬盘映射和软盘映射都是哪些文件。配置文件bochsrc内容如下：12345678910111213141516171819202122232425################################################################ Configuration file for Bochs################################################################ how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file=$BXSHARE/BIOS-bochs-latest vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest # what disk images will be usedfloppya: 1_44=a.img, status=inserted# choose the boot disk.boot: floppy# where do we send log messages?# log: bochsout.txt# disable the mousemouse: enabled=0# enable key mapping, using US layout as default.keyboard: keymap=$BXSHARE/keymaps/x11-pc-us.map 然后再输入命令：1bochs -f bochsrc 会出现下面内容，然后选择6，若出现黑色的框也就是Bochs那就是成功啦，然后再终端输入c,大功告成！！ 用Bochs调试操作系统我们以开始的引导扇区为例，在07c00h处设置断点，从这里开始执行，然后单步执行，和其他调试工具一样。同时在任何时刻你都可以查看CPU寄存器，或者查看某个内存地址处的内容。下面我们具体操作一下：注意！！！： bochs 2.3.5 以上的版本没有dump_cpu了,可以用r，fp，mmx，sse，dreg，sreg，creg命令代替。 附录调试命令： #接着安装GCC和NASM查看某软件是否安装的命令 * -v下载安装某软件的命令，123sudo apt-get install build-essential ***例子：安装nasmsudo apt-get install build-essential nasm]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>NASM</tag>
        <tag>Bochs2.6.9虚拟机</tag>
        <tag>Bochs配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ORANGE's:一个操作系统实现》准备工作（0）]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%8AORANGE-s-%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E3%80%8B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[马上开始动手写最小的一个“操作系统” 1.准备的工具 具有Window或者Linux的计算机 汇编编译器NASM下载地址：http://www.nasm.us/ VM虚拟机（11.1.3） MASM2015当作汇编的编辑器 2.操作系统源码123456789101112131415161718 org 07c00h ;告诉编译器程序加载到7c00处 mov ax,cs mov ds,ax mov es,ax call DispStr ;调用显示字符串例程 jmp $ ;无限循环DispStr: mov ax, BootMessage mov bp, ax ;ES:BP=串地址 mov cx, 16 ;CX=串长度 mov ax, 01301h ;AH=13,AL=01h mov bx, 000ch ;页号为0（BH=0）黑底红字（Bl=OCh，高亮） mov dl, 0 int 10h ;10h号中断 retBootMessage: db "His World dwj!" times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节dw 0xaa55 ; 结束标志 3编译源码制作img文件（软盘镜像文件）操作系统要在裸机上跑（没有操作系统的电脑），所以使用VM虚拟机来运行我们写的操作系统，同时又因为现在很多人的电脑都没有光驱了，所以没法制作光盘来做启动盘，这个时候可以用如下命令：1nasm boot.asm -o boot.img 来生成img文件，这个文件就等同于软盘文件，可以放在虚拟机里跑。具体的例子如图： （1）首先在MASM上编写汇编源码（各行代码含义后面会讲到）： （2）然后在cmd中，找到boot.asm的位置，如图： （3）然后输入命令：1nasm boot.asm -o boot.img 就可以看到，新生成了boot.img （4）打开虚拟机新建，如下列图：一路NEXT，直到下图：然后可以得到一个空白的裸机，用来跑自己写的OS用：因为我用的.img文件做虚拟软盘，所以需要编辑虚拟机设置：然后选择自己的boot.img文件在那即可 即可显示Hello World!是不是有点小激动呢，哈哈。但是，事实上，这个东西还算不上完整的操作系统，只是最简单的引导扇区，但是它和其他软件不同，它是直接在裸机上跑的，已经具备了操作系统的一个特性。 4代码解释org 07c00h：以为计算机电源被打开时，它会先进行加电自检，然后寻找启动盘，这行代码就是告诉BIOS，一旦发现了引导扇区，就将这段512字节的内容装载到0000:7c00处，然后将控制权交给这段引导代码。到此，计算机不再由BIOS中固有的程序控制，而编程由自己的OS的一部分来控制。 mov ax,cs mov ds,axmov es,ax：这三个mov指令，是将ds和es两个段寄存器指向与cs相同的段。 mov ax, BootMessage：把BootMessage中的值的首地址传给寄存器ax(pS：Nasm中，不加[]的标签或者变量都被认为是地址)。 ($-$$)：开始汇编处，距离本行的相对位置。 dw 0xaa55：计算机只有找到0xaa55为结束，才会认为是软盘启动。]]></content>
      <categories>
        <category>操作系统</category>
        <category>ORANGE&#39;s的学习</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>于渊</tag>
        <tag>NASM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王超群的博客世界]]></title>
    <url>%2F2018%2F01%2F04%2F%E7%8E%8B%E8%B6%85%E7%BE%A4%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[#写在开头的话一直都想搞个博客，但是一直都有事情耽搁了，现在在做毕设，刚好可以把以前没做的事都好好的做做。包括操作系统的实现、机器学习、算法与数据结构等等，都系统的学一下，弥补在大学没有深入学习的遗憾。 首先是博客搭建以前用过腾讯云+wordpress在Linux下建站，但是没时间管理，所以弃了，现在用的是Github+hexo，感觉很不错，也让人有欲望写学习笔记和写心得，现在把搭建博客的流程详细记录一下，为第一篇博文练手，也可以给其他像我一样想这样建立自己博客的朋友提供一个参考。具体的搭建流程可以参考https://www.cnblogs.com/visugar/p/6821777.html 下面我只把HEXO使用的相关命令贴出来： 一、将本地与git仓库对应连接起来1、绑定用户12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 2、配置ssh1$ ssh-keygen -t rsa -C "email@example.com" 3、测试ssh1$ ssh -T git@github.com 4、克隆仓库到本地1$ git clone git@github.com:Your Name/*****.github.io.git 5、初始化仓库1$ git init 二、上传项目、文件、文件夹1、上传README文件123456$ git init$ touch README.md$ git add README.md$ git commit -m 'first_commit$ git remote add origin git@github.com:Your Name/*****.github.io.git$ git push origin master 2、上传项目、文件、文件夹123456$ git add . $ git commit -m 'first_commit'$ git remote add origin git@github.com:Your Name/*****.github.io.git（如果错误 git remote rm origin）$ git push -u origin master（如果错误 git pull origin master） 三、下载项目12$ git init$ git pull git@github.com:Your Name/*****.github.io.git 其次是学习主要在完成毕设的同时，学习OS，首先学习下ORANGE’S：一个操作系统的实现这本书，手头有这本书的扫描版和相关光盘附件。 下载地址：https://pan.baidu.com/s/1o8US7J8 密码：byf9 然后再学习MIT6.828课程。预计在2018年2月就学完第一块了。剩下的计划慢慢来吧。]]></content>
      <tags>
        <tag>江汉大学</tag>
        <tag>HEXO</tag>
        <tag>Orange S：一个操作系统的实现(有光盘)</tag>
      </tags>
  </entry>
</search>
